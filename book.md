---
title: "مجموعه سوال و جواب‌های جاواسکریپتی"
author: Sudheer johna - translated by Mariotek team
date: August 30, 2020
export_on_save:
html: true
puppeteer:
     landscape: false
     printBackground: true
     timeout: 3000
     width: "170mm"
     height: "240mm"
     margin: { top: '40px', bottom: '55px', right: '40px', left: '40px'}
     displayHeaderFooter: true
     headerTemplate: '<div />'
     footerTemplate: '<div style="width: 297mm;text-align: center;font-size: 10px;font-family: BYekan;direction:rtl;position: relative; bottom: -15px">
    <span style="position: relative; top:50px"><span class="pageNumber"></span></span>
    <img style="width:100px;float:right;display: inline-block" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACcCAMAAAANmRRNAAAAOVBMVEUAAABYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtolEGJAAAAE3RSTlMAWUhRPmYIESkgNnAwGXiAjqC4Jm454QAABztJREFUeNrs2AGOAyEIBVBAEK1Os/c/7dZtO2M2PUA/4d3gB5EApZRSSimllFJKKaWUUorGKYTJTPhcmCfBm8yC/65cLIvxLcJ0hgUpRiN4UTrDIhTDQ3TGgymFUDlEOR4itMefcqMYJEiPkArFcCv0We1Yj67xpwhSmBmrVs60OaauCEVuvRIYdlocOMITt65SVgRtoBHIm4r8DBFtqPP93c9F3bA+p11/RphOi2B9TrthtYaYiJ1pM4EPisx7LOAg9d7p5MBBSI0u0KuVyRakE67jXumtQB8Xi0VZrcYMMEiWNrbVChqXdyTwIHX0V+MjD5JFxysRo64h/6+lfBC2Y9Qgx0axKMfGMQNMxGuYKPj/u3AJMBFfmwn2anWSQeTwg2QxBV+trs3EsVerExv4anUarviD5Leba9tuGgaCe9fVTsL/fyy0cZCJ0AWc4B7mzZAedxxrZzS76gc8/geK+Am+/B+vFsAtwVdBUGRm+oD8QMze+xAW55wZDEFX+CpAXXyOUUToA/wJ3IE/8JNnzBvPjebtyyyStu8zc24JwW885Xc06fbt8193PPMJGnkkUrdPno4vq9t4bkRRDc6AHbsvefbPL6vAKcDlEJHsUrk6tZGF8RAR2mKugsxwAo4+wMgl5oJz066Ix1zK1jM5v23S3uWZhyEWrIcCTxhl7j9AufCQiqF9xlxfYZCrmbJFMtUOldK1Yqw09gRw6wE6NfCqYeIxJP8Fur3tB6gZAKJ2lYbjrmdybrbtERqgO8Wo6EbVWxlOb5I6bFt8uEOUXf/7tLScP3/afoBlfZCyQUGt46LnD6lgnKgDxomsJ0NJTh9SaZuUqFBgpFJRKWHjoo+JNNaT9o0RJz2+Y5X2iHy6ePwBEu9OEpIFp986hxUVDnAfqqObLhupk4iY2rzGLHuxtxDjdWVkycu+jhOcA/SdAlxhYXIAyzbamBPXDfgI54AFWtCaoy3pdr2IbHO+JTUtYhLgHAi3OdLTkCwicgyS0Ko5jiImBufAY/+/tqqKyGXONydctk98neNKvSRF430xFApFZNA917ywGpwJDK1RZfpYDa3MTZTdk9flo6Ie1vECy9z24o1p62zdXZKRsvEvNJM/2prUIRPVtEyYFL8dPXjsrqAHY72EqgF/AJRhHcgQI/gkY5OS9M8Ot12ueX+pfPTkliWGHlIAMFU3SlKc2h/lXsKiApWYHDmChsk6n8D7bdc8SlJYYQev40NjC2os13r8CBqtDkabJKdqA5OS4v5Kl4kaEnYWTOUwEfAXPx6hltXXJqW9YJGmEr6ADyoh2WEiENbYmUvasCTumxTcX0ae3AV4xXBYTCL9XGvY3OsVUApdk5JCa/F3F1jeUrD0ktONiFBD47OAUi9JkQQFmud9QUwftNo/MK/aZcn3S4+huo5JUarirSYwV77lNUQgrmHiEH1epR1FuWTd3VUvtBYl+CvUQ9HhIrBHSL/PdtWassfa9ZRdyTR62ZbCKc/YBkm5rLF2mWOa2Ze9qV2jWr8nNZyiVUlKJSZRh2/DGyMdKp6HO3ei1TfaPYjDjVe59zuTaLmEmd8jJPq9ybUU5jq/7s1EIKQ4JbScwlZ6WmIiPFLEYxg1V2ylKV/tV/nt76o0V4DRv4lIAaoB6cRPYySo4JIr8daoa/Xm3iynuf5RvlygBulUASZ5PxEItxVmYNdkbc/scWy93z0bc7mG2fjCtw+GqRs51nf3zyJCmrqPCCRsnjJG6dqKtxIp/l1xst3DKTTERPBfCQn/nojXytj39DkkeuaXqnjrvULCvnesSwZMSg8Nn1VHaawVuLyZSFGyUDYfg/1RXKWa5S9efXTzeVgOBgWDk8wlAXGrTLV76hCPdBhvsfxNyMuIzBKDjdT1af5IdardU4d4Sep46/gUni4/2y7ITPHRtaDYOAhVwGqTezOnaM9iwnJIEXspgvORCO/ZuUMZN3DiJczaNUr+SUwEXzI83NkjOX9vyFBpjLU+7Fc/K0VhL6Or78db4Q+IjGwosUXh+/cjfrl/Ia4ifaHZJbtXR0m9eKuQnIfD0XqzEOXRAV/B6rcNp5esX6mIST/eQi3FZwqCk+vNQpYb3huxeTEowGSzb3opxG513ffHtladn5V4pPnCkfnO534PkocAxRRGb3od4pEO9dv+5K9taZgnsp8ZWXZ8SvGacBqmao+dCdLcX95i5HF6NYzje2GULZ8CJHrTnIPr7b2rQhxWyAqTsKGs4zj8HWfoZu56i6SILNG7kUAviTcxUYMXQWWaSE6DNoTVBmH/rdbdlGQUX0bEDXLLMee69+DCZhBI16UUuKqbEvFlIa/HcQDbTqIGKu98putDUN0zH0wLoL6KCPN0HUCCMROrt5mfgsqPArf8UogNNcBLoH6WyJKmBufaSVsxCCR+K8TkrxleAaezkfhcyScZiNEmqEke8cS3BK9A5h5L7pi4eTPQ9WC2foM5fAdxoS47LLn9fAAAAABJRU5ErkJggg==" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACcCAMAAAANmRRNAAAAM1BMVEUAAABYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVsrbnhhAAAAEXRSTlMAWUhRMz5mCBEpIHB6GY6ftSRD8gQAAAclSURBVHja7NhdjsMwCATgARv/tnv/467Qtitb6gE6iO8peQsieEKQUkoppZRSSimllFJK6d9AECIVMVQRDdKWoZHa0rIt3yfUtLQwbZmR2hJnWmakQ6xJkFJgDTEM6QhhCmKoBTGYIgY1MKmr47PClYoqIkU/lSMTXPqqWrwcq08cSAPxKGfADerTt0/zcoraihAjY5rq/lG1yfl6XWobVl4nAfW3iircqH/lLLA687D3tsFK6nXH25Hr0YX4CDvzcD14x/3Kw8b1/XhZRyHKvPQea1V/PMHLFG+NelVUw0vljZB7rdpse8mtzPcFcYQ4eQ342rwR4rp0wG3iCHFPCfLfdApc38wRcuRho/9JZxogQlyxABHiSg0QIU4W9xby1mUAm37SgSEBIsQtwaDeQo4YaQEmHTAb/BHy2821rikOwlByIQECuu//tHuxDq0osFu7dvf8Gj+rk5SSk5wEb3z4z3VHnoPzP13eVtjV/R+4oBtCNYRQUooxMvsfwJ8gIpDT6Kv+upi6WMrVUvoJWIF+AX/Ce8/MsXwq4AVeWfrLqG9XfGaqXyyNKZUQVDsZ5yegAouhi6UhZwq/LNUdQv7fhwe3RaSI++6Muk8AH622wLiz3v8IiB9eg8NdjvCHHIGy/FGFLOKdS/wBNIMB4uv0xj+11xnaAUAoboioboUT9Bu3Y1lqpcqMHUTKvrPER2PMXkC3sqqPKKLIJxshhLQ2wiZMSSLRqYRXS0zuE9g+RhaH04wFhH9eIydLUDaPEckofgYQvl16v+YsA2vru19M+/c0kNzf2qbqJxhYQ7+mkO40o5Jg3SedJT4WY/by1iMCRSOt19LZEpSL0H2+TEqVGR+hXlBdhfDJEhRHIXqEH4jZXg/Fe6HwkKmfLEFxtBhf5Iq3cTmXqHEDwvTzA8V9BLiOmoU9AeULc9I1jZeWK85WVTlu2+lkvAwzFucCUnENJJ3ujEOqFFL10mUO2Pt8uVrR1lpx7lwJinNaKaQpGRXMJyYAeBicRXInS1Dqdm5zjAK2eBS+xppjuF9xsgRlgea0jTs1qapY4jQhs5xOQVkAtM2Ha1LVIPDPnYOEnPRECUqtQioCKQlqtxZTfjGlzdQRa0ZIObldsLj9OiF1PdxrquWAQ5xIUIqJDP2Qne1X2vwLvuTfOw4nNk5QvEUHNKDm7HYKg6br8OXJ/5ZupRJGCkoQUeeSuR7IdM/5tC2FsEAZHxKTuHlFIwWFF8EFOmaqQVV09lJIFEkTu7Jsn0QbJCgqEkbFmAsZ9x60U0t3NyBN6WsITaDoJCgx+/FAd8yxlqv7KCSBxMqH86I3QT9BISvN6jXgnNxuR2xRqnhCKGw3d7JugpIMnRvWlfAVbZB3pfEBjKe5eStome8pKJhT89kWAHvPcFaJZ7L4awQtlE6CEgS0F/DqNn+LIyi+J2p3ayq18Fok85knDvunetVeR7Shu2llUqj57DbotrC0dSynZvz7XRgQO1InCBF/veVn0iGScFAxM74rwg2FNAqKQrMcT59GkSNbRFAmW88AL1o8MWPnPlHN8fBQKQnCXKMumT5Pi9HSzJ1I2R+qfweY3EHmn3bxktFUKsGWjhXyI8wFX5SnXvocp6oGzNppOh3+2xtV0AoWXANkmDBF0KmAcwc6MuZDpGpNi5x5rkdmdGw/eJyAQnydx6pd1M0gX9Oxje1xlhDk9QGyOCsdpEs+eBpnTK4eXp5BBnPeuwmQOeB++nM8jYB/QSHJaLLFA+Icy/GOBJgQtOzRYrTU8HKvNpf43BFyb0OBEce0FFIMasdu4IfvHUGLb3Qk0kjQaqb/feZBRdYm7ZKOdsTTUNASbMS3+tG+H6EqMfNkrIl1//RbK2h5a8S3uRaPyGaaauyIJvZEAGT4Xj709EghChImqyIVehicbMF478QwEsFXa6nIe8f4wD9QSDScTZRS5nFDyEO46fuAyDF0NIsxIPUFrZjX1JZmSSDm+KrAqs09zBek6kF7cYuesX1By/yKA6fDBObma8NtSUr0tzUgz0rYS7rnoYkF+oIWSrUtTocJEG2bydl42QacdPAV8xVXiEsrTbtPXcihBt3Z3aUG61eFby1iuFYPhpEG/O/8opYOOV+wcuDs7krGX8EU12tAPB8yEdwIBDT3K1oI9ypERbST27ThauVBWc+4zDuSZHbyYQxhl1MNuhO1fkjM8k38Lzoo2pPIWjH+MMVLZaEQsjJKCUJkTwCCfL10zsuwzBd1gO5NYFSrHY8WyC0l60CUNp52xMv7JGHgpuNRQ1HJggslp9B0DEbWjdXa8D5HBJbCYw0Nd0K7NJTcsHkLST1HDtG3k4Bugm65hyLynPRJcadjPxzC9I4mcm8BXyIuQTdu6GAB0x+N0lmZdSSKewvs2525vVUPehTgcYqcpsV4Ce4d+Ja1k1N1aXo+SaXQF9x6+A4+TyvoMJMD8AAAAABJRU5ErkJggg==" style="float:left;width: 100px;display: inline-block" />
  </div>'
---

<div dir="rtl" align="right">

<img src="images/image-MariotekLogo.png" alt="Mariotek" align="center" />

# مجموعه سوال و جواب‌های جاواسکریپتی

> اگه از کتاب خوشتون اومد به گیت‌هابمون مراجعه کنین و بهمون :star: بدین. اگر هم قصد مشارکت داشتید همونجا می‌تونین شروع کنین و ما هم خیلی خوشحال می‌شیم :)

<span class="show-in-print">

> لینک گیت‌هاب ما برای مشارکت برای تولید کتاب‌ها: <a style="float:left" href="http://github.com/mariotek">https://github.com/mariotek</a>

</span>

### نحوه دانلود کتاب به فرمت‌های PDF/Epub

می‌تونین خیلی راحت نسخه آنلاین کتاب استفاده کنین یا اگه به فایل کتاب می‌خوایین دسترسی داشته باشین، از بخش ریلیزهای گیت‌هاب به فرمت‌های مختلف آخرین نسخه کتاب رو می‌تونین دریافت کنین.

<div class="a4 half"></div>

<br />
<br />
<br />

### فهرست

<div class="fehrest">

| ردیف | سوال                                                                                                                                                                                     | صفحه |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| 1    | [روش‌های ایجاد objectها توی جاواسکریپت کدوما هستن؟](#روشهای-ایجاد-objectها-توی-جاواسکریپت-کدوما-هستن)                                                                                    | 29   |
| 2    | [زنجیره prototype چیه؟](#زنجیره-prototype-چیه)                                                                                                                                           | 31   |
| 3    | [تفاوت‌های بین call، apply و bind کدوما هستن؟](#تفاوتهای-بین-Call،-Apply-و-Bind-چیا-هستن)                                                                                                | 31   |
| 4    | [فرمت JSON چیه و عملیات‌های معمول روی اون چیا هستن؟](#فرمت-JSON-چیه-و-عملیاتهای-معمول-روی-اون-چیا-هستن)                                                                                  | 33   |
| 5    | [هدف از متد slice روی آرایه‌ها چیه؟](#هدف-از-متد-slice-روی-آرایهها-چیه)                                                                                                                  | 33   |
| 6    | [هدف از متد splice روی آرایه‌ها چیه؟](#هدف-از-متد-splice-روی-آرایهها-چیه)                                                                                                                | 34   |
| 7    | [تفاوت متدهای slice و splice چیا هستن؟](#تفاوت-متدهای-slice-و-splice-چیا-هستن)                                                                                                           | 34   |
| 8    | [تفاوت‌های Object و Map چیا هستن؟](#تفاوتهای-Object-و-Map-چیا-هستن)                                                                                                                      | 35   |
| 9    | [تفاوت‌های بین عملگرهای == و === چیا هستن؟](#تفاوتهای-بین-عملگرهای-و-چیا-هستن)                                                                                                           | 35   |
| 10   | [توابع lambda یا arrow-function چی هستن؟](#توابع-lambda-یا-arrow-function-چی-هستن)                                                                                                       | 36   |
| 11   | [یه تابع first-class چجور تابعی‌ـه؟](#یه-تابع-first-class-چجور-تابعیـه)                                                                                                                  | 36   |
| 12   | [یه تابع first-order چجور تابعی‌ـه؟](#یه-تابع-first-order-چجور-تابعیـه)                                                                                                                  | 37   |
| 13   | [یه تابع higher-order چجور تابعی‌ـه؟](#یه-تابع-higher-order-چجور-تابعیـه)                                                                                                                | 37   |
| 14   | [یه تابع unary چجور تابعی‌ـه؟](#یه-تابع-unary-چجور-تابعیـه)                                                                                                                              | 38   |
| 15   | [currying توابع یعنی چی؟](#currying-توابع-یعنی-چی)                                                                                                                                       | 38   |
| 16   | [چه توابعی pure هستن؟](#چه-توابعی-pure-هستن)                                                                                                                                             | 38   |
| 17   | [هدف از کلمه کلیدی let چیه؟](#هدف-از-کلمه-کلیدی-let-چیه)                                                                                                                                 | 39   |
| 18   | [تفاوت‌های کلمات کلیدی let و var چیا هستن؟](#تفاوتهای-کلمات-کلیدی-let-و-var-چیا-هستن)                                                                                                    | 40   |
| 19   | [دلیل انتخاب کلمه کلیدی let چیه؟](#دلیل-انتخاب-کلمه-کلیدی-let-چیه)                                                                                                                       | 41   |
| 20   | [چطوری می‌تونیم توی بلوک مربوط به switch بدون دریافت خطا متغیر تعریف کنیم؟](#چطوری-می‌تونیم-توی-بلوک-مربوط-به-switch-بدون-دریافت-خطا-متغیر-تعریف-کنیم)                                   | 41   |
| 21   | [Temporal-Dead-Zone چیه؟](#Temporal-Dead-Zone-چیه)                                                                                                                                       | 42   |
| 22   | [IIFE(توابع بلافاصله صدا زده شده) چی هستن؟](#IIFEتوابع-بلافاصله-صدا-زده-شده-چی-هستن)                                                                                                     | 42   |
| 23   | [مزایای استفاده از moduleها چیه؟](#مزایای-استفاده-از-moduleها-چیه)                                                                                                                       | 43   |
| 24   | [Memoization چیه؟](#Memoization-چیه)                                                                                                                                                     | 43   |
| 25   | [Hoisting چیه؟](#Hoisting-چیه)                                                                                                                                                           | 44   |
| 26   | [Classها توی ES6 چیکار می‌کنن؟](#Classها-توی-ES6-چیکار-میکنن)                                                                                                                            | 45   |
| 27   | [Closureها چیا هستن؟](#Closureها-چیا-هستن)                                                                                                                                               | 45   |
| 28   | [Moduleها چیا هستن؟](#Moduleها-چیا-هستن)                                                                                                                                                 | 46   |
| 29   | [چرا به moduleها نیاز داریم؟](#چرا-به-moduleها-نیاز-داریم)                                                                                                                               | 46   |
| 30   | [توی جاواسکریپت scope چیه و چیکار میکنه؟](#توی-جاواسکریپت-scope-چیه-و-چیکار-میکنه)                                                                                                       | 47   |
| 31   | [service-worker چیه؟](#service-worker-چیه)                                                                                                                                               | 47   |
| 32   | [توی service-worker چطوری می‌شه DOM رو دستکاری کرد؟](#توی-service-worker-چطوری-می‌شه-DOM-رو-دستکاری-کرد)                                                                                 | 47   |
| 33   | [چطوری می‌تونیم بین ریست شدن‌های service-worker داده‌های مورد نظرمون رو مجدد استفاده کنیم؟](#چطوری-می‌تونیم-بین-ریست-شدنهای-service-worker-دادههای-مورد-نظرمون-رو-مجدد-استفاده-کنیم)     | 47   |
| 34   | [IndexedDB چیه؟](#IndexedDB-چیه)                                                                                                                                                         | 48   |
| 35   | [Web-storage چیه؟](#Web-storage-چیه)                                                                                                                                                     | 48   |
| 36   | [Post-message چیه؟](#Post-message-چیه)                                                                                                                                                   | 48   |
| 37   | [Cookie چیه؟](#Cookie-چیه)                                                                                                                                                               | 48   |
| 38   | [چرا به cookie نیاز داریم؟](#چرا-به-cookie-نیاز-داریم)                                                                                                                                   | 49   |
| 39   | [گزینه‌های قابل تنظیم توی cookie چیا هستن؟](#گزینههای-قابل-تنظیم-توی-cookie-چیا-هستن)                                                                                                    | 49   |
| 40   | [چطوری می‌شه یه cookie رو حذف کرد؟](#چطوری-می‌شه-یه-cookie-رو-حذف-کرد)                                                                                                                   | 50   |
| 41   | [تفاوت‌های بین cookie و local-storage و session-storage چیا هستن؟](#تفاوتهای-بین-cookie-و-local-storage-و-session-storage-چیا-هستن)                                                      | 50   |
| 42   | [تفاوت‌های بین localStorage و sessionStorage چیا هستن؟](#تفاوتهای-بین-localStorage-و-sessionStorage-چیا-هستن)                                                                            | 50   |
| 43   | [چطوری به web-storage دسترسی پیدا می‌کنی؟](#چطوری-به-web-storage-دسترسی-پیدا-می‌کنی)                                                                                                     | 51   |
| 44   | [چه متد‌هایی روی session-storage قابل استفاده هستن؟](#چه-متدهایی-روی-session-storage-قابل-استفاده-هستن)                                                                                  | 51   |
| 45   | [رخداد storage چیه و چطوری ازش استفاده می‌کنیم؟](#رخداد-storage-چیه-و-چطوری-ازش-استفاده-می‌کنیم)                                                                                         | 52   |
| 46   | [چرا به web-storage نیاز داریم؟](#چرا-به-web-storage-نیاز-داریم)                                                                                                                         | 52   |
| 47   | [چطوری می‌تونیم پشتیبانی از web-storage توسط مرورگر رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-از-web-storage-توسط-مرورگر-رو-بررسی-کنیم)                                                   | 52   |
| 48   | [چطوری می‌تونیم پشتیبانی از web-worker توسط مرورگر رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-از-web-worker-توسط-مرورگر-رو-بررسی-کنیم)                                                     | 53   |
| 49   | [یه مثال از web-workerها می‌تونی بزنی؟](#یه-مثال-از-web-workerها-میتونی-بزنی)                                                                                                            | 53   |
| 50   | [محدودیت‌های web-workerها روی DOM چیا هستن؟](#محدودیتهای-web-workerها-روی-DOM-چیا-هستن)                                                                                                  | 54   |
| 51   | [Promise چیه؟](#Promise-چیه)                                                                                                                                                             | 55   |
| 52   | [چرا به Promise نیاز داریم؟](#چرا-به-promise-نیاز-داریم)                                                                                                                                 | 56   |
| 53   | [سه تا وضعیت ممکن برای یه Promise چیا هستن؟](#سه-تا-وضعیت-ممکن-برای-یه-promise-چیا-هستن)                                                                                                 | 56   |
| 54   | [توابع callback چی هستن؟](#توابع-callback-چی-هستن)                                                                                                                                       | 57   |
| 55   | [چرا به توابع callback نیاز داریم؟](#چرا-به-توابع-callback-نیاز-داریم)                                                                                                                   | 57   |
| 56   | [Callback-hell یا جهنم توابع callback چیه؟](#Callback-hell-یا-جهنم-توابع-callback-چیه)                                                                                                   | 58   |
| 57   | [Server-sent-events یا همون SSE چیه؟](#Server-sent-events-یا-همون-SSE-چیه)                                                                                                               | 59   |
| 58   | [چطوری می‌تونیم پیام‌های server-sent-event رو دریافت کنیم؟](#چطوری-می‌تونیم-پیامهای-server-sent-event-رو-دریافت-کنیم)                                                                    | 59   |
| 59   | [چطوری می‌تونیم پشتیبانی مرورگر برای SSE رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-مرورگر-برای-SSE-رو-بررسی-کنیم)                                                                         | 59   |
| 60   | [کدوم توابع روی SSE وجود دارن؟](#کدوم-توابع-روی-SSE-وجود-دارن)                                                                                                                           | 60   |
| 61   | [اصلی‌ترین قوانین Promiseها چیا هستن؟](#اصلیترین-قوانین-promiseها-چیا-هستن)                                                                                                              | 61   |
| 62   | [Callback توی callback چطوری رخ میده؟](#Callback-توی-callback-چطوری-رخ-میده)                                                                                                             | 60   |
| 63   | [زنجیره Promiseها چیه؟](#زنجیره-promiseها-چیه)                                                                                                                                           | 61   |
| 64   | [کاربرد متد promise.all چیه؟](#کاربرد-متد-promise.all-چیه)                                                                                                                               | 62   |
| 65   | [هدف از متد race روی Promise چیه؟](#هدف-از-متد-race-روی-promise-چیه)                                                                                                                     | 63   |
| 66   | [حالت strict توی جاواسکریپت چی کار میکنه؟](#حالت-strict-توی-جاواسکریپت-چی-کار-میکنه)                                                                                                     | 63   |
| 67   | [چرا به حالت strict نیاز داریم؟](#چرا-به-حالت-strict-نیاز-داریم)                                                                                                                         | 63   |
| 68   | [چطوری می‌تونیم حالت strict رو فعال کنیم؟](#چطوری-می‌تونیم-حالت-strict-رو-فعال-کنیم)                                                                                                     | 64   |
| 69   | [هدف از عملگر نقیض دوتایی(!!) چیه؟](#هدف-از-عملگر-نقیض-دوتایی!!-چیه)                                                                                                                     | 64   |
| 70   | [هدف از عملگر delete چیه؟](#هدف-از-عملگر-delete-چیه)                                                                                                                                     | 65   |
| 71   | [عملگر typeof چیکار میکنه؟](#عملگر-typeof-چیکار-میکنه)                                                                                                                                   | 65   |
| 72   | [undefined چیه و چه زمانی undefined می‌گیریم؟](#undefined-چیه-و-چه-زمانی-undefined-می‌گیریم)                                                                                             | 65   |
| 73   | [null چیه؟](#null-چیه)                                                                                                                                                                   | 65   |
| 74   | [تفاوت‌های بین null و undefined چیا هستن؟](#تفاوتهای-بین-null-و-undefined-چیا-هستن)                                                                                                      | 66   |
| 75   | [متد eval چیه؟](#متد-eval-چیه)                                                                                                                                                           | 66   |
| 76   | [تفاوت‌های بین window و document چیا هستن؟](#تفاوتهای-بین-window-و-document-چیا-هستن)                                                                                                    | 67   |
| 77   | [توی جاواسکریپت چطوری می‌تونیم به history دسترسی داشته باشیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-به-history-دسترسی-داشته-باشیم)                                                             | 67   |
| 78   | [انواع داده‌های جاواسکریپت کدوما هستن؟](#انواع-دادههای-جاواسکریپت-کدوما-هستن)                                                                                                            | 68   |
| 79   | [isNaN چیه و چیکار میکنه؟](#isNaN-چیه-و-چیکار-میکنه)                                                                                                                                     | 68   |
| 80   | [تفاوت‌های بین undeclared و undefined چیا هستن؟](#تفاوتهای-بین-undeclared-و-undefined-چیا-هستن)                                                                                          | 68   |
| 81   | [کدوم متغیرها عمومی هستن؟](#کدوم-متغیرها-عمومی-هستن)                                                                                                                                     | 69   |
| 82   | [مشکلات متغیرهای عمومی چیا هستن؟](#مشکلات-متغیرهای-عمومی-چیا-هستن)                                                                                                                       | 69   |
| 83   | [مقدار NaN چیه؟](#مقدار-NaN-چیه)                                                                                                                                                         | 69   |
| 84   | [هدف از تابع isFinite چیه؟](#هدف-از-تابع-isFinite-چیه)                                                                                                                                   | 69   |
| 85   | [یه event-flow چیه؟](#یه-event-flow-چیه)                                                                                                                                                 | 70   |
| 86   | [Event-bubbling چیه؟](#Event-bubbling-چیه)                                                                                                                                               | 70   |
| 87   | [Event-capturing چیه؟](#Event-capturing-چیه)                                                                                                                                             | 70   |
| 88   | [چطوری می‌شه یه فرم رو با استفاده از جاواسکریپت ثبت کرد؟](#چطوری-می‌شه-یه-فرم-رو-با-استفاده-از-جاواسکریپت-ثبت-کرد)                                                                       | 70   |
| 89   | [چطوری می‌شه به اطلاعات مربوط به سیستم عامل کاربر دسترسی داشت؟](#چطوری-می‌شه-به-اطلاعات-مربوط-به-سیستم-عامل-کاربر-دسترسی-داشت)                                                           | 71   |
| 90   | [تفاوت‌های بین رخدادهای document-load و DOMContentLoaded چیا هستن؟](#تفاوتهای-بین-رخدادهای-document-load-و-DOMContentLoaded-چیا-هستن)                                                    | 71   |
| 91   | [تفاوت‌های بین objectهای native ، host و user چیا هستن؟](#تفاوتهای-بین-objectهای-native-،-host-و-user-چیا-هستن)                                                                          | 71   |
| 92   | [کدوم ابزار و تکنیک‌ها برای دیباگ کردن برنامه جاواسکریپتی استفاده میشن؟](#کدوم-ابزار-و-تکنیکها-برای-دیباگ-کردن-برنامه-جاواسکریپتی-استفاده-میشن)                                          | 72   |
| 93   | [مزایا و معایب استفاده از Promiseها به جای callback چیا هستن؟](#مزایا-و-معایب-استفاده-از-promiseها-به-جای-callback-چیا-هستن)                                                             | 72   |
| 94   | [تفاوت‌های بین attribute و property روی DOM چیا هستن؟](#تفاوتهای-بین-attribute-و-property-روی-DOM-چیا-هستن)                                                                              | 72   |
| 95   | [سیاست same-origin چیه؟](#سیاست-same-origin-چیه)                                                                                                                                         | 73   |
| 96   | [هدف استفاده از void 0 چیه؟](#هدف-استفاده-از-void-0-چیه)                                                                                                                                 | 73   |
| 97   | [جاواسکریپت یه زبان تفسیری هست یا کامپایلری؟](#جاواسکریپت-یه-زبان-تفسیری-هست-یا-کامپایلری)                                                                                               | 74   |
| 98   | [آیا جاواسکریپت یه زبان حساس به بزرگی و کوچکی(case-sensitive) حروف است؟](#آیا-جاواسکریپت-یه-زبان-حساس-به-بزرگی-و-کوچکیcase-sensitive-حروف-است)                                           | 74   |
| 99   | [ارتباطی بین Java و JavaScript وجود داره؟](#ارتباطی-بین-Java-و-JavaScript-وجود-داره)                                                                                                     | 74   |
| 100  | [Eventها چی هستن؟](#Eventها-چی-هستن)                                                                                                                                                     | 74   |
| 101  | [کی جاواسکریپت رو ساخته؟](#کی-جاواسکریپت-رو-ساخته)                                                                                                                                       | 75   |
| 102  | [هدف از متد preventDefault چیه؟](#هدف-از-متد-preventDefault-چیه)                                                                                                                         | 75   |
| 103  | [کاربرد متد stopPropagation چیه؟](#کاربرد-متد-stopPropagation-چیه)                                                                                                                       | 76   |
| 104  | [مراحلی که موقع استفاده از return false توی یه event-handler رخ میده چیا هستن؟](#مراحلی-که-موقع-استفاده-از-return-false-توی-یه-event-handler-رخ-میده-چیا-هستن)                           | 76   |
| 105  | [BOM چیه؟](#BOM-چیه)                                                                                                                                                                     | 76   |
| 106  | [موارد استفاده از setTimeout کدوما هستن؟](#موارد-استفاده-از-setTimeout-کدوما-هستن)                                                                                                       | 77   |
| 107  | [موارد استفاده از setInterval کدوما هستن؟](#موارد-استفاده-از-setInterval-کدوما-هستن)                                                                                                     | 77   |
| 108  | [چرا جاواسکریپت رو به عنوان یه زبان تک thread می‌شناسن؟](#چرا-جاواسکریپت-رو-به-عنوان-یه-زبان-تک-thread-میشناسن)                                                                          | 78   |
| 109  | [Event-delegation چیه؟](#Event-delegation-چیه)                                                                                                                                           | 78   |
| 110  | [ECMAScript چیه؟](#ECMAScript-چیه)                                                                                                                                                       | 78   |
| 111  | [JSON چیه؟](#JSON-چیه)                                                                                                                                                                   | 79   |
| 112  | [قوانین فرمت JSON کدوما هستن؟](#قوانین-فرمت-JSON-کدوما-هستن)                                                                                                                             | 79   |
| 113  | [هدف از متد JSON.stringify چیه؟](#هدف-از-متد-JSON.stringify-چیه)                                                                                                                         | 79   |
| 114  | [چطوری می‌تونیم یه رشته JSON رو تجزیه کنیم؟](#چطوری-می‌تونیم-یه-JSON-رو-تجزیه-کنیم)                                                                                                      | 79   |
| 115  | [چرا به JSON نیاز داریم؟](#چرا-به-JSON-نیاز-داریم)                                                                                                                                       | 80   |
| 116  | [PWAها چی هستن؟](#PWAها-چی-هستن)                                                                                                                                                         | 80   |
| 117  | [هدف از متد clearTimeout چیه؟](#هدف-از-متد-clearTimeout-چیه)                                                                                                                             | 80   |
| 118  | [هدف از متد clearInterval چیه؟](#هدف-از-متد-clearInterval-چیه)                                                                                                                           | 81   |
| 119  | [توی جاواسکریپت، چطوری می‌شه به یه صفحه جدید redirect انجام داد؟](#توی-جاواسکریپت،-چطوری-می‌شه-به-یه-صفحه-جدید-redirect-انجام-داد)                                                       | 81   |
| 120  | [چطوری بررسی می‌کنیم که یه string شامل یه substring هست یا نه؟](#چطوری-بررسی-می‌کنیم-که-یه-string-شامل-یه-substring-هست-یا-نه)                                                           | 82   |
| 121  | [توی جاواسکریپت، چطوری مقدار یه آدرس email رو اعتبارسنجی می‌کنیم؟](#توی-جاواسکریپت،-چطوری-مقدار-یه-آدرس-email-رو-اعتبارسنجی-می‌کنیم)                                                     | 82   |
| 122  | [چطوری می‌تونیم مقدار آدرس url جاری رو بخونیم؟](#چطوری-می‌تونیم-مقدار-آدرس-url-جاری-رو-بخونیم)                                                                                           | 83   |
| 123  | [ویژگی‌های مختلف url روی object مربوط به history کدوما هستن؟](#ویژگیهای-مختلف-url-روی-object-مربوط-به-history-کدوما-هستن)                                                                | 83   |
| 124  | [توی جاواسکریپت چطوری می‌تونیم مقدار یه query-string رو بخونیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-مقدار-یه-query-string-رو-بخونیم)                                                         | 84   |
| 125  | [چطوری می‌تونیم بررسی کنیم که آیا یه پراپرتی روی آبجکت وجود داره یا نه؟](#چطوری-می‌تونیم-بررسی-کنیم-که-آیا-یه-پراپرتی-روی-آبجکت-وجود-داره-یا-نه)                                         | 84   |
| 126  | [چطوری روی یه object حلقه میزنی؟](#چطوری-روی-یه-object-حلقه-میزنی)                                                                                                                       | 85   |
| 127  | [چطوری تست می‌کنی که یه object خالیه؟](#چطوری-تست-می‌کنی-که-یه-object-خالیه)                                                                                                             | 85   |
| 128  | [arguments object چیه؟](#arguments-object-چیه)                                                                                                                                           | 86   |
| 129  | [چطوری حرف اول یه رشته رو به حرف بزرگ تبدیل می‌کنی؟](#چطوری-حرف-اول-یه-رشته-رو-به-حرف-بزرگ-تبدیل-می‌کنی)                                                                                 | 86   |
| 130  | [مزایا و معایب حلقه for چیا هستن؟](#مزایا-و-معایب-حلقه-for-چیا-هستن)                                                                                                                     | 87   |
| 131  | [چطوری تاریخ جاری رو توی جاواسکریپت نشون میدی؟](#چطوری-تاریخ-جاری-رو-توی-جاواسکریپت-نشون-میدی)                                                                                           | 87   |
| 132  | [چطوری دو تا date object رو با هم مقایسه می‌کنی؟](#چطوری-دو-تا-date-object-رو-با-هم-مقایسه-می‌کنی)                                                                                       | 87   |
| 133  | [چطوری بررسی می‌کنی که یه رشته با یه رشته دیگه شروع می‌شه؟](#چطوری-بررسی-می‌کنی-که-یه-رشته-با-یه-رشته-دیگه-شروع-می‌شه)                                                                   | 88   |
| 134  | [چطوری یه رشته رو trim می‌کنی؟](#چطوری-یه-رشته-رو-trim-می‌کنی)                                                                                                                           | 88   |
| 135  | [توی جاواسکریپت چطوری می‌تونیم یه زوج مرتب از key یه valueها بسازیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-یه-زوج-مرتب-از-key-یه-valueها-بسازیم)                                               | 88   |
| 136  | [آیا عبارت '!--' عملگر خاصی هست؟](#آیا-عبارت-!---عملگر-خاصی-هست)                                                                                                                         | 89   |
| 137  | [چطوری می‌تونیم به متغیرهامون مقادیر اولیه بدیم؟](#چطوری-می‌تونیم-به-متغیرهامون-مقادیر-اولیه-بدیم)                                                                                       | 89   |
| 138  | [چطوری می‌تونیم متن‌های چند خطی درست کنیم؟](#چطوری-می‌تونیم-متنهای-چند-خطی-درست-کنیم)                                                                                                    | 89   |
| 139  | [مدل app-shell چیه؟](#مدل-app-shell-چیه)                                                                                                                                                 | 90   |
| 140  | [چطوری می‌تونیم روی یه تابع property اضافه کنیم؟](#چطوری-می‌تونیم-روی-یه-تابع-property-اضافه-کنیم)                                                                                       | 90   |
| 141  | [چطوری می‌تونیم تعداد پارامترهای ورودی یه تابع رو به دست بیاریم؟](#چطوری-می‌تونیم-تعداد-پارامترهای-ورودی-یه-تابع-رو-به-دست-بیاریم)                                                       | 91   |
| 142  | [Polyfill چیه؟](#Polyfill-چیه)                                                                                                                                                           | 91   |
| 143  | [عبارات Break و continue چی هستن؟](#عبارات-Break-و-continue-چی-هستن)                                                                                                                     | 92   |
| 144  | [توی جاواسکریپت labelها چیکار می‌کنن؟](#توی-جاواسکریپت-labelها-چیکار-میکنن)                                                                                                              | 92   |
| 145  | [مزایای declare کردن متغیرها در اوایل کد چیه؟](#مزایای-declare-کردن-متغیرها-در-اوایل-کد-چیه)                                                                                             | 92   |
| 146  | [مزایای مقداردهی اولیه متغیرها چیه؟](#مزایای-مقداردهی-اولیه-متغیرها-چیه)                                                                                                                 | 93   |
| 147  | [روش توصیه شده برای ایجاد object چیه؟](#روش-توصیه-شده-برای-ایجاد-object-چیه)                                                                                                             | 93   |
| 148  | [چطوری می‌تونیم آرایه‌ JSON تعریف کنیم؟](#چطوری-می‌تونیم-آرایه-JSON-تعریف-کنیم)                                                                                                          | 93   |
| 149  | [چطوری می‌تونیم اعداد تصادفی تولید کنیم؟](#چطوری-می‌تونیم-اعداد-تصادفی-تولید-کنیم)                                                                                                       | 94   |
| 150  | [می‌تونی یه تابع تولید اعداد تصادفی توی یه بازه مشخص بنویسی؟](#میتونی-یه-تابع-تولید-اعداد-تصادفی-توی-یه-بازه-مشخص-بنویسی)                                                                | 94   |
| 151  | [Tree-shaking چیه؟](#Tree-shaking-چیه)                                                                                                                                                   | 95   |
| 152  | [دلایل نیاز به tree-shaking کدوما هستن؟](#دلایل-نیاز-به-tree-shaking-کدوما-هستن)                                                                                                         | 95   |
| 153  | [آیا استفاده از eval توصیه می‌شه؟](#آیا-استفاده-از-eval-توصیه-می‌شه)                                                                                                                     | 95   |
| 154  | [Regular-Expression چیه؟](#Regular-Expression-چیه)                                                                                                                                       | 95   |
| 155  | [متدهای رشته که روی Regular-expression مجاز هستن کدوماست؟](#متدهای-رشته-که-روی-Regular-expression-مجاز-هستن-کدوماست)                                                                     | 96   |
| 156  | [توی Regex بخش modifiersها چیکار میکنه؟](#توی-Regex-بخش-modifiersها-چیکار-میکنه)                                                                                                         | 96   |
| 157  | [پترن‌های regular-expression چیه؟](#پترنهای-regular-expression-چیه)                                                                                                                      | 97   |
| 158  | [آبجکت RegExp چیه؟](#آبجکت-RegExp-چیه)                                                                                                                                                   | 97   |
| 159  | [چطوری روی یه رشته دنبال یه پترن RegExp می‌گردی؟](#چطوری-روی-یه-رشته-دنبال-یه-پترن-RegExp-میگردی)                                                                                        | 98   |
| 160  | [هدف از متد exec چیه؟](#هدف-از-متد-exec-چیه)                                                                                                                                             | 98   |
| 161  | [چطوری استایل‌های یه المنت HTML رو تغییر میدی؟](#چطوری-استایلهای-یه-المنت-HTML-رو-تغییر-میدی)                                                                                            | 98   |
| 162  | [نتیجه عبارت 1+2+'3' چی می‌شه؟](#نتیجه-عبارت-1+2+3-چی-می‌شه)                                                                                                                             | 99   |
| 163  | [عبارت debugger چیکار میکنه؟](#عبارت-debugger-چیکار-میکنه)                                                                                                                               | 99   |
| 164  | [هدف از breakpointها توی debugging چیه؟](#هدف-از-breakpointها-توی-debugging-چیه)                                                                                                         | 99   |
| 165  | [آیا می‌تونیم از عبارت‌های رزرو شده در تعریف identifierها(اسم متغیر، کلاس و ...) استفاده کنیم؟](#آیا-می‌تونیم-از-عبارتهای-رزرو-شده-در-تعریف-identifierهااسم-متغیر،-کلاس-و--استفاده-کنیم) | 99   |
| 166  | [چطوری تشخیص بدیم که یه مرورگر mobile هست یا نه؟](#چطوری-تشخیص-بدیم-که-یه-مرورگر-mobile-هست-یا-نه)                                                                                       | 100  |
| 167  | [چطوری بدون Regex تشخیص بدیم که یه مرورگر mobile هست یا نه؟](#چطوری-بدون-Regex-تشخیص-بدیم-که-یه-مرورگر-mobile-هست-یا-نه)                                                                 | 102  |
| 168  | [چطوری طول و عرض یه تصویر رو با جاواسکریپت به دست میاری؟](#چطوری-طول-و-عرض-یه-تصویر-رو-با-جاواسکریپت-به-دست-میاری)                                                                       | 102  |
| 169  | [چطوری درخواست‌های synchronous HTTP بزنیم؟](#چطوری-درخواستهای-synchronous-HTTP-بزنیم)                                                                                                    | 103  |
| 170  | [چطوری درخواست‌های asynchronous HTTP بزنیم؟](#چطوری-درخواستهای-asynchronous-HTTP-بزنیم)                                                                                                  | 103  |
| 171  | [چطوری یه تاریخ رو به یه تاریخ در timezone دیگه تبدیل کنیم؟](#چطوری-یه-تاریخ-رو-به-یه-تاریخ-در-timezone-دیگه-تبدیل-کنیم)                                                                 | 103  |
| 172  | [چه propertyهایی برای اندازه‌گیزی سایز window به کار میره؟](#چه-propertyهایی-برای-اندازهگیزی-سایز-window-به-کار-میره)                                                                    | 104  |
| 173  | [عملگر شرطی سه گانه توی جاواسکریپت چیه؟](#عملگر-شرطی-سه-گانه-توی-جاواسکریپت-چیه)                                                                                                         | 104  |
| 174  | [آیا می‌شه روی عملگر شرطی زنجیره شرط‌ها رو اعمال کرد؟](#آیا-می‌شه-روی-عملگر-شرطی-زنجیره-شرطها-رو-اعمال-کرد)                                                                              | 104  |
| 175  | [روش‌های اجرای جاواسکریپت بعد از لود شدن صفحه کدوما هستن؟](#روشهای-اجرای-جاواسکریپت-بعد-از-لود-شدن-صفحه-کدوما-هستن)                                                                      | 105  |
| 176  | [تفاوت‌های بین proto و prototype کدوما هستن؟](#تفاوتهای-بین-proto-و-prototype-کدوما-هستن)                                                                                                | 105  |
| 177  | [میتونی یه مثال از زمانی که واقعا به سمیکولون( ; ) نیاز هست بزنی؟](#میتونی-یه-مثال-از-زمانی-که-واقعا-به-سمیکولون-نیاز-هست-بزنی)                                                          | 106  |
| 178  | [متد freeze چیکار میکنه؟](#متد-freeze-چیکار-میکنه)                                                                                                                                       | 106  |
| 179  | [هدف از متد freeze چیه؟](#هدف-از-متد-freeze-چیه)                                                                                                                                         | 107  |
| 180  | [چرا به متد freeze نیاز داریم؟](#چرا-به-متد-freeze-نیاز-داریم)                                                                                                                           | 107  |
| 181  | [چطوری می‌تونیم زبان ترجیحی یه مرورگر رو تشخیص بدیم؟](#چطوری-می‌تونیم-زبان-ترجیحی-یه-مرورگر-رو-تشخیص-بدیم)                                                                               | 107  |
| 182  | [چطوری می‌تونیم حرف اول همه کلمات یه رشته رو به حرف بزرگ تبدیل کنیم؟](#چطوری-می‌تونیم-حرف-اول-همه-کلمات-یه-رشته-رو-به-حرف-بزرگ-تبدیل-کنیم)                                               | 108  |
| 183  | [چطوری می‌شه تشخیص داد که جاواسکریپت یه صفحه وب غیرفعال شده؟](#چطوری-می‌شه-تشخیص-داد-که-جاواسکریپت-یه-صفحه-وب-غیرفعال-شده)                                                               | 108  |
| 184  | [عملگرهای پشتیبانی شده توسط جاواسکریپت کدوما هستن؟](#عملگرهای-پشتیبانی-شده-توسط-جاواسکریپت-کدوما-هستن)                                                                                   | 109  |
| 185  | [پارامتر rest چیکار میکنه؟](#پارامتر-rest-چیکار-میکنه)                                                                                                                                   | 109  |
| 186  | [اگه پارامتر rest رو به عنوان آخرین پارامتر استفاده نکنیم چی می‌شه؟](#اگه-پارامتر-rest-رو-به-عنوان-آخرین-پارامتر-استفاده-نکنیم-چی-می‌شه)                                                 | 110  |
| 187  | [عملگرهای منطقی باینری توی جاواسکریپت کدوما هستن؟](#عملگرهای-منطقی-باینری-توی-جاواسکریپت-کدوما-هستن)                                                                                     | 110  |
| 188  | [عملگر spread چیکار میکنه؟](#عملگر-spread-چیکار-میکنه)                                                                                                                                   | 111  |
| 189  | [چطوری تشخیص میدی که یه آبجکت freeze شده یا نه؟](#چطوری-تشخیص-میدی-که-یه-آبجکت-freeze-شده-یا-نه)                                                                                         | 111  |
| 190  | [چطوری بررسی کنیم که دو تا مقدار(شامل آبجکت) با هم برابرن یا نه؟](#چطوری-بررسی-کنیم-که-دو-تا-مقدارشامل-آبجکت-با-هم-برابرن-یا-نه)                                                         | 111  |
| 191  | [هدف از متد is روی object چیه؟](#هدف-از-متد-is-روی-object-چیه)                                                                                                                           | 112  |
| 192  | [چطوری propertyهای یه object رو به یه object دیگه کپی می‌کنی؟](#چطوری-propertyهای-یه-object-رو-به-یه-object-دیگه-کپی-می‌کنی)                                                             | 112  |
| 193  | [کاربردهای متد assign چیه؟](#کاربردهای-متد-assign-چیه)                                                                                                                                   | 113  |
| 194  | [آبجکت proxy چیه؟](#آبجکت-proxy-چیه)                                                                                                                                                     | 113  |
| 195  | [هدف از متد seal چیه؟](#هدف-از-متد-seal-چیه)                                                                                                                                             | 114  |
| 196  | [کاربردهای متد seal چیه؟](#کاربردهای-متد-seal-چیه)                                                                                                                                       | 114  |
| 197  | [تفاوت‌های بین متدهای freeze و seal چیا هست؟](#تفاوتهای-بین-متدهای-freeze-و-seal-چیا-هست)                                                                                                | 115  |
| 198  | [چطوری تشخیص میدی که یه آبجکت seal شده یا نه؟](#چطوری-تشخیص-میدی-که-یه-آبجکت-seal-شده-یا-نه)                                                                                             | 115  |
| 199  | [چطوری کلید و مقدارهای enumerable رو به دست میاری؟](#چطوری-کلید-و-مقدارهای-enumerable-رو-به-دست-میاری)                                                                                   | 115  |
| 200  | [تفاوت‌های بین متدهای Object.values و Object.entries چیا هست؟](#تفاوتهای-بین-متدهای-Objectvalues-و-Objectentries-چیا-هست)                                                                | 116  |
| 201  | [چطوری لیست کلیدهای یه object رو بدست میاری؟](#چطوری-لیست-کلیدهای-یه-object-رو-بدست-میاری)                                                                                               | 116  |
| 202  | [چطوری یه object با prototype درست می‌کنی؟](#چطوری-یه-object-با-prototype-درست-می‌کنی)                                                                                                   | 117  |
| 203  | [WeakSet چیه؟](#WeakSet-چیه)                                                                                                                                                             | 117  |
| 204  | [تفاوت‌های بین WeakSet و Set کدوما هستن؟](#تفاوتهای-بین-WeakSet-و-Set-کدوما-هستن)                                                                                                        | 118  |
| 205  | [لیست متدهایی که رو WeakSet قابل استفاده هستن رو می‌تونی بگی؟](#لیست-متدهایی-که-رو-WeakSet-قابل-استفاده-هستن-رو-میتونی-بگی)                                                              | 118  |
| 206  | [WeakMap چیه؟](#WeakMap-چیه)                                                                                                                                                             | 119  |
| 207  | [تفاوت‌های بین WeakMap و Map کدوما هستن؟](#تفاوتهای-بین-WeakMap-و-Map-کدوما-هستن)                                                                                                        | 119  |
| 208  | [لیست متدهایی که رو WeakMap قابل استفاده هستن رو می‌تونی بگی؟](#لیست-متدهایی-که-رو-WeakMap-قابل-استفاده-هستن-رو-میتونی-بگی)                                                              | 120  |
| 209  | [هدف از متد uneval چیه؟](#هدف-از-متد-uneval-چیه)                                                                                                                                         | 120  |
| 210  | [چطوری یه URL رو encode می‌کنی؟](#چطوری-یه-URL-رو-encode-می‌کنی)                                                                                                                         | 121  |
| 211  | [چطوری یه URL رو decode می‌کنی؟](#چطوری-یه-URL-رو-decode-می‌کنی)                                                                                                                         | 121  |
| 212  | [چطوری محتوای یه صفحه رو پرینت می‌گیری؟](#چطوری-محتوای-یه-صفحه-رو-پرینت-می‌گیری)                                                                                                         | 121  |
| 213  | [تفاوت‌های بین uneval و eval چیا هستن؟](#تفاوتهای-بین-uneval-و-eval-چیا-هستن)                                                                                                            | 122  |
| 214  | [تابع anonymous چیه؟](#تابع-anonymous-چیه)                                                                                                                                               | 122  |
| 215  | [تفاوت تقدم بین متغیرهای local و global چطوریه؟](#تفاوت-تقدم-بین-متغیرهای-local-و-global-چطوریه)                                                                                         | 123  |
| 216  | [accessorهای جاواسکریپت چیکار می‌کنن؟](#accessorهای-جاواسکریپت-چیکار-میکنن)                                                                                                              | 123  |
| 217  | [چطوری روی constructor یه Object یه مقدار تعریف می‌کنی؟](#چطوری-روی-constructor-یه-Object-یه-مقدار-تعریف-می‌کنی)                                                                         | 124  |
| 218  | [تفاوت‌های بین get و defineProperty چیا هست؟](#تفاوتهای-بین-get-و-defineProperty-چیا-هست)                                                                                                | 124  |
| 219  | [مزایای استفاده از Getter و Setter چیه؟](#مزایای-استفاده-از-Getter-و-Setter-چیه)                                                                                                         | 124  |
| 220  | [می‌تونیم getter و setter رو با استفاده از متد defineProperty تعریف کنیم؟](#می‌تونیم-getter-و-setter-رو-با-استفاده-از-متد-defineProperty-تعریف-کنیم)                                     | 125  |
| 221  | [هدف استفاده از switch-case چیه؟](#هدف-استفاده-از-switch-case-چیه)                                                                                                                       | 125  |
| 222  | [چه قواعدی برای استفاده از swtich-case باید رعایت بشه؟](#چه-قواعدی-برای-استفاده-از-swtich-case-باید-رعایت-بشه)                                                                           | 126  |
| 223  | [نوع داده‌های primitive کدوما هستن؟](#نوع-دادههای-primitive-کدوما-هستن)                                                                                                                  | 126  |
| 224  | [روش‌های مختلف دسترسی به propertyهای object کدوما هستن؟](#روشهای-مختلف-دسترسی-به-propertyهای-object-کدوما-هستن)                                                                          | 127  |
| 225  | [قوانین پارامترهای توابع کدوما هستن؟](#قوانین-پارامترهای-توابع-کدوما-هستن)                                                                                                               | 127  |
| 226  | [آبجکت error چیه؟](#آبجکت-error-چیه)                                                                                                                                                     | 127  |
| 227  | [چه موقعی خطای syntax دریافت می‌کنیم؟](#چه-موقعی-خطای-syntax-دریافت-می‌کنیم)                                                                                                             | 128  |
| 228  | [عنوان خطاهای مختلف که روی error-object برمیگردن کدوما هستن؟](#عنوان-خطاهای-مختلف-که-روی-error-object-برمیگردن-کدوما-هستن)                                                               | 128  |
| 229  | [عبارات مختلف که در هنگام مدیریت error استفاده میشن کدوما هستن؟](#عبارات-مختلف-که-در-هنگام-مدیریت-error-استفاده-میشن-کدوما-هستن)                                                         | 129  |
| 230  | [دو نوع مختلف حلقه‌ها تو جاواسکریپت کدوما هستن؟](#دو-نوع-مختلف-حلفهها-در-جاواسکریپت-کدوما-هستن)                                                                                          | 129  |
| 231  | [nodejs چیه؟](#nodejs-چیه)                                                                                                                                                               | 129  |
| 232  | [آبجکت Intl چیه؟](#آبجکت-Intl-چیه)                                                                                                                                                       | 130  |
| 233  | [چطوری تاریخ و زمان رو بر اساس زبان جاری سیستم کاربر نمایش بدیم؟](#چطوری-تاریخ-و-زمان-رو-بر-اساس-زبان-جاری-سیستم-کاربر-نمایش-بدیم)                                                       | 130  |
| 234  | [Iterator چیه؟](#Iterator-چیه)                                                                                                                                                           | 130  |
| 131  |                                                                                                                                                                                          |      |
| 236  | [Event-loop چیه؟](#Event-loop-چیه)                                                                                                                                                       | 131  |
| 237  | [Call-stack چیه؟](#Call-stack-چیه)                                                                                                                                                       | 131  |
| 238  | [Event-queue چیه؟](#Event-queue-چیه)                                                                                                                                                     | 132  |
| 239  | [Decorator چیه؟](#Decorator-چیه)                                                                                                                                                         | 132  |
| 240  | [مقادیر موجود روی آبجکت Intl کدوما هستن؟](#مقادیر-موجود-روی-آبجکت-Intl-کدوما-هستن)                                                                                                       | 133  |
| 241  | [عملگر Unary چیه؟](#عملگر-Unary-چیه)                                                                                                                                                     | 134  |
| 242  | [چطوری المنت‌های موجود تو یه آرایه رو مرتب می‌کنی؟](#چطوری-المنتهای-موجود-تو-یه-آرایه-رو-مرتب-می‌کنی)                                                                                    | 134  |
| 243  | [هدف از تابع مرتب‌سازی موقع استفاده از متد sort چیه؟](#هدف-از-تابع-مرتبسازی-موقع-استفاده-از-متد-sort-چیه)                                                                                | 134  |
| 244  | [چطوری آیتم‌های یه آرایه رو معکوس مرتب کنیم؟](#چطوری-آیتمهای-یه-آرایه-رو-معکوس-مرتب-کنیم)                                                                                                | 134  |
| 245  | [چطوری حداقل و حداکثر مقدار یه آرایه رو بدست بیاریم؟](#چطوری-حداقل-و-حداکثر-مقدار-یه-آرایه-رو-بدست-بیاریم)                                                                               | 135  |
| 246  | [چطوری حداقل و حداکثر مقدار یه آرایه رو بدون استفاده از متدهای Math بدست بیاریم؟](#چطوری-حداقل-و-حداکثر-مقدار-یه-آرایه-رو-بدون-استفاده-از-متدهای-Math-بدست-بیاریم)                       | 135  |
| 247  | [عبارت خالی چیه و هدف از استفاده ازش چیه؟](#عبارت-خالی-چیه-و-هدف-از-استفاده-ازش-چیه)                                                                                                     | 136  |
| 248  | [چطوری metadata یه ماژول رو بدست میاری؟](#چطوری-metadata-یه-ماژول-رو-بدست-میاری)                                                                                                         | 136  |
| 249  | [عملگر comma چیه و چیکار میکنه؟](#عملگر-comma-چیه-و-چیکار-میکنه)                                                                                                                         | 137  |
| 250  | [مزایای استفاده از عملگر comma چیه؟](#مزایای-استفاده-از-عملگر-comma-چیه)                                                                                                                 | 137  |
| 251  | [Typescript چیه؟](#Typescript-چیه)                                                                                                                                                       | 138  |
| 252  | [تفاوت‌های بین javascript و typescript کدوما هستن؟](#تفاوتهای-بین-javascript-و-typescript-کدوما-هستن)                                                                                    | 138  |
| 253  | [مزایای typescript نسبت به javascript چیاست؟](#مزایای-typescript-نسبت-به-javascript-چیاست)                                                                                               | 139  |
| 254  | [object-initializer چیه؟](#object-initializer-چیه)                                                                                                                                       | 139  |
| 255  | [متد constructor چیه؟](#متد-constructor-چیه)                                                                                                                                             | 140  |
| 256  | [اگه متد constructor رو بیش از یه بار توی کلاس بنویسیم چی می‌شه؟](#اگه-متد-constructor-رو-بیش-از-یه-بار-توی-کلاس-بنویسیم-چی-می‌شه)                                                       | 140  |
| 257  | [چطوری متد constructor کلاس والد رو صدا بزنیم؟](#چطوری-متد-constructor-کلاس-والد-رو-صدا-بزنیم)                                                                                           | 141  |
| 258  | [چطوری prototype یه object رو به دست میاری؟](#چطوری-prototype-یه-object-رو-به-دست-میاری)                                                                                                 | 141  |
| 259  | [اگه به متد getPrototype رشته پاس بدیم چی می‌شه؟](#اگه-به-متد-getPrototype-رشته-پاس-بدیم-چی-می‌شه)                                                                                       | 141  |
| 260  | [چطوری prototype یه object روی یه object دیگه ست کنیم؟](#چطوری-prototype-یه-object-روی-یه-object-دیگه-ست-کنیم)                                                                           | 142  |
| 261  | [چطوری بررسی می‌کنی که یه object قابل extend هست یا نه؟](#چطوری-بررسی-می‌کنی-که-یه-object-قابل-extend-هست-یا-نه)                                                                         | 142  |
| 262  | [چطوری جلوی extend یه object رو بگیریم؟](#چطوری-جلوی-extend-یه-object-رو-بگیریم)                                                                                                         | 142  |
| 263  | [روش‌های مختلف برای تبدیل یه object به object غیرقابل extend چیه؟](#روشهای-مختلف-برای-تبدیل-یه-object-به-object-غیرقابل-extend-چیه)                                                      | 143  |
| 264  | [چطوری propertyهای متعددی رو روی یه object تعریف می‌کنی؟](#چطوری-propertyهای-متعددی-رو-روی-یه-object-تعریف-می‌کنی)                                                                       | 143  |
| 265  | [منظور از MEAN توی جاواسکریپت چیه؟](#منظور-از-MEAN-توی-جاواسکریپت-چیه)                                                                                                                   | 144  |
| 266  | [Obfuscation توی جاواسکریپت چیه و چیکار میکنه؟](#Obfuscation-توی-جاواسکریپت-چیه-و-چیکار-میکنه)                                                                                           | 144  |
| 267  | [چه نیازی به Obfuscate کردن داریم؟](#چه-نیازی-به-Obfuscate-کردن-داریم)                                                                                                                   | 145  |
| 268  | [Minification چیه؟](#Minification-چیه)                                                                                                                                                   | 145  |
| 269  | [مزایای minification یا کم حجم‌سازی چیه؟](#مزایای-minification-یا-کم-حجمسازی-چیه)                                                                                                        | 145  |
| 270  | [تفاوت‌های بین Obfuscation و Encryption چیه؟](#تفاوتهای-بین-Obfuscation-و-Encryption-چیه)                                                                                                | 146  |
| 271  | [ابزارهای مختلف برای minification کدوما هستن؟](#ابزارهای-مختلف-برای-minification-کدوما-هستن)                                                                                             | 146  |
| 272  | [چطوری اعتبارسنجی فرم رو با javascript انجام میدی؟](#چطوری-اعتبارسنجی-فرم-رو-با-javascript-انجام-میدی)                                                                                   | 146  |
| 273  | [چطوری اعتبارسنجی فرم رو بدون javascript انجام میدی؟](#چطوری-اعتبارسنجی-فرم-رو-بدون-javascript-انجام-میدی)                                                                               | 147  |
| 274  | [متدهای موجود روی DOM برای اعتبارسنجی کدوما هستن؟](#متدهای-موجود-روی-DOM-برای-اعتبارسنجی-کدوما-هستن)                                                                                     | 147  |
| 275  | [مقادیر موجود روی DOM برای اعتبارسنجی کدوما هستن؟](#مقادیر-موجود-روی-DOM-برای-اعتبارسنجی-کدوما-هستن)                                                                                     | 148  |
| 276  | [مقادیر موجود روی input برای اعتبارسنجی کدوما هستن؟](#مقادیر-موجود-روی-input-برای-اعتبارسنجی-کدوما-هستن)                                                                                 | 148  |
| 277  | [یه مثال از استفاده ویژگی rangeOverflow می‌تونی بزنی؟](#یه-مثال-از-استفاده-ویژگی-rangeOverflow-میتونی-بزنی)                                                                              | 149  |
| 278  | [جاواسکریپت قابلیت استفاده از enum رو پیش‌فرض توی خودش داره؟](#جاواسکریپت-قابلیت-استفاده-از-enum-رو-پیشفرض-توی-خودش-داره)                                                                | 149  |
| 279  | [enum چیه؟](#enum-چیه)                                                                                                                                                                   | 150  |
| 280  | [چطوری همه propertyهای یه object رو به دست بیاریم؟](#چطوری-همه-propertyهای-یه-object-رو-به-دست-بیاریم)                                                                                   | 150  |
| 281  | [چطوری property-descriptorهای یه آبجکت رو بدست بیاریم؟](#چطوری-property-descriptorهای-یه-آبجکت-رو-بدست-بیاریم)                                                                           | 150  |
| 282  | [گزینه‌هایی که موقع تعریف ویژگی object با descriptor داریم کدوما هستن؟](#گزینههایی-که-موقع-تعریف-ویژگی-object-با-descriptor-داریم-کدوما-هستن)                                            | 151  |
| 283  | [چطوری کلاس‌ها رو extend می‌کنی؟](#چطوری-کلاسها-رو-extend-می‌کنی)                                                                                                                        | 151  |
| 284  | [چطوری آدرس صفحه رو بدون رفرش صفحه عوض کنیم؟](#چطوری-آدرس-صفحه-رو-بدون-رفرش-صفحه-عوض-کنیم)                                                                                               | 152  |
| 285  | [چطوری بررسی می‌کنی که یه آرایه یه مقدار مشخص رو داره یا نه؟](#چطوری-بررسی-می‌کنی-که-یه-آرایه-یه-مقدار-مشخص-رو-داره-یا-نه)                                                               | 152  |
| 286  | [چطوری آرایه‌های scalar رو با هم مقایسه می‌کنی؟](#چطوری-آرایههای-scalar-رو-با-هم-مقایسه-می‌کنی)                                                                                          | 153  |
| 287  | [چطوری می‌شه پارامترهای صفحه رو از متد GET گرفت؟](#چطوری-می‌شه-پارامترهای-صفحه-رو-از-متد-GET-گرفت)                                                                                       | 153  |
| 288  | [چطوری اعداد رو می‌شه سه رقم سه رقم جدا کرد؟](#چطوری-اعداد-رو-می‌شه-سه-رقم-سه-رقم-جدا-کرد)                                                                                               | 153  |
| 289  | [تفاوت‌ بین java و javascript چیه؟](#تفاوت-بین-java-و-javascript-چیه)                                                                                                                    | 154  |
| 290  | [آیا جاواسکریپت namespace رو پشتیبانی میکنه؟](#آیا-جاواسکریپت-namespace-رو-پشتیبانی-میکنه)                                                                                               | 154  |
| 291  | [چطوری namespace تعریف می‌کنی؟](#چطوری-namespace-تعریف-می‌کنی)                                                                                                                           | 155  |
| 292  | [چطوری می‌تونیم تکه کد جاواسکریپت داخل یه iframe رو از صفحه والد صدا بزنیم؟](#چطوری-می‌تونیم-تکه-کد-جاواسکریپت-داخل-یه-iframe-رو-از-صفحه-والد-صدا-بزنیم)                                 | 156  |
| 293  | [چطوری می‌شه اختلاف timezone رو از آبجکت date بگیریم؟](#چطوری-می‌شه-اختلاف-timezone-رو-از-آبجکت-date-بگیریم)                                                                             | 157  |
| 294  | [چطوری فایل‌های CSS و JS رو به شکل داینامیک بارگذاری کنیم؟](#چطوری-فایلهای-CSS-و-JS-رو-به-شکل-داینامیک-بارگذاری-کنیم)                                                                    | 157  |
| 295  | [روش‌های مختلف برای پیدا کردن elementها توی DOM کدوما هستن؟](#روشهای-مختلف-برای-پیدا-کردن-elementها-توی-DOM-کدوما-هستن)                                                                  | 158  |
| 296  | [jQuery چیه؟](#jQuery-چیه)                                                                                                                                                               | 158  |
| 297  | [موتور V8 جاواسکریپت چیه؟](#موتور-V8-جاواسکریپت-چیه)                                                                                                                                     | 158  |
| 298  | [چرا ما جاواسکریپت رو به عنوان یه زبان داینامیک می‌شناسیم؟](#چرا-ما-جاواسکریپت-رو-به-عنوان-یه-زبان-داینامیک-میشناسیم)                                                                    | 159  |
| 299  | [عملگر void چیکار میکنه؟](#عملگر-void-چیکار-میکنه)                                                                                                                                       | 159  |
| 300  | [چطوری می‌شه نمایشگر موس صفحه رو به درحال لود تغییر داد؟](#چطوری-می‌شه-نمایشگر-موس-صفحه-رو-به-درحال-لود-تغییر-داد)                                                                       | 159  |
| 301  | [چطوری می‌شه یه حلقه بی‌نهایت درست کرد؟](#چطوری-می‌شه-یه-حلقه-بینهایت-درست-کرد)                                                                                                          | 160  |
| 302  | [چرا باید در استفاده از عبارت with تجدیدنظر کرد؟](#چرا-باید-در-استفاده-از-عبارت-with-تجدیدنظر-کرد)                                                                                       | 160  |
| 303  | [خروجی این حلقه‌ها چی می‌شه؟](#خروجی-این-حلقهها-چی-می‌شه)                                                                                                                                | 161  |
| 304  | [می‌تونی یه سری از ویژگی‌های ES6 رو اسم ببری؟](#میتونی-یه-سری-از-ویژگیهای-ES6-رو-اسم-ببری)                                                                                               | 161  |
| 305  | [ES6 چیه؟](#ES6-چیه)                                                                                                                                                                     | 162  |
| 306  | [آیا می‌تونیم متغیرهای تعریف شده با let و const رو مجددا declare کنیم؟](#آیا-می‌تونیم-متغیرهای-تعریف-شده-با-let-و-const-رو-مجددا-declare-کنیم)                                           | 162  |
| 307  | [آیا استفاده از const برای تعریف متغیر اونا رو immutable میکنه؟](#آیا-استفاده-از-const-برای-تعریف-متغیر-اونا-رو-immutable-میکنه)                                                         | 163  |
| 308  | [parameterهای پیش‌فرض چی هستن؟](#parameterهای-پیشفرض-چی-هستن)                                                                                                                            | 163  |
| 309  | [template-literalها چی هستن؟](#template-literalها-چی-هستن)                                                                                                                               | 164  |
| 310  | [چطوری رشته‌های چند خطی رو توی template-literalها می‌نویسیم؟](#چطوری-رشتههای-چند-خطی-رو-توی-template-literalها-مینویسیم)                                                                 | 165  |
| 311  | [template-literal‌های تودرتو چی هستن؟](#template-literalهای-تودرتو-چی-هستن)                                                                                                              | 165  |
| 312  | [tagged-templateها چی هستن؟](#tagged-templateها-چی-هستن)                                                                                                                                 | 165  |
| 313  | [رشته‌های خام چی هستن؟](#رشتههای-خام-چی-هستن)                                                                                                                                            | 166  |
| 314  | [assign کردن با destructuring چیه و چطوری انجام می‌شه؟](#assign-کردن-با-destructuring-چیه-و-چطوری-انجام-می‌شه)                                                                           | 167  |
| 315  | [موقع assign کردن با destructuring چطوری می‌شه مقدار اولیه تعریف کرد؟](#موقع-assign-کردن-با-destructuring-چطوری-می‌شه-مقدار-اولیه-تعریف-کرد)                                             | 168  |
| 316  | [چطوری می‌تونیم مقدار یه آرایه رو با استفاده از destructuring-assignment تعویض کنیم؟](#چطوری-می‌تونیم-مقدار-یه-آرایه-رو-با-استفاده-از-destructuring-assignment-تعویض-کنیم)               | 168  |
| 317  | [Enhanced-object-literalها چی هستن؟](#Enhanced-object-literalها-چی-هستن)                                                                                                                 | 169  |
| 318  | [importهای داینامیک چی هستن؟](#importهای-داینامیک-چی-هستن)                                                                                                                               | 169  |
| 319  | [کاربرد importهای داینامیک چیه؟](#کاربرد-importهای-داینامیک-چیه)                                                                                                                         | 169  |
| 320  | [آرایه‌های نوع‌دار(typed-arrays) چیه؟](#آرایههای-نوعدارtyped-arrays-چیه)                                                                                                                 | 170  |
| 321  | [مزایای لودر ماژول‌ها چیه؟](#مزایای-لودر-ماژولها-چیه)                                                                                                                                    | 171  |
| 322  | [collation چیه؟](#collation-چیه)                                                                                                                                                         | 171  |
| 323  | [عبارت for...of چیه؟](#عبارت-forof-چیه)                                                                                                                                                  | 171  |
| 324  | [خروجی عملگر spread روی آرایه زیر چیه؟](#خروجی-عملگر-spread-روی-آرایه-زیر-چیه)                                                                                                           | 172  |
| 325  | [آیا PostMessage امنه؟](#آیا-PostMessage-امنه)                                                                                                                                           | 172  |
| 326  | [مشکلات استفاده از postmessage با origin روی wildcard چیه؟](#مشکلات-استفاده-از-postmessage-با-origin-روی-wildcard-چیه)                                                                   | 172  |
| 327  | [چطوری از دریافت postMessageهای ناخواسته و ناامن از طرف هکرها جلوگیری کنیم؟](#چطوری-از-دریافت-postMessageهای-ناخواسته-و-ناامن-از-طرف-هکرها-جلوگیری-کنیم)                                 | 173  |
| 328  | [می‌تونیم کلا postMessageها رو غیرفعال کنیم؟](#می‌تونیم-کلا-postMessageها-رو-غیرفعال-کنیم)                                                                                               | 173  |
| 329  | [آیا postMessageها به صورت synchronous و همزمان کار می‌کنن؟](#آیا-postMessageها-به-صورت-synchronous-و-همزمان-کار-میکنن)                                                                  | 173  |
| 330  | [پارادیم زبان جاواسکریپت چیه؟](#پارادیم-زبان-جاواسکریپت-چیه)                                                                                                                             | 174  |
| 331  | [تفاوت‌های بین جاواسکریپت داخلی و خارجی چیه؟](#تفاوتهای-بین-جاواسکریپت-داخلی-و-خارجی-چیه)                                                                                                | 174  |
| 332  | [آیا جاواسکریپت سریعتر از اسکریپت‌های سمت سرور است؟](#آیا-جاواسکریپت-سریعتر-از-اسکریپتهای-سمت-سرور-است)                                                                                  | 174  |
| 333  | [چطوری وضعیت چک بودن یه checkbox رو بدست بیاریم؟](#چطوری-وضعیت-چک-بودن-یه-checkbox-رو-بدست-بیاریم)                                                                                       | 174  |
| 334  | [هدف از عملگر double-tilde چیه؟](#هدف-از-عملگر-double-tilde-چیه)                                                                                                                         | 175  |
| 335  | [چطوری یه کاراکتر رو به کد ASCII تبدیل کنیم؟](#چطوری-یه-کاراکتر-رو-به-کد-ASCII-تبدیل-کنیم)                                                                                               | 175  |
| 336  | [ArrayBuffer چیه؟](#ArrayBuffer-چیه)                                                                                                                                                     | 175  |
| 337  | [خروجی کد زیر چی خواهد بود؟](#خروجی-کد-زیر-چی-خواهد-بود)                                                                                                                                 | 176  |
| 338  | [هدف از Error-object چیه؟](#هدف-از-Error-object-چیه)                                                                                                                                     | 176  |
| 339  | [هدف از EvalError-object چیه؟](#هدف-از-EvalError-object-چیه)                                                                                                                             | 177  |
| 340  | [خطاهایی که در حالت strict-mode رخ میدن ولی در غیر اون وجود ندارن کدوما هستن؟](#خطاهایی-که-در-حالت-strict-mode-رخ-میدن-ولی-در-غیر-اون-وجود-ندارن-کدوما-هستن)                             | 177  |
| 341  | [آیا همه objectها دارای prototype هستن؟](#آیا-همه-objectها-دارای-prototype-هستن)                                                                                                         | 178  |
| 342  | [تفاوت‌های بین parameter و argument چیه؟](#تفاوتهای-بین-parameter-و-argument-چیه)                                                                                                        | 178  |
| 343  | [هدف از متد some روی آرایه‌ها چیه؟](#هدف-از-متد-some-روی-آرایهها-چیه)                                                                                                                    | 178  |
| 344  | [چطوری دو یا تعداد بیشتری از آرایه‌ها رو با هم ترکیب کنیم؟](#چطوری-دو-یا-تعداد-بیشتری-از-آرایهها-رو-با-هم-ترکیب-کنیم)                                                                    | 179  |
| 345  | [تفاوت‌های بین Shallow و Deep کپی چیه؟](#تفاوتهای-بین-Shallow-و-Deep-کپی-چیه)                                                                                                            | 179  |
| 346  | [چطوری می‌تونیم به یه تعداد مشخص از یه رشته کپی کنیم؟](#چطوری-می‌تونیم-به-یه-تعداد-مشخص-از-یه-رشته-کپی-کنیم)                                                                             | 180  |
| 347  | [چطوری همه stringهای match شده با یه regular-expression رو برگردونیم؟](#چطوری-همه-stringهای-match-شده-با-یه-regular-expression-رو-برگردونیم)                                             | 181  |
| 348  | [چطوری یه رشته رو از اول یا از آخر trim کنیم؟](#چطوری-یه-رشته-رو-از-اول-یا-از-آخر-trim-کنیم)                                                                                             | 181  |
| 349  | [خروجی کنسول زیر با عملگر unary چی می‌شه؟](#خروجی-کنسول-زیر-با-عملگر-unary-چی-می‌شه)                                                                                                     | 181  |
| 350  | [آیا جاواسکریپت از mixinها استفاده میکنه؟](#آیا-جاواسکریپت-از-mixinها-استفاده-میکنه)                                                                                                     | 182  |
| 351  | [تابع thunk چیه و چیکار میکنه؟](#تابع-thunk-چیه-و-چیکار-میکنه)                                                                                                                           | 182  |
| 352  | [thunkهای asynchronous چیکار می‌کنن؟](#thunkهای-asynchronous-چیکار-میکنن)                                                                                                                | 182  |
| 353  | [خروجی فراخوانی‌های توابع زیر چی می‌شه؟](#خروجی-فراخوانیهای-توابع-زیر-چی-می‌شه)                                                                                                          | 183  |
| 354  | [چطوری همه خطوط جدید رو از یه رشته حذف کرد؟](#چطوری-همه-خطوط-جدید-رو-از-یه-رشته-حذف-کرد)                                                                                                 | 184  |
| 355  | [تفاوت‌ بین reflow و repaint چیه؟](#تفاوت-بین-reflow-و-repaint-چیه)                                                                                                                      | 184  |
| 356  | [اگه قبل از یه آرایه عملگر نفی «!» بزاریم چی می‌شه؟](#اگه-قبل-از-یه-آرایه-عملگر-نفی-«!»-بزاریم-چی-می‌شه)                                                                                 | 184  |
| 357  | [اگه دو تا آرایه رو با هم جمع ببندیم چی می‌شه؟](#اگه-دو-تا-آرایه-رو-با-هم-جمع-ببندیم-چی-می‌شه)                                                                                           | 185  |
| 358  | [اگه عملگر جمع «+» روی قبل از مقادیر falsy قرار بدیم چی می‌شه؟](#اگه-عملگر-جمع-«+»-روی-قبل-از-مقادیر-falsy-قرار-بدیم-چی-می‌شه)                                                           | 185  |
| 359  | [چطوری با استفاده از آرایه‌ها و عملگرهای منطقی می‌تونیم رشته self رو تولید کنیم؟](#چطوری-با-استفاده-از-آرایهها-و-عملگرهای-منطقی-می‌تونیم-رشته-self-رو-تولید-کنیم)                        | 185  |
| 360  | [چطوری می‌تونیم مقادیر falsy رو از آرایه حذف کنیم؟](#چطوری-می‌تونیم-مقادیر-falsy-رو-از-آرایه-حذف-کنیم)                                                                                   | 186  |
| 361  | [چطوری مقادیر تکراری رو از یه آرایه حذف کنیم؟](#چطوری-مقادیر-تکراری-رو-از-یه-آرایه-حذف-کنیم)                                                                                             | 186  |
| 362  | [aliaseهای همزمان با destructuring چطوری کار می‌کنن؟](#aliaseهای-همزمان-با-destructuring-چطوری-کار-میکنن)                                                                                | 187  |
| 363  | [چطوری آیتم‌های یه آرایه رو بدون استفاده از متد map پیمایش کنیم؟](#چطوری-آیتمهای-یه-آرایه-رو-بدون-استفاده-از-متد-map-پیمایش-کنیم)                                                        | 187  |
| 364  | [چطوری یه آرایه رو خالی کنیم؟](#چطوری-یه-آرایه-رو-خالی-کنیم)                                                                                                                             | 187  |
| 365  | [چطوری اعداد رو با تعداد رقم اعشار مشخص رند می‌کنی؟](#چطوری-اعداد-رو-با-تعداد-رقم-اعشار-مشخص-رند-می‌کنی)                                                                                 | 188  |
| 366  | [ساده‌ترین روش برای تبدیل آرایه به object چیه؟](#سادهترین-روش-برای-تبدیل-آرایه-به-object-چیه)                                                                                            | 188  |
| 367  | [چطوری یه آرایه با یه سری داده درست کنیم؟](#چطوری-یه-آرایه-با-یه-سری-داده-درست-کنیم)                                                                                                     | 188  |
| 368  | [متغیرهای موجود روی آبجکت console کدوما هستن؟](#متغیرهای-موجود-روی-آبجکت-console-کدوما-هستن)                                                                                             | 188  |
| 369  | [می‌شه پیام‌های کنسول رو استایل‌دهی کرد؟](#می‌شه-پیامهای-کنسول-رو-استایلدهی-کرد)                                                                                                         | 189  |
| 370  | [هدف از متد dir روی آبجکت console چیه؟](#هدف-از-متد-dir-روی-آبجکت-console-چیه)                                                                                                           | 189  |
| 371  | [آیا می‌شه المنت‌های HTML رو توی console دیباگ کرد؟](#آیا-می‌شه-المنتهای-HTML-رو-توی-console-دیباگ-کرد)                                                                                  | 190  |
| 372  | [چطوری می‌شه داده‌ها رو به شکل جدولی توی console نمایش بدیم؟](#چطوری-می‌شه-دادهها-رو-به-شکل-جدولی-توی-console-نمایش-بدیم)                                                                | 190  |
| 373  | [چطوری می‌شه بررسی کرد که یه پارامتر Number هست یا نه؟](#چطوری-می‌شه-بررسی-کرد-که-یه-پارامتر-Number-هست-یا-نه)                                                                           | 191  |
| 374  | [چطوری یه متن رو می‌تونیم به clipboard کپی کنیم؟](#چطوری-یه-متن-رو-می‌تونیم-به-clipboard-کپی-کنیم)                                                                                       | 191  |
| 375  | [چطوری می‌شه timestamp رو بدست آورد؟](#چطوری-می‌شه-timestamp-رو-بدست-آورد)                                                                                                               | 191  |
| 376  | [چطوری یه آرایه چندسطحی رو تک سطحی کنیم؟](#چطوری-یه-آرایه-چندسطحی-رو-تک-سطحی-کنیم)                                                                                                       | 192  |
| 377  | [ساده‌ترین روش برای بررسی چندشرطی چیه؟](#سادهترین-روش-برای-بررسی-چندشرطی-چیه)                                                                                                            | 192  |
| 378  | [چطوری کلیک روی دکمه برگشت مرورگر رو متوجه بشیم؟](#چطوری-کلیک-روی-دکمه-برگشت-مرورگر-رو-متوجه-بشیم)                                                                                       | 193  |
| 379  | [چطوری می‌تونیم کلیک راست رو غیرفعال کنیم؟](#چطوری-می‌تونیم-کلیک-راست-رو-غیرفعال-کنیم)                                                                                                   | 193  |
| 380  | [object-wrapperها چی هستن؟](#object-wrapperها-چی-هستن)                                                                                                                                   | 193  |
| 381  | [AJAX چیه؟](#AJAX-چیه)                                                                                                                                                                   | 194  |
| 382  | [روش‌های مختلف مدیریت یه کد Asynchronous چیه؟](#روشهای-مختلف-مدیریت-یه-کد-Asynchronous-چیه)                                                                                              | 194  |
| 383  | [چطوری یه درخواست fetch رو کنسل کنیم؟](#چطوری-یه-درخواست-fetch-رو-کنسل-کنیم)                                                                                                             | 194  |
| 384  | [Speech-API چیه؟](#Speech-API-چیه)                                                                                                                                                       | 195  |
| 385  | [حداقل timeout توی throttling چقدره؟](#حداقل-timeout-توی-throttling-چقدره)                                                                                                               | 196  |
| 386  | [چطوری می‌شه یه timeout صفر توی مرورگر اجرا کرد؟](#چطوری-می‌شه-یه-timeout-صفر-توی-مرورگر-اجرا-کرد)                                                                                       | 197  |
| 387  | [taskها توی event-loop چی هستن؟](#taskها-توی-event-loop-چی-هستن)                                                                                                                         | 197  |
| 388  | [microtaskها چی هستن؟](#microtaskها-چی-هستن)                                                                                                                                             | 198  |
| 389  | [event-loopهای مختلف کدوما هستن؟](#event-loopهای-مختلف-کدوما-هستن)                                                                                                                       | 198  |
| 390  | [هدف از queueMicrotask چیه؟](#هدف-از-queueMicrotask-چیه)                                                                                                                                 | 198  |
| 391  | [چطوری می‌شه از کتابخونه‌های جاواسکریپت توی فایل typescript استفاده کرد؟](#چطوری-می‌شه-از-کتابخونههای-جاواسکریپت-توی-فایل-typescript-استفاده-کرد)                                        | 199  |
| 392  | [تفاوت‌های بین Promiseها و observableها کدوما هستن؟](#تفاوتهای-بین-promiseها-و-observableها-کدوما-هستن)                                                                                  | 199  |
| 393  | [heap چیه؟](#heap-چیه)                                                                                                                                                                   | 200  |
| 394  | [event-table چیه؟](#event-table-چیه)                                                                                                                                                     | 200  |
| 395  | [صف microTask چیه؟](#صف-microTask-چیه)                                                                                                                                                   | 201  |
| 396  | [تفاوت بین shim و polyfill چیه؟](#تفاوت-بین-shim-و-polyfill-چیه)                                                                                                                         | 201  |
| 397  | [چطوری متوجه primitive یا غیر primitive بودن یه نوع داده میشیم؟](#چطوری-متوجه-primitive-یا-غیر-primitive-بودن-یه-نوع-داده-میشیم)                                                         | 202  |
| 398  | [babel چیه؟](#babel-چیه)                                                                                                                                                                 | 202  |
| 399  | [آیا Node.js به شکل کامل تک thread کار میکنه؟](#آیا-Nodejs-به-شکل-کامل-تک-thread-کار-میکنه)                                                                                              | 202  |
| 400  | [کاربردهای مرسوم observableها کدوما هستن؟](#کاربردهای-مرسوم-observableها-کدوما-هستن)                                                                                                     | 203  |
| 401  | [RxJS چیه؟](#RxJS-چیه)                                                                                                                                                                   | 203  |
| 402  | [تفاوت بین Function-constructor و function-declaration چیه؟](#تفاوت-بین-Function-constructor-و-function-declaration-چیه)                                                                 | 203  |
| 403  | [شرط Short-circuit یا اتصال کوتاه چیه؟](#شرط-Short-circuit-یا-اتصال-کوتاه-چیه)                                                                                                           | 204  |
| 404  | [ساده‌ترین روش برای تغییر سایز یه آرایه چیه؟](#سادهترین-روش-برای-تغییر-سایز-یه-آرایه-چیه)                                                                                                | 204  |
| 405  | [observable چیه؟](#observable-چیه)                                                                                                                                                       | 205  |
| 406  | [تفاوت‌های بین توابع و کلاس‌ها چیه؟](#تفاوتهای-بین-توابع-و-کلاسها-چیه)                                                                                                                   | 206  |
| 407  | [تابع async چیه؟](#تابع-async-چیه)                                                                                                                                                       | 207  |
| 408  | [چطوری خطاهای ایجاد شده هنگام استفاده از Promiseها رو کنترل کنیم؟](#چطوری-خطاهای-ایجاد-شده-هنگام-استفاده-از-promiseها-رو-کنترل-کنیم)                                                     | 207  |
| 409  | [Deno چیه؟](#Deno-چیه)                                                                                                                                                                   | 209  |
| 410  | [توی جاواسکریپت چطوری یه object قابل پیمایش درست کنیم؟](#توی-جاواسکریپت-چطوری-یه-object-قابل-پیمایش-درست-کنیم)                                                                           | 209  |
| 411  | [روش مناسب برای فراخوانی توابع بازگشتی چیه؟](#روش-مناسب-برای-فراخوانی-توابع-بازگشتی-چیه)                                                                                                 | 211  |
| 412  | [چطوری بررسی کنیم که یه آبجکت Promise هست یا نه؟](#چطوری-بررسی-کنیم-که-یه-آبجکت-promise-هست-یا-نه)                                                                                       | 211  |
| 413  | [چطوری متوجه بشیم که یا تابع با تابع constructor صدا زده شده یا نه؟](#چطوری-متوجه-بشیم-که-یا-تابع-با-تابع-constructor-صدا-زده-شده-یا-نه)                                                 | 212  |
| 414  | [تفاوت‌های بین آبجکت argument و پارامتر rest چیه؟](#تفاوتهای-بین-آبجکت-argument-و-پارامتر-rest-چیه)                                                                                      | 213  |
| 415  | [تفاوت‌های بین عملگر spread و پارامتر rest چیه؟](#تفاوتهای-بین-عملگر-spread-و-پارامتر-rest-چیه)                                                                                          | 213  |
| 416  | [نوع‌های مختلف generatorها کدوما هستن؟](#نوعهای-مختلف-generatorها-کدوما-هستن)                                                                                                            | 213  |
| 417  | [iterableهای built-in کدوما هستن؟](#iterableهای-built-in-کدوما-هستن)                                                                                                                     | 215  |
| 418  | [تفاوت‌های بین حلقه for...of و for...in چیه؟](#تفاوتهای-بین-حلقه-forof-و-forin-چیه)                                                                                                      | 215  |
| 419  | [چطوری propertyهای instance و غیر instanceای تعریف می‌کنی؟](#چطوری-propertyهای-instance-و-غیر-instanceای-تعریف-می‌کنی)                                                                   | 216  |
| 420  | [تفاوت‌های بین isNaN و Number.isNaN کدوما هستن؟](#تفاوتهای-بین-isNaN-و-NumberisNaN-کدوما-هستن)                                                                                           | 216  |

</div>

{Pishgoftar}

<div dir="rtl" align="right">
<br />
<br />

1. ### روش‌های ایجاد objectها توی جاواسکریپت کدوما هستن؟

   1. **سازنده آبجکت:** ساده‌ترین راه برای ایجاد یه آبجکت خالی استفاده از کلاس Objectـه. در حال حاضر این روش توصیه نمی‌شه.

    <span dir="ltr" align="left">

   ```js
   const object = new Object();
   ```

    </span>

   2. **متد استاتیک create روی Object:** متد استاتیک create روی Object با انتقال prototype آبجکت به عنوان پارامتر، یه آبجکت جدید ایجاد میکنه.

    <span dir="ltr" align="left">

   ```js
   const object = Object.create(null);
   ```

    </span>

   3. **استفاده از syntax آبجکت:** با مقداردهی یه متغیر توسط یه آبجکت ساده داخل syntax آبجکت.

    <span dir="ltr" align="left">

   ```js
   const object = {
     name: "Ali Karimi",
     age: 30,
   };
   ```

    </span>

   4. **constructor تابع:** هر تابعی که بخوایم رو ایجاد می‌کنیم و از طریق عملگر new یه نمونه آبجکت جدید می‌سازیم.

    <span dir="ltr" align="left">

   ```js
   function Person(name) {
     const object = {};
     object.name = name;
     object.age = 30;

     return object;
   }

   const object = new Person("Ali Karimi");
   ```

    </span>

   5. **constructor تابع به همراه prototype** شبیه سازنده تابع هستش اما از prototype برای متد‌ها و خصوصیاتشون استفاده میکنه.

    <span dir="ltr" align="left">

   ```js
   function Person() {}
   Person.prototype.name = "Ali Karimi";

   const object = new Person();
   ```

    </span>

   این معادل نمونه‌ای هستش که با متد ایجاد آبجکت با prototype تابع ایجاد شده و تابع رو با یه نمونه و پارامتر‌هاش به عنوان آرگومان فراخوانی میکنه.

    <span dir="ltr" align="left">

   ```js
   function func() {}

   new func(x, y, z);
   ```

    </span>

   **(یا)**

    <span dir="ltr" align="left">

   ```js
   // Create a new instance using function prototype.
   const newInstance = Object.create(func.prototype)

   // Call the function
   const result = func.call(newInstance, x, y, z),

   // If the result is a non-null object then use it otherwise just use the new instance.
   console.log(result && typeof result === 'object' ? result : newInstance);
   ```

    </span>

   6. **استفاده از کلاس‌های ES6:** توی ES6 کلمه کلیدی class رو برای ایجاد آبجکت‌ها معرفی کردن.

    <span dir="ltr" align="left">

   ```js
   class Person {
     constructor(name) {
       this.name = name;
     }
   }

   const object = new Person("Ali Karimi");
   ```

    </span>

   7. **الگو یا پترن Singleton:** آبجکت‌ای‌ـه که فقط یه بار قابل نمونه‌گیری هستش و فراخوانی‌های بعدی روی سازنده‌ش همون نمونه اولی رو برمی‌گردونه و اینطوری می‌شه مطمئن شد که به طور تصادفی نمونه‌های مختلف ایجاد نمی‌شه.

    <span dir="ltr" align="left">

   ```js
   const object = new (function () {
     this.name = "Ali Karimi";
   })();
   ```

    </span>

    <br />

   **[فهرست](#فهرست)**

2. ### زنجیره prototype چیه؟

   **زنجیره prototype** برای ساخت انواع جدیدی از آبجکت‌ها بر‌اساس موارد موجود استفاده می‌شه. این کار شبیه ارث بری توی یه زبان مبتنی بر کلاس هستش. prototype روی نمونه آبجکت از طریق ویژگی **Object.getPrototypeOf(object)** یا \***\*proto\*\*** در دسترسه در حالی که prototype توی عملکرد سازنده‌ها از طریق object.prototype در دسترسه.

    <br />

    <img src="images/prototype_chain.png" align="center" alt="زنجیره prototype چیه؟" />

   **[فهرست](#فهرست)**

3. ### تفاوت‌های بین call، apply و bind چیا هستن؟

   **متد call:** متد call یه تابع با یه مقدار `this` و آرگومان‌های ارائه شده رو دونه دونه فراخوانی میکنه.

    <span dir="ltr" align="left">

   ```js
   const employee1 = {
     firstName: "John",
     lastName: "Rodson",
   };
   const employee2 = {
     firstName: "Jimmy",
     lastName: "Baily",
   };

   function invite(greeting1, greeting2) {
     console.log(
       `${greeting1} ${this.firstName} ${this.lastName}, ${greeting2}`
     );
   }

   invite.call(employee1, "Hello", "How are you?"); // Hello John Rodson, How are you?
   invite.call(employee2, "Hello", "How are you?"); // Hello Jimmy Baily, How are you?
   ```

    </span>

   **متد apply:** تابع رو فراخوانی میکنه و بهمون اجازه میده تا آرگومان‌ها رو به عنوان یه آرایه منتقل کنیم.

    <span dir="ltr" align="left">

   ```js
   const employee1 = { firstName: "John", lastName: "Rodson" };
   const employee2 = { firstName: "Jimmy", lastName: "Baily" };

   function invite(greeting1, greeting2) {
     console.log(
       `${greeting1} ${this.firstName} ${this.lastName}, ${greeting2}`
     );
   }

   invite.apply(employee1, ["Hello", "How are you?"]); // Hello John Rodson, How are you?
   invite.apply(employee2, ["Hello", "How are you?"]); // Hello Jimmy Baily, How are you?
   ```

    </span>

   **متد bind:** یه تابع جدید برمی‌گردونه، در حالی که بهمون اجازه میده هر تعداد آرگومانی که می خوایم رو توی یه آرایه منتقل کنیم.

    <span dir="ltr" align="left">

   ```js
   const employee1 = { firstName: "John", lastName: "Rodson" };
   const employee2 = { firstName: "Jimmy", lastName: "Baily" };

   function invite(greeting1, greeting2) {
     console.log(
       `${greeting1} ${this.firstName} ${this.lastName}, ${greeting2}`
     );
   }

   const inviteEmployee1 = invite.bind(employee1);
   const inviteEmployee2 = invite.bind(employee2);
   inviteEmployee1("Hello", "How are you?"); // Hello John Rodson, How are you?
   inviteEmployee2("Hello", "How are you?"); // Hello Jimmy Baily, How are you?
   ```

    </span>

   متدهای `call` و `apply` تقریباً قابل تعویض هستن. هر دو بلافاصله تابع فعلی رو اجرا می‌کنن. شما باید تصمیم بگیرین که ارسال آرایه در آرایه آسون‌تره یا فهرستی از آرگومان‌های جدا شده با کاما. باید یادمون باشه که متد call برای کاما (فهرست جدا شده) و apply برای حالت آرایه‌ای‌ـه. در حالی که bind یه تابع جدید ایجاد میکنه و می‌تونه با دریافت «this» روی اولین پارامتر ارسال شده کانتکست آبجکت جدید ساخته رو تنظیم کنه.

   **[فهرست](#فهرست)**

4. ### فرمت JSON چیه و عملیات‌های معمول روی اون چیا هستن؟

   **JSON** یه قالب داده مبتنی برمتن‌‌ـه که از syntax آبجکت جاواسکریپت (Javascript objext syntax) پیروی میکنه و توسط `Douglas Crockford` رایج شد. کاربردش زمانی‌ـه که بخواییم داده‌ها رو از طریق شبکه انتقال بدیم و اساسا یه فایل متنی با پسوند .json و نوع MIME از application/json داشته باشیم. اکثرا دو عملیات زیر روی JSON انجام میشه:

    <br />

   **تجزیه (Parsing):** تبدیل یه رشته به یه آبجکت جاواسکریپت (native Object).

    <span dir="ltr" align="left">

   ```js
   JSON.parse(text);
   ```

    </span>

   **رشته‌سازی (stringify کردن):** تبدیل یه آبجکت جاواسکریپت به یه رشته تا بتونه از طریق شبکه منتقل بشه یا یه جایی ذخیره بشه.

    <span dir="ltr" align="left">

   ```js
   JSON.stringify(object);
   ```

    </span>

   **[فهرست](#فهرست)**

5. ### هدف از متد slice روی آرایه‌ها چیه؟

   متد **slice** عناصر انتخاب شده توی یه آرایه رو به عنوان یه آرایه جدید برمی‌گردونه. این عناصر رو از اولین آرگومان داده شده انتخاب میکنه و با آرگومان پایانی و اختیاری داده شده بدون در نظر گرفتن آخرین عنصر به پایان می‌رسونه. اگه آرگومان دوم رو حذف کنیم تا آخر آرایه همه عناصر رو انتخاب میکنه. چند تا مثال در مورد نحوه کارکردش ببینیم:

    <br />

    <span dir="ltr" align="left">

   ```js
   const arrayIntegers = [1, 2, 3, 4, 5];
   const arrayIntegers1 = arrayIntegers.slice(0, 2); // returns [1,2]
   const arrayIntegers2 = arrayIntegers.slice(2, 3); // returns [3]
   const arrayIntegers3 = arrayIntegers.slice(4); // returns [5]
   ```

    </span>

   **نکته:** متد slice‌ آرایه اصلی رو تغییر نمیده ولی یه زیر‌مجموعه به عنوان یه آرایه جدید برمی‌گردونه.

   **[فهرست](#فهرست)**

6. ### هدف از متد splice روی آرایه‌ها چیه؟

   متد **splice** برای اضافه کردن یه عنصر به آرایه یا حذف از اون استفاده می‌شه و مورد یا موارد حذف شده رو برمی‌گردونه. آرگومان اول موقعیت آرایه رو برای درج یا حذف مشخص میکنه در حالی که آرگومان اختیاری دوم تعداد عناصر برای حذف رو مشخص میکنه و مابقی هر آرگومان اضافه‌ای که به این متد ارسال بشه، به آرایه اضافه می‌شه. چند تا مثال در مورد نحوه کارکردش ببینیم:

    <br />

    <span dir="ltr" align="left">

   ```js
   const arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
   const arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
   const arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

   const arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // returns [1, 2]; original array: [3, 4, 5]
   const arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
   const arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); // returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
   ```

    </span>

   **نکته:** متد splice آرایه اصلی رو اصلاح میکنه یعنی متغیر اصلی رو تحت تاثیر قرار میده و آرایه حذف شده رو برمی‌گردونه.

   **[فهرست](#فهرست)**

7. ### تفاوت متدهای slice و splice چیا هستن؟

   | slice                                                | splice                                              |
   | ---------------------------------------------------- | --------------------------------------------------- |
   | آرایه اصلی رو تغییر نمیده (immutable یا تغییرناپذیر) | آرایه اصلی رو تغییر میده (mutable یا تغییرپذیر)     |
   | زیر مجموعه آرایه اصلی رو برمی‌گردونه                 | عناصر حذف شده رو به عنوان آرایه برمی‌گردونه         |
   | برای انتخاب عناصر از آرایه استفاده می‌شه             | برای درج عناصر به آرایه یا حذف از اون استفاده می‌شه |

   **[فهرست](#فهرست)**

8. ### تفاوت‌های Object و Map چیا هستن؟

   **آبجکت‌ها** شبیه به **Mapها** هستن(البته خود Map هم آبجکته و اینجا منظور شاعر خود شخص Object رو میگه) از این جهت که هردو بهمون این امکان رو میدن که مقادیر رو روی کلید‌های مشخصی تعریف کنیم، مقادیر رو بازیابی کنیم، کلید‌ها رو حذف کنیم و ببینیم چیزی توی یه کلید ذخیره شده یا نه. به همین دلیل در طول تاریخ از آبجکت‌ها به عنوان Map و HashMap استفاده‌های زیادی شده. اما تفاوت‌های مهمی وجود داره که استفاده از Map رو توی موارد خاص ارجعیت میده.

   1. کلید‌های یه آبجکت رشته‌ها و Symbolها هستن، در حالی که برای Map مقادیر مختلفی میتونه وجود داشته باشه که شامل توابع، آبجکت‌ها و هر نوع اولیه دیگه‌ای می‌شه.
   2. کلید‌های Map مرتب میشن در حالی که کلید‌های اضافه شده به آبجکت اینطوری نیستن. بنابراین موقع تکرار روی اون، آبجکت map کلیدها رو به ترتیب اضافه شدنشون برمی‌گردونه.
   3. اندازه Map رو می‌تونیم به راحتی با ویژگی سایز بدست بیاریم، در حالی که تعداد خصوصیات یه آبجکت باید به صورت دستی و با ساخت یه آرایه از روی کلیدها و یا مقادیرش حساب بشه.
   4. Map قابل تکراره و میتونه مستقیما تکرار بشه، در حالی که تکرار روی یه آبجکت مستلزم بدست آوردن کلیدهای اون به روشی خاص و تکرار روی اونهاست.
   5. آبجکت یه prototype داره، بنابراین کلید‌های پیش‌فرض توی Object وجود داره که که اگه دقت نکنیم ممکنه با کلید‌هامون برخورد کنه. از زمان ES5 می‌تونیم با استفاده از Map = Object.create(null)، این قضیه رو دور بزنیم ولی به‌ندرت این کار انجام می‌شه.
   6. Map ممکنه توی سناریوهای شامل جمع و حذف مکرر جفت کلیدها عملکرد بهتری داشته باشه.

   **[فهرست](#فهرست)**

9. ### تفاوت‌های بین عملگرهای == و === چیا هستن؟

   جاواسکریپت مقایسه برابری سخت ( === ، !== ) و تبدیل نوع ( == ، != ) رو فراهم میکنه. عملگرهای سختگیرانه نوع متغیر رو در نظر می‌گیرند، در حالی که عملگرهای غیر دقیق، اصلاح/تبدیل نوع رو بر اساس مقادیر متغیرها انجام میدن. اپراتورهای سختگیر از شرایط زیر برای انواع مختلف پیروی می‌کنن.

   1. دو رشته زمانی کاملاً برابر هستن که توالی کاراکترهای یکسان، طول یکسان و کاراکترهای مشابه در موقعیت‌های متناظر داشته باشن.
   2. دو عدد زمانی که از نظر عددی مساوی باشن کاملاً برابر هستن. یعنی داشتن مقدار عددی یکسان.

   دو مورد خاص در این مورد وجود داره:

   1. NaN با هیچ چیز از جمله NaN برابر نیست.
   2. صفرهای مثبت و منفی با هم برابرند.
   3. اگه هر دو درست یا نادرست باشن، دو عملوند بولین کاملاً برابر هستن.
   4. اگه دو شیء به یه شیء اشاره کنن کاملاً برابر هستن.
   5. انواع Null و Undefined با === برابر نیستن، بلکه با == برابر هستن. یعنی
      null === undefined --> false اما null == undefined --> true

   یه چندتا مثال که موارد بالا رو پوشش میدن:

    <span dir="ltr" align="left">

   ```js
   0 == false   // true
   0 === false  // false
   1 == "1"     // true
   1 === "1"    // false
   null == undefined // true
   null === undefined // false
   '0' == false // true
   '0' === false // false
   []==[] or []===[] //false, refer different objects in memory
   {}=={} or {}==={} //false, refer different objects in memory
   ```

    </span>

   **[فهرست](#فهرست)**

10. ### توابع lambda یا arrow-function چی هستن؟

    arrow function ‌ها به صورت ساده‌تر و کوتاه‌تر تعریف میشن و **شئ this** ، **متغیر جادویی argumants** ، **متد super** یا **new.target** ندارن. این توابع بدون متد هستن و به عنوان سازنده یا constructor استفاده نمیشن.

    **[فهرست](#فهرست)**

11. ### یه تابع first-class چجور تابعی‌ـه؟

    توی جاواسکریپت، توابع آبجکت‌های کلاس اول یا first class هستن. توابع کلاس اول توی هر زبان برنامه‌نویسی، زمانی معنی میدن که توابع توی اون زبان باهاشون مثل بقیه متغیر‌ها رفتار بشه.

    برای مثال، توی جاواسکریپت، یه تابع می‌تونه به عنوان آرگومان به یه تابع دیگه پاس داده بشه، می‌تونه به عنوان مقدار نهایی یه تابع دیگه برگشت داده بشه و می‌تونه به یه متغیر دیگه به عنوان مقدار اختصاص داده بشه. برای مثال توی کد زیر، تابع handler به عنوان callback به یه تابع listener پاس داده شده.

     <span dir="ltr" align="left">

    ```js
    const handler = () => console.log("This is a click handler function");

    /**
     * Usage of `handler` method
     */
    document.addEventListener("click", handler);
    ```

     </span>

    **[فهرست](#فهرست)**

12. ### یه تابع first-order چجور تابعی‌ـه؟

    تابع مرتبه اول یا first-order تابعیه که هیچ تابع دیگه‌ای رو به عنوان آرگومان قبول نمیکنه و هیچ تابعی رو هم به عنوان مقدار برگشتی یا return value برنمی‌گردونه. مثل:

     <span dir="ltr" align="left">

    ```js
    const firstOrder = () => console.log("I am a first order function!");
    ```

     </span>

    **[فهرست](#فهرست)**

13. ### یه تابع higher-order چجور تابعی‌ـه؟

    توابع مرتبه بالا توابعی هستن که یه تابع رو به عنوان پارامتر ورودی دریافت و یا به عنوان خروجی ارسال میکنن. مثل:

     <span dir="ltr" align="left">

    ```js
    const firstOrderFunc = () =>
      console.log("Hello I am a First order function");
    const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();

    higherOrder(firstOrderFunc);
    ```

     </span>

    **[فهرست](#فهرست)**

14. ### یه تابع unary چجور تابعی‌ـه؟

    تابع unary تابعیه که فقط یه آرگومان ورودی دریافت میکنه. مثل:

     <span dir="ltr" align="left">

    ```js
    // Add 10 to the given argument and display the value
    const unaryFunction = (a) => {
      console.log(a + 10);
    };
    ```

     </span>

    **[فهرست](#فهرست)**

15. ### currying توابع یعنی چی؟

    به فرایندی که در اون یه تابع با چندین آرگومان رو به مجموعه‌ای از توابع که فقط یه آرگومان دریافت می‌کنن، تبدیل کنیم currying می‌گیم. Currying از نام یه ریاضی‌دان به اسم Haskell Curry گرفته شده. با استفاده از Currying در واقع یه تابع رو به یه تابع unary تبدیل می‌کنیم. بیاین یه مثال از یه تابع با چندین آرگومان و تبدیلش به تابع currying بزنیم.

     <span dir="ltr" align="left">

    ```js
    const multiArgFunction = (a, b, c) => a + b + c;
    const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
    curryUnaryFunction(1); // returns a function: b => c =>  1 + b + c
    curryUnaryFunction(1)(2); // returns a function: c => 3 + c
    curryUnaryFunction(1)(2)(3); // returns the number 6
    ```

     </span>

    توابع Curried برای بهبود قابلیت استفاده مجدد کد و ترکیب عملکردی عالی هستن.

    **[فهرست](#فهرست)**

16. ### چه توابعی pure هستن؟

    **تابع pure** تابعیه که مقدار برگشتیش فقط توسط آرگومان‌هاش تعیین می‌شه بدون هیج side effect یا عوارض جانبی. برای مثال اگه ما یه تابع رو n بار در n جای مختلف برنامه فراخوانی کنیم همیشه یه مقدار مشخص برگشت داده می‌شه. بیاین یه مثال از تفاوت بین توابع pure و توابع غیرpure بزنیم.

     <span dir="ltr" align="left">

    ```js
    // Impure
    const numberArray = [];
    const impureAddNumber = (number) => numberArray.push(number);

    // Pure
    const pureAddNumber = (number) => (argNumberArray) =>
      argNumberArray.concat([number]);

    // Display the results
    console.log(impureAddNumber(6)); // returns 1
    console.log(numberArray); // returns [6]
    console.log(pureAddNumber(7)(numberArray)); // returns [6, 7]
    console.log(numberArray); // returns [6]
    ```

     </span>

    بر اساس تکه کدهای بالا، تابع push با تغییر روی آرایه و برگردوندن شماره ایندکس push که مستقل از مقدار پارامتر هستش، یه تابع ناخالص یا Impure به حساب میاد. در حالی که از یه طرف متد concat آرایه رو می‌گیره و اونو با یه آرایه دیگه ترکیب میکنه و یه آرایه کاملا جدید و بدون هیچ side-effect تولید میکنه. همچنین مقدار برگشتی با آرایه قبلی ترکیب شده هستش.
    یادتون باشه که توابع خالص یا pure مهم‌ان چون اونا unite-test رو بدون هیچ side-effect و بدون نیاز به dependency-injection ساده می‌کنن. اونا همچنین از اتصال محکم بین بخش‌های مختلف برنامه جلوگیری می‌کنن و با نداشتن side-effect، احتمال بروز خطا تو برنامه رو کمک‌تر می‌کنن. این اصول کنار هم جمع میشن و کنار **Immutability** و باعث میشن که از **const** به جای **let** استفاده بشه.

    **نکته:** دقت کنیم که چاپ یه مقدار روی کنسول و یا درخواست api-call هم side-effect محسوب میشه.

    **[فهرست](#فهرست)**

17. ### هدف از کلمه کلیدی let چیه؟

    دستور `let` یه **متغیر محلی block scope** تعریف میکنه. از این رو متغیر‌هایی که با کلمه کلیدی let تعریف میشن محدود به همون اسکوپی که توش تعریف شدن، میشن و فقط دستورها و عبارت‌های توی همون اسکوپ بهش دسترسی دارن. درحالی که متغیر‌های تعریف شده با کلمه کلیدی var برای تعریف یه متغیر توی سطح global و یا به شکل محلی و برای استفاده در کل تابع بدون در نظر گرفتن اسکوپی که توش تعریف شده، استفاده می‌شه. بیاین برای نشون دادن کاربردش یه مثال بزنیم.

     <span dir="ltr" align="left">

    ```js
    const counter = 30;
    if (counter === 30) {
      const counter = 31;
      console.log(counter); // 31
    }
    console.log(counter); // 30 (because if block variable won't exist here)
    ```

     </span>

    **[فهرست](#فهرست)**

18. ### تفاوت‌های کلمات کلیدی let و var چیا هستن؟

    var :

    1. دامنه تابع داره
    2. متغیر‌ها Hoist میشن
    3. از ابتدای جاواسکریپت در دسترس هستش

     <br />

    let:

    1. به عنوان بخشی از ES6 معرفی شده
    2. محدود به scope یا دامنه هستش
    3. Hoist شده ولی قابل استفاده نیست

     <br />

    بیاین با یه مثال تفاوتش رو بهتر ببینیم:

     <span dir="ltr" align="left">

    ```js
    function userDetails(username) {
      if (username) {
        console.log(salary); // undefined(due to hoisting)
        console.log(age); // error: age is not defined (ReferenceError)
        let age = 30;
        var salary = 10000;
      }
      console.log(salary); // 10000 (accessible to due function scope)
      console.log(age); // error: age is not defined(due to block scope)
    }
    ```

     </span>

    **[فهرست](#فهرست)**

19. ### دلیل انتخاب کلمه کلیدی let چیه؟

    Let یه عنوان ریاضی هستش که توسط زبان‌های برنامه‌نویسی اولیه مثل Scheme و Basic پذیرفته شده. این زبان از ده‌ها زبان دیگه گرفته شده که از let به عنوان یه کلمه کلیدی سنتی تا حد ممکن نزدیک به var استفاده میکنه.

    **[فهرست](#فهرست)**

20. ### چطوری می‌تونیم توی بلوک مربوط به switch بدون دریافت خطا متغیر تعریف کنیم؟

    اگه بخوایم متغیر‌ها رو مجددا توی یه بلوک `switch` تعریف کنیم، این کار باعث خطا می‌شه چون در واقع فقط یه بلوک وجود داره. برای مثال توی کد زیر یه خطای نحوی ایجاد می‌شه:

     <span dir="ltr" align="left">

    ```js
    let counter = 1;
    switch (x) {
      case 0:
        let name;
        break;

      case 1:
        let name; // SyntaxError for redeclaration.
        break;
    }
    ```

     </span>

    برای جلوگیری از این خطا، می‌تونیم یه بلوک تودرتو داخل case ایجاد کنیم و یه محیط واژگانی دارای محدوده بلوک جدید ایجاد کنیم.

     <span dir="ltr" align="left">

    ```js
    const counter = 1;
    switch (x) {
      case 0: {
        let name;
        break;
      }
      case 1: {
        let name; // No SyntaxError for redeclaration.
        break;
      }
    }
    ```

     </span>

    **[فهرست](#فهرست)**

21. ### Temporal-Dead-Zone چیه؟

    Temporal Dead Zone رفتاری توی جاواسکریپت‌ـه که موقع تعریف متغیر با کلمات کلیدی let و const رخ میده، نه با کلمه کلیدی var. توی اکما‌سکریپت 6، دستیابی به متغیر let و const قبل از تعریفش (توی scope خودش) باعث خطای refrence می‌شه. فاصله زمانی ایجاد اون، بین ایجاد اتصال متغیر و تعریف اون، منطقه Temporal Dead هستش. بیاین با یه مثال ببینیم:

     <span dir="ltr" align="left">

    ```js
    function somemethod() {
      console.log(counter1); // undefined
      console.log(counter2); // ReferenceError
      var counter1 = 1;
      let counter2 = 2;
    }
    ```

     </span>

    **[فهرست](#فهرست)**

22. ### IIFE(توابع بلافاصله صدا زده شده) چی هستن؟

    IIFE (فراخوانی عملکرد بلافاصله) یه تابع جاواسکریپت‌ـه که به محض تعریف اجرا می‌شه.
    تعریف اون به این صورته:

     <span dir="ltr" align="left">

    ```js
    (function () {
      // logic here
    })();
    ```

     </span>

     <br />

    دلیل اصلی استفاده از IIFE بدست آوردن حریم خصوصی داده‌هاست، چون محیط خارجی به متغیر‌هایی که توی IIFE تعریف شده دسترسی نداره. برای مثال، اگه سعی کنیم با IIFE به متغیر‌ها دسترسی پیدا کنیم این خطا رو می‌گیریم:

     <span dir="ltr" align="left">

    ```js
    (function () {
      const message = "IIFE";
      console.log(message);
    })();

    console.log(message); // Error: message is not defined
    ```

     </span>

    **[فهرست](#فهرست)**

23. ### مزایای استفاده از moduleها چیه؟

    استفاده از ماژول‌ها مزایای زیادی داره، مثلا:

     <br />

    1. قابلیت نگهداری بالایی دارن
    2. قابلیت استفاده مجدد دارن
    3. نامگذاری بخش‌های مختلف کد رو راحت‌تر می‌کنن

    **[فهرست](#فهرست)**

24. ### Memoization چیه؟

    `Memoization` یه روش برنامه‌نویسی‌ـه که سعی میکنه با ذخیره نتایج قبلی یه تابع عملکرد(پرفورمنس performance) اون تابع رو افزایش بده. هر بار که یه تابع Memoize شده فراخوانی می‌شه، پارامتر‌های اون به همراه نتجه بدست‌ اومده cache می‌شه(یعنی توی حافظه ذخیره می‌شه). موقع اجرای بعدی قبل از انجام محاسبه بررسی میشه که داده قبلا پردازش شده یا نه و اگه داده وجود داشته باشه، بدون اجرای کل تابع و از روی مقدار cache شده نتیجه برگشت داده میشه، در غیر این صورت تابع به شکل عادی اجرا می‌شه و بعدش نتیجه بدست اومده توی حافظه ذخیره می‌شه.

     <br />

    بیاین یه مثال از نوشتن یه تابع با Memoization بزنیم،

     <span dir="ltr" align="left">

    ```js
    const memoizAddition = () => {
      const cache = {};
      return (value) => {
        if (value in cache) {
          console.log("Fetching from cache");

          return cache[value];
          // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
        }
        console.log("Calculating result");
        const result = value + 20;

        cache[value] = result;
        return result;
      };
    };

    // returned function from memoizAddition
    const addition = memoizAddition();
    console.log(addition(20)); // output: 40 calculated
    console.log(addition(20)); // output: 40 cached
    ```

     </span>

    **[فهرست](#فهرست)**

25. ### Hoisting چیه؟

    Hoisting یه مکانیسم جاواسکریپت‌ـه که متغیر‌ها و تعاریف توابع رو به بالای scope یا دامنه خودشون انتقال میده. یادمون باشه که جاواسکریپت فقط تعریف متغیر‌ها و توابع رو Hoist میکنه، نه مقدار دهی اولیه اونا رو.
    بیاین یه مثال ساده از hoist کردن متغیر‌ها ببینیم:

     <span dir="ltr" align="left">

    ```js
    console.log(message); // output : undefined
    var message = "The variable Has been hoisted";
    ```

     </span>

    ترجمه کد بالا اینطوری می‌شه:

     <span dir="ltr" align="left">

    ```js
    let message;
    console.log(message);
    message = "The variable Has been hoisted";
    ```

     </span>

    **[فهرست](#فهرست)**

26. ### Classها توی ES6 چیکار می‌کنن؟

    در ES6، کلاس‌های جاواسکریپت اصطلاحا فقط یه suger-syntax روی وراثت مبتنی بر prototype جاواسکریپت‌ هستن.
    برای مثال، وراثت مبتنی بر prototype که به شکل تابع به صورت زیر نوشته شده:

     <span dir="ltr" align="left">

    ```js
    function Bike(model, color) {
      this.model = model;
      this.color = color;
    }

    Bike.prototype.getDetails = function () {
      return `${this.model} bike has${this.color} color`;
    };
    ```

     </span>

    حالا همین کد با کلاس‌های ES6 و به شکل ساده‌تری به صورت زیر قابل نوشتن‌ـه:

     <span dir="ltr" align="left">

    ```js
    class Bike {
      constructor(color, model) {
        this.color = color;
        this.model = model;
      }

      getDetails() {
        return `${this.model} bike has${this.color} color`;
      }
    }
    ```

     </span>

    **[فهرست](#فهرست)**

27. ### Closureها چیا هستن؟

    کلاژور ترکیبی از یه تابع و یه scope هستش که تابع توی اون تعریف شده. برای مثال این یه تابع داخلی‌ـه که به متغیر‌های تابع خارجی دسترسی داره.
    کلاژور دارای سه زنجیره scope هستش:
    ۱. scope داخلی و جایی که متغیر‌های محلی بین براکت‌های اون تعریف شده باشن
    ۲. متغیر‌های تابع بیرونی
    ۳. متغیر‌های عمومی و general

    بیاین یه مثال راجع به مفهوم کلاژور بزنیم

     <span dir="ltr" align="left">

    ```js
    function welcome(name) {
      const greetingInfo = function (message) {
        console.log(`${message} ${name}`);
      };
      return greetingInfo;
    }

    const myFunction = welcome("John");
    myFunction("Welcome "); // Output: Welcome John
    myFunction("Hello Mr."); // output: Hello Mr.John
    ```

     </span>

    مطابق کد بالا، تابع داخلی (greetingInfo) حتی بعد از بازگشت تابع خارجی به متغیر‌های scope تابع خارجی (welcome) دسترسی داره.

    **[فهرست](#فهرست)**

28. ### Moduleها چیا هستن؟

    ماژول‌ها به واحد‌های کوچیکی از کد مستقل و قابل استفاده مجدد گفته میشن و به عنوان پایه بسیاری از دیزاین پترن‌های جاواسکریپت عمل می‌کنن. خروجی ماژول‌های جاواسکریپت یه شی، یه تابع یا constructor هستش.

    **[فهرست](#فهرست)**

29. ### چرا به moduleها نیاز داریم؟

    دلایل زیادی برای استفاده کردن از ماژول‌ها وجود داره که یه تعداد از اونا رو این زیر میاریم:

    1. قابلیت نگهداری
    2. قابلیت استفاده مجدد
    3. نام‌گذاری
    4. جدا بودن بخش‌های مختلف برنامه

    **[فهرست](#فهرست)**

30. ### توی جاواسکریپت scope چیه و چیکار میکنه؟

    scope یا محدوده، به نحوه دسترسی متغیر‌ها، توابع و اشیاء توی بخش‌های مختلف کدمون در زمان اجرا گفته میشه. به عبارت دیگه، دامنه قابلیت دیده شدن متغیر‌ها و بقیه منابع رو تو قسمت‌هایی از کدمون تعیین میکنه.

    **[فهرست](#فهرست)**

31. ### service-worker چیه؟

    service worker اساسا یه اسکریپت هستش که جدا از یه صفحه وب توی پس‌زمینه اجرا می‌شه و ویژگی‌هایی رو فراهم میکنه که نیازی به صفحه وب یا تعامل کاربر نداره. بعضی از ویژگی‌های عمده service worker‌ها عبارتند از: تجربه کار با برنامه بدون نیاز به اینترنت(آفلاین وب)، به روزرسانی داده‌ها به شکل متناوب در پس‌زمینه، push notification، رهگیری و رسیدگی به درخواست‌های شبکه و مدیریت درخواست‌های cache شده.

    **[فهرست](#فهرست)**

32. ### توی service-worker چطوری می‌شه DOM رو دستکاری کرد؟

    service worker مستقیما نمیتونه به DOM دسترسی پیدا کنه، اما میتونه با پاسخ به پیام‌های ارسالی از طریق رابط `postMessage` با صفحاتی که کنترل میکنه ارتباط برقرار کنه و این صفحات میتونن DOM رو دستکاری کنن.

    **[فهرست](#فهرست)**

33. ### چطوری می‌تونیم بین ریست شدن‌های service-worker داده‌های مورد نظرمون رو مجدد استفاده کنیم؟

    مشکلی که توی service worker وجود داره اینه که در صورت عدم استفاده برای یه مدت، قطع میشه و در صورت نیاز بعدی دوباره راه‌اندازی می‌شه، به همین دلیل نمی‌تونیم به state‌های سراسری توی handlerهای `onfetch` و `onmessage` یه service worker اعتماد کنیم. تو این حالت service worker برای تداوم کار و استفاده مجدد موقع شروع مجدد، به indexedDB دسترسی خواهد داشت و میشه از اون استفاده کرد.

    **[فهرست](#فهرست)**

34. ### IndexedDB چیه؟

    IndexedDB یه API سطح پایین برای ذخیره client-side یا سمت کاربر و برای مقدار زیادی از داده‌های ساخت‌ یافته(structured) شامل فایل‌ها و bolbها هستش. این API از index‌ها برای فراهم‌سازی جستجو‌ با کارایی بالا توی این داده‌ها استفاده میکنه.

    **[فهرست](#فهرست)**

35. ### Web-storage چیه؟

    web storage یه API هستش که مکانیزمی رو فراهم میکنه که مرورگر‌ها می‌تونن یه مقدار رو به همراه یه کلید و بصورت محلی توی مرورگر کاربر ذخیره کنن، که روشی بسیار مدرن‌تر و عملی‌تر نسبت به کوکی‌ها محسوب میشه. فضای ذخیره‌سازی وب دو مکانیزم برای ذخیره اطلاعات روی client فراهم میکنه.

    1. **Local storage:** داده‌ها رو برای مسیر(origin) فعلی و بدون تاریخ انقضا ذخیره میکنه.
    2. **Session storage:** داده‌ها رو برای یه session ذخیره میکنه و با بسته شدن تب مرورگر داده‌ها از بین میرن.

    **[فهرست](#فهرست)**

36. ### Post-message چیه؟

    Post message روشی هست که امکان ایجاد ارتباط متقابل بین آبجکت‌های window رو فراهم میکنه (برای مثال، بین یه صفحه و یه پنجره باز‌شو که باعث ایجاد اون شده، یا بین یه صفحه و یه iframe قرارداده شده شده توی اون)
    به طور کلی اسکریپت‌های موجود در صفحات مختلف اگه که صفحاتشون از خط‌ و مشی‌ یکسانی تبعیت کنن مجاز به دسترسی به همدیگه هستن.(یعنی صفحات از پروتکل، شماره پورت و host یکسانی برخوردار باشن).

    **[فهرست](#فهرست)**

37. ### Cookie چیه؟

    کوکی قطعه‌ای از داده هستش که توی کامپیوترمون ذخیره می‌شه تا مرورگر به اون دسترسی داشته باشه. کوکی‌ها به عنوان جفت‌های کلید و مقدار ذخیره میشن.
    برای مثال می‌تونیم یه کوکی با عنوان نام کاربری مثل زیر ایجاد کنیم:

     <span dir="ltr" align="left">

    ```js
    document.cookie = "username=John";
    ```

     </span>

     <img src="images/cookie.png" align="center" alt="Cookie illustation" />

    **[فهرست](#فهرست)**

38. ### چرا به cookie نیاز داریم؟

    از کوکی‌ها برای به خاطر سپردن اطلاعات مربوط به مشخصات کاربر (مانند نام کاربری) استفاده می‌شه. در اصل شامل دو مرحله هستش:

    1. وقتی که کاربر از یه صفحه وب بازدید میکنه، مشخصات کاربر میتونه توی یه کوکی ذخیره بشه.
    2. دفعه بعد که کاربر از صفحه بازدید کرد، کوکی مشخصات کاربر رو به خاطر میاره.

    **[فهرست](#فهرست)**

39. ### گزینه‌های قابل تنظیم توی cookie چیا هستن؟

    گزینه‌های زیر برای کوکی موجوده:

    1. به طور پیش فرض، کوکی موقع بسته شدن مرورگر حذف می‌شه اما با تنظیم تاریخ انقضا (به وقت UTC) می‌تونیم این رفتار رو تغییر بدیم.

     <span dir="ltr" align="left">

    ```js
    document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
    ```

     </span>

    2. به طور پیش فرض، کوکی به صفحه فعلی تعلق داره. اما با استفاده از پارامتر path می‌تونیم به مرورگر بگیم که کوکی متعلق به چه مسیری‌ـه.

     <span dir="ltr" align="left">

    ```js
    document.cookie = "username=John; path=/services";
    ```

     </span>

    **[فهرست](#فهرست)**

40. ### چطوری می‌شه یه cookie رو حذف کرد؟

    با تنظیم تاریخ انقضا به عنوان تاریخ گذشته می‌تونیم کوکی رو حذف کنیم. تو این حالت نیازی به تعیین مقدار کوکی نیست.
    برای مثال، می‌تونیم کوکی نام کاربری رو توی صفحه فعلی به صورت زیر حذف کنیم.

     <span dir="ltr" align="left">

    ```js
    document.cookie =
      "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
    ```

     </span>

    **نکته** برای اطمینان از نحوه درست پاک کردن کوکی باید گزینه مسیر کوکی رو تعیین کنیم. بعضی از مرورگرها تا زمانی که پارامتر مسیر رو تعیین نکنیم اجازه حذف کوکی رو نمیدن.

    **[فهرست](#فهرست)**

41. ### تفاوت‌های بین cookie و local-storage و session-storage چیا هستن؟

    | ویژگی                               | Cookie                                   | Local storage      | Session storage         |
    | ----------------------------------- | ---------------------------------------- | ------------------ | ----------------------- |
    | قابل دسترسی از طرف client یا server | هردو server و client                     | فقط client         | فقط client              |
    | طول عمر                             | پیکربندی‌شده با استفاده از گزینه اکسپایر | تا وقتی که حذف بشه | تا وقتی که تب بسته‌نشده |
    | پشتیبانی از SSL                     | پشتیبانی می‌شه                           | پشتیبانی نمی‌شه    | پشتیبانی نمی‌شه         |
    | حداکثر اندازه داده                  | 4KB                                      | 5MB                | 5MB                     |

    **[فهرست](#فهرست)**

42. ### تفاوت‌های بین localStorage و sessionStorage چیا هستن؟

    لوکال استوریج همون سشن استوریج هستش اما داده‌ها با بستن و دوباره باز کردن مرورگر همچنان حفظ می‌شه (تاریخ انقضا نداره) در حالی که سشن استوریج داده‌ها رو با بستن پنجره مرورگر پاک میکنه.

    **[فهرست](#فهرست)**

43. ### چطوری به web-storage دسترسی پیدا می‌کنی؟

    آبجکت window ویژگی‌های `WindowLocalStorage` و `WindowSessionStorage` رو که دارای ویژگی‌های `localStorage` و `sessionStorage` هستن رو پشتیبانی میکنه. این خصوصیات نمونه ای از شئ Storage رو ایجاد میکنه که از طریق اون می‌شه موارد داده رو برای یه دامنه خاص و نوع ذخیره سازی (session یا محلی) تنظیم، بازیابی و حذف کرد.

     <br />

    برای مثال، می‌تونیم روی اشیای ذخیره سازی محلی مثل زیر بخونیم و بنویسیم:

     <br />
     <span dir="ltr" align="left">

    ```js
    localStorage.setItem("logo", document.getElementById("logo").value);
    localStorage.getItem("logo");
    ```

     </span>

    **[فهرست](#فهرست)**

44. ### چه متد‌هایی روی session-storage قابل استفاده هستن؟

    session storage متد‌هایی رو برای خواندن، نوشتن و پاکسازی داده‌های session ارائه میده. مثلا:

     <span dir="ltr" align="left">

    ```js
    // Save data to sessionStorage
    sessionStorage.setItem("key", "value");

    // Get saved data from sessionStorage
    const data = sessionStorage.getItem("key");

    // Remove saved data from sessionStorage
    sessionStorage.removeItem("key");

    // Remove all saved data from sessionStorage
    sessionStorage.clear();
    ```

     </span>

    **[فهرست](#فهرست)**

    <br />

45. ### رخداد storage چیه و چطوری ازش استفاده می‌کنیم؟

    StorageEvent رویدادی هستش که با همزمان با تغییر یه محل ذخیره‌سازی تو یه context صفحه دیگه‌ای فراخوانی می‌شه. این امکان بهمون قابلیت پردازش تغییرات مقادیر ذخیره‌سازی شده توسط یه EventHandler رو میده. ساختار کد اون یه چیزی مث کد زیر میشه:

     <span dir="ltr" align="left">

    ```js
    window.onstorage = functionRef;
    ```

     </span>

    برای مثال استفاده از رویداد onstorage رو ببینیم که کلید ذخیره و مقادیر اونو ثبت میکنه:

     <span dir="ltr" align="left">

    ```js
    window.onstorage = function (e) {
      console.log(
        `The ${e.key} key has been changed from ${e.oldValue} to ${e.newValue}.`
      );
    };
    ```

     </span>

    **[فهرست](#فهرست)**

46. ### چرا به web-storage نیاز داریم؟

    با استفاده از این قابلیت میشه گفت که فضای ذخیره‌سازی وب از امنیت بیشتری برخورداره و مقدار زیادی داده می‌تونن به صورت محلی ذخیره بشن، بدون اینکه روی عملکرد وب سایت تأثیر بذارن. همچنین، اطلاعات هرگز به سرور منتقل نمیشن و به همین دلیل این روش نسبت به کوکی‌ها بیشتر توصیه می‌شه.

    **[فهرست](#فهرست)**

47. ### چطوری می‌تونیم پشتیبانی از web-storage توسط مرورگر رو بررسی کنیم؟

    قبل از استفاده از فضای ذخیره‌سازی وب، می‌تونیم پشتیبانی مرورگر رو برای localStorage و sessionStorage بررسی کنیم. البته مرورگرهای مدرن امروزی کاملا پشتیبانی web-storage رو ارائه میدن.

     <span dir="ltr" align="left">

    ```js
    if (typeof Storage !== "undefined") {
      // Code for localStorage/sessionStorage.
    } else {
      // Sorry! No Web Storage support..
    }
    ```

     </span>

    **[فهرست](#فهرست)**

48. ### چطوری می‌تونیم پشتیبانی از web-worker توسط مرورگر رو بررسی کنیم؟

    می‌تونیم برای داشتن یه کد cross-functional قبل از استفاده از وب ورکرها، پشتیبانی مرورگر رو بررسی کنیم، انجام این کار هم ساده اس و با یه شرط ساده محقق میشه:

     <span dir="ltr" align="left">

    ```js
    if (typeof Worker !== "undefined") {
      // code for Web worker support.
    } else {
      // Sorry! No Web Worker support..
    }
    ```

     </span>

    **[فهرست](#فهرست)**

49. ### یه مثال از web-workerها می‌تونی بزنی؟

    یه مثال ساده برای شروع استفاده از web worker‌ها میتونه مثال شمارنده باشه که برای اجرای اون باید مراحل زیر رو دنبال کنیم:

     <br />

    1. **ساخت یه فایل Web Worker**: برای افزایش مقدار شمارشی، باید یه اسکریپت بنویسیم که این کار رو انجام میده. بیاین اسمشو counter.js بذاریم

     <span dir="ltr" align="left">

    ```js
    let i = 0;

    function timedCount() {
      i += 1;
      postMessage(i);
      setTimeout("timedCount()", 500);
    }

    timedCount();
    ```

     </span>

    اینجا از روش postMessage برای ارسال پیام به صفحه HTML استفاده می‌شه.

     <br />

    2. **ایجاد شی Web Worker**: با بررسی پشتیبانی مرورگر می‌تونیم یه شی Web Worker ایجاد کنیم. بیاین اسم این فایل رو web_worker_example.js بذاریم.

     <span dir="ltr" align="left">

    ```js
    if (typeof w === "undefined") {
      w = new Worker("counter.js");
    }
    ```

     </span>

    روی همین شئ ما می‌تونیم پیام‌ها رو از web worker دریافت کنیم:

     <span dir="ltr" align="left">

    ```js
    w.onmessage = function (event) {
      document.getElementById("message").innerHTML = event.data;
    };
    ```

     </span>
     <br />

    3. **پایان دادن به web Worker**: ‌می‌دونیم که Web Workerها تا زمان خاتمه یافتن پیام‌ها(حتی بعد از اتمام یه اسکریپت خارجی) به گوش دادن ادامه میدن. برای قطع کردن گوش دادن به پیام‌ها می‌تونیم از دستور terminate استفاده کنیم.

     <span dir="ltr" align="left">

    ```js
    w.terminate();
    ```

     </span>
     <br />

    4. **استفاده مجدد از web worker**: اگه متغیر worker رو undefined مقداردهی کنیم، می‌تونیم از کد نوشته شده مجددا استفاده کنیم.

     <span dir="ltr" align="left">

    ```js
    w = undefined;
    ```

     </span>

    **[فهرست](#فهرست)**

50. ### محدودیت‌های web-workerها روی DOM چیا هستن؟

    WebWorker‌ها به اشیا جاواسکریپت دسترسی ندارن چون توی یه فایل خارجی تعریف شدن. پس به این آبجکت‌ها دسترسی نداریم:

    1. آبجکت Window
    2. آبجکت Document
    3. آبجکت Parent

    **[فهرست](#فهرست)**

51. ### Promise چیه؟

    یه Promise آبجکت‌ای‌ـه که یه ممکنه یه callback برای موفق بودن یا رو با یه callback موفق نبودن(مثلاً خطای شبکه) فرآیند تولید کنه. پس کلا حالت‌های ممکن برای یه Promise یکی از این سه حالت خواهد بود: انجام شده، رد شده، یا در انتظار.

    برای ساختن Promise‌ها از سینتکس زیر استفاده می‌شه

     <span dir="ltr" align="left">

    ```js
    const promise = new Promise((resolve, reject) => {
      // promise description
    });
    ```

     </span>

    استفاده از Promiseها رو هم باهم ببینیم

     <span dir="ltr" align="left">

    ```js
    const promise = new Promise(
      (resolve) => {
        setTimeout(() => {
          resolve("I'm a Promise!");
        }, 5000);
      },
      (reject) => {
        // if we want to rejest, we can call `reject()` cb method
      }
    );

    /**
     * We can call promise and add some success callback functionality to run after resolve
     */
    promise.then((value) => console.log(value)); // here after 5s we will have a log in our console
    ```

     </span>

    چرخه فرآیند یه Promise به این شکل انجام میشه:

    ![Screenshot](images/promises.png)

    **[فهرست](#فهرست)**

    <br />
    <br />

52. ### چرا به Promise نیاز داریم؟

    Promiseها برای رسیدگی به عملیات ناهمزمان(async) استفاده می‌شن. اونا با جلوگیری از وقوع callback hell و نوشتن کد clean و تر و تمیزتر ، یه رویکرد جایگزین برای callbackها ارائه می‌کنن.

    **[فهرست](#فهرست)**

53. ### سه تا وضعیت ممکن برای یه Promise چیا هستن؟

    Promiseها سه حالت دارن:

    <br />

    1. **Pending:** این حالت اولیه Promise قبل از شروع عملیاته
    2. **Fulfilled:** این حالت نشون میده که عملیات مشخص شده تکمیل شده.
    3. **Rejected:** این حالت نشون میده که عملیات کامل نشده. تو این حالت یه مقدار خطا داده خواهد شد.

    **[فهرست](#فهرست)**

54. ### توابع callback چی هستن؟

    تابع callback تابعیه که به عنوان آرگومان به تابع دیگری منتقل می‌شه. این تابع در داخل تابع خارجی برای تکمیل یه عملیات فراخوانی می‌شه.
    بیاین یه مثال ساده از نحوه استفاده از تابع callback ببینیم:

     <span dir="ltr" align="left">

    ```js
    function callbackFunction(name) {
      console.log(`Hello ${name}`);
    }

    function outerFunction(callback) {
      const name = prompt("Please enter your name.");
      callback(name);
    }

    outerFunction(callbackFunction);
    ```

     </span>

    **[فهرست](#فهرست)**

55. ### چرا به توابع callback نیاز داریم؟

    چون جاواسکریپت یه زبان ایونت محوره به callback‌ها نیاز داریم. این به این معنیه که جاواسکریپت به جای منتظر موندن برای جواب یه عملیات فراخوانی شده، در حین گوش دادن به ایونت‌های دیگه به اجرا شدن ادامه میده.

    بیاین یه مثال از دو تا تابع که پشت سرهم اجرا میشن ولی یکی‌شون callback میزنه به یه API (شبیه‌سازی شده با setTimeout) و اون یکی یه لاگ کنسول ساده می‌ندازه رو ببینیم:.

     <span dir="ltr" align="left">

    ```js
    function firstFunction() {
      // Simulate a code delay
      setTimeout(() => {
        console.log("First function called");
      }, 1000);
    }

    function secondFunction() {
      console.log("Second function called");
    }

    firstFunction();
    secondFunction();

    // Output :
    // Second function called
    // First function called
    ```

     </span>

    همونطور که از خروجی می‌شه فهمید، جاواسکریپت منتظر جواب تابع اول نمونده و بلوک کد باقی مونده رو اجرا کرده. بنابراین از callback‌ها می‌تونیم به شکلی استفاده کنیم که مطمئن شیم یه کد تا زمانی که اجرای کد دیگه تموم نشده، اجرا نمی‌شه.

    **[فهرست](#فهرست)**

56. ### Callback hell یا جهنم توابع callback چیه؟

    Callback Hell اصطلاحا یه آنتی‌پترن‌ـه که با چندین callback تودرتو ایجاد میشه، همیشه هم خوندن کد و رفع خطاها رو سخت‌تر میکنه، مخصوصا زمان‌هایی که با async کار می‌کنیم. یه جهنم callback با یه کد مثل کد پایین ایجاد میشه:

     <span dir="ltr" align="left">

    ```js
    async1(() => {
      async2(() => {
        async3(() => {
          async4(() => {
            // ....
          });
        });
      });
    });
    ```

     </span>

    **[فهرست](#فهرست)**

57. ### Server-sent-events یا همون SSE چیه؟

    event‌های ارسال شده توسط سرور (SSE) یه فناوری server pushـه که به مرورگر این امکان رو میده که به‌روزرسانی‌های خودکار رو از طریق درخواست HTTP و بدون استفاده از polling(درخواست‌های پیوسته و منظم) دریافت کنه. این روش، یه کانال ارتباطی یه طرفه‌ـست و event‌ها فقط از سرور به client ارسال میشن. این روزا از قابلیت‌های SSE روی به‌روزرسانی‌های فیس‌بوک/تویتر، به‌روزرسانی قیمت سهام، فیدهای خبری و غیره استفاده میشه.

    **[فهرست](#فهرست)**

58. ### چطوری می‌تونیم پیام‌های server-sent-event رو دریافت کنیم؟

    کلاس EventSource برای دریافت پیام‌های event ارسال شده از سرور استفاده می‌شه. برای مثال، می‌تونیم پیام‌هایی که میخوایین رو از سرور مثل مثال زیر بگیرین.

     <span dir="ltr" align="left">

    ```js
    if (typeof EventSource !== "undefined") {
      const source = new EventSource("sse_generator.js");
      source.onmessage = function (event) {
        document.getElementById("output").innerHTML += `${event.data}<br>`;
      };
    }
    ```

     </span>

    **[فهرست](#فهرست)**

59. ### چطوری می‌تونیم پشتیبانی مرورگر برای SSE رو بررسی کنیم؟

    می‌تونیم قبل از استفاده از SSE مانند زیر، پشتیبانی مرورگر رو با یه شرط شبیه کد زیر بررسی کنیم:

     <span dir="ltr" align="left">

    ```js
    if (typeof EventSource !== "undefined") {
      // Server-sent events supported. Let's have some code here!
    } else {
      // No server-sent events supported
    }
    ```

     </span>

    **[فهرست](#فهرست)**

60. ### کدوم توابع روی SSE وجود دارن؟

    این پایین یه لیست از eventهای موجود برای SSE رو ذکر می‌کنیم:

    | ایونت     | توضیحات                                          |
    | --------- | ------------------------------------------------ |
    | onopen    | موقعی که اتصال به سرور باز می‌شه استفاده می‌شه   |
    | onmessage | این event زمانی استفاده می‌شه که پیامی دریافت شه |
    | onerror   | زمانی اتفاق میوفته که خطایی رخ بده               |

    **[فهرست](#فهرست)**

61. ### اصلی‌ترین قوانین Promiseها چیا هستن؟

    میشه گفت اصلی‌ترین قانون‌های Promise‌ها ایناست:

    1. Promise آبجکت‌ای‌ـه که متد «.then» رو برای منتظر پاسخ درخواست موندن ارائه میکنه.
    2. یه Promise معلق ممکنه به حالت تحقق یافته یا رد شده تبدیل بشه.
    3. Promise تمام شده یا رد شده حل و فصل می‌شه و نباید به حالت دیگری تبدیل شه.
    4. پس از اتمام Promise مقدار اون نباید تغییر کنه.

    **[فهرست](#فهرست)**

62. ### Callback توی callback چطوری رخ میده؟

    می‌تونیم یه پاسخ api-call رو داخل یه api-call دیگر قرار بدین تا عملیات‌ها رو به شکل متوالی و یکی یکی انجام بدین. این به عنوان callback در callbacks شناخته می‌شه.

    <span dir="ltr" align="left">

    ```js
    loadScript('/script1.js', function(script) {
       console.log('first script is loaded');

       loadScript('/script2.js', function(script) {
          console.log('second script is loaded');

          loadScript("/script2.js", function (script) {
            console.log("second script is loaded");

            loadScript("/script3.js", function (script) {
              console.log("third script is loaded");
              // after all scripts are loaded
            });
         });
    });
    ```

     </span>

    **[فهرست](#فهرست)**

63. ### زنجیره Promiseها چیه؟

    فرآیند اجرای دنباله‌ای از عملیا‌ت‌های ناهمزمان(async) به طوریکه هر کدوم بعد از تموم شدن قبلی اجرا بشن با استفاده از Promise‌ها به عنوان Promise chaining شناخته می‌شه. بیاین برای محاسبه نتیجه نهایی یه مقدار، یه مثال از زنجیره Promiseها رو ببینیم:

     <span dir="ltr" align="left">

    ```js
    new Promise((resolve, reject) => {
      setTimeout(() => resolve(1), 1000);
    })
      .then((result) => {
        console.log(result); // 1
        return result * 2;
      })
      .then((result) => {
        console.log(result); // 2
        return result * 3;
      })
      .then((result) => {
        console.log(result); // 6
        return result * 4;
      });
    ```

     </span>

    توی بلوک‌های کد بالا، نتیجه هر Promise به زنجیره‌های then بعدی منتقل می‌شه، فرآیندشون به شکل زیر انجام میشه:

    1. Promise اول توی 1 ثانیه حل می‌شه،
    2. پس از اون then با چاپ مقدار `1` توی کنسول، فراخوانی می‌شه و یه Promise با مقدار result ضربدر 2 برمی‌گردونه.
    3. پس از اون result به callback بعدی منتقل شده و با چاپ مقدار `2` و برگردوندن یه Promise با result ضربدر 3.
    4. در نهایت مقدار به آخرین callback رسیده و با چاپ مقدار `6` توی کنسول، یه Promise با result ضربدر 4 برمی‌گردونه`.

    5. Promise اول توی 1 ثانیه حل می‌شه،
    6. پس از اون «.then» با ثبت نتیجه (1) فراخوانی می‌شه و سپس یه Promise با مقدار نتیجه \* 2 برمی‌گردونه.
    7. پس از اون مقدار به بعدی منتقل شد. سپس با ثبت نتیجه (2) و برگردوندن یه Promise با نتیجه \*3.
    8. در نهایت مقدار به آخرین . سپس با ثبت نتیجه (6) و یه Promise با نتیجه \* 4، handler`.

    **[فهرست](#فهرست)**

64. ### کاربرد متد promise.all چیه؟

    Promise.all یه Promiseـه که آرایه‌ای از Promise‌ها رو به عنوان ورودی می‌گیره(یک تکرار) و زمانی resolve می‌شه که همه Promise‌ها resolve بشن، و اگه یکی از اونها رد شه reject میشه. برای مثال، تیکه کد زیر رو ببینیم:

     <span dir="ltr" align="left">

    ```js
    Promise.all([Promise1, Promise2, Promise3])
      .then((result) => {
        console.log(result);
      })
      .catch((error) => {
        console.log(`Error in promises ${error}`);
      });
    ```

     </span>

    **نکته:** ترتیب خروجی Promise‌ها طبق همون ترتیب آرایه ورودی ایجاد میشه.

    **[فهرست](#فهرست)**

65. ### هدف از متد race روی Promise چیه؟

    متد Promise.race یه آرایه از Promiseها رو می‌گیره و نتیجه اولین Promiseای resolve یا reject شده رو برمی‌گردونه. بیاین مثالی از متد race رو در نظر بگیریم که تو اون Promise2 اول resolve می‌شه:

     <span dir="ltr" align="left">

    ```js
    const promise1 = new Promise((resolve, reject) => {
      setTimeout(resolve, 500, "one");
    });
    const promise2 = new Promise((resolve, reject) => {
      setTimeout(resolve, 100, "two");
    });

    Promise.race([promise1, promise2]).then((value) => {
      console.log(value); // "two" // Both promises will resolve, but promise2 is faster
    });
    ```

     </span>

    **[فهرست](#فهرست)**

66. ### حالت strict توی جاواسکریپت چی کار میکنه؟

    Strict Mode یکی از قابلیت‌های ارائه شده توی ES5 هست که به ما این امکان رو میده که یه برنامه یا یه تابع رو تو یه حالت اجرایی "سخت‌تر" قرار بدیم. به این ترتیب از انجام بعضی اقدامات جلوگیری میکنه و استثنا(Exception)های بیشتری رو ایجاد میکنه. عبارت تحت اللفظی "usestrict" به مرورگر دستور میده تا از کد جاواسکریپت در حالت Strict استفاده کنه.

    **[فهرست](#فهرست)**

67. ### چرا به حالت strict نیاز داریم؟

    حالت سخت گیرانه(strict mode) برای نوشتن جاواسکریپت "امن" و حصول اطمینان از اطلاع از "syntax بد" برای جلوگیری از خطاهای واقعی استفاده میشه. برای مثال، ایجاد تصادفی یه متغیر گلوبال رو با ایجاد یه Exception حذف میکنه و یا یه خطا برای انتساب به یه ویژگی غیرقابل نوشتن، یه ویژگی فقط گیرنده، یه ویژگی غیرموجود، یه متغیر غیرموجود یا یه ویژگی غیر قابل نوشتن ایجاد میکنه.

    **[فهرست](#فهرست)**

68. ### چطوری می‌تونیم حالت strict رو فعال کنیم؟

    حالت سخت با اضافه کردن رشته `use strict` به ابتدای scope اعلام می‌شه. پس می‌تونیم اونو به ابتدای یه اسکریپت یا یه تابع اضافه کنیم.
    اگه در ابتدای یه اسکریپت اعلام شه، دامنه عمومی داره:

     <span dir="ltr" align="left">

    ```js
    "use strict";

    x = 3.14; // This will cause an error because x is not declared
    ```

     </span>

    و اگه در داخل یه تابع اعلام کنیم محدوده محلی داره:

     <span dir="ltr" align="left">

    ```js
    x = 3.14; // This will not cause an error.
    myFunction();

    function myFunction() {
      "use strict";

      y = 3.14; // This will cause an error
    }
    ```

     </span>

    **[فهرست](#فهرست)**

69. ### هدف از عملگر نقیض دوتایی(!!) چیه؟

    علامت نقیض دوتایی یا نفی (!!) اینه که تضمین میکنه که نوع حاصل از عملیات یه مقدار true یا falseـه و تایپش بولین‌ـه. اگه falsy بود (برای مثال 0، null، undifiend و غیره)، false میشه و در غیر این صورت، درسته و نتیجه true خواهد بود.
    برای مثال، می‌تونیم نسخه IE رو با استفاده از عبارت زیر آزمایش کنیم.

     <span dir="ltr" align="left">

    ```js
    let isIE8 = false;
    isIE8 = !!navigator.userAgent.match(/MSIE 8.0/);
    console.log(isIE8); // returns true or false
    ```

     </span>

    اگه از این عبارت استفاده نکنیم مقدار اصلی رو برمی‌گردونه.

     <span dir="ltr" align="left">

    ```js
    console.log(navigator.userAgent.match(/MSIE 8.0/)); // returns either an Array or null
    ```

     </span>

    **نکته:** `!!` یه اپراتور جدید نیست و فقط دوتا اپراتور `!` هست.
    **نکته:** استفاده از `!!` معادل استفاده از `Boolean(var)` هست ولی `!!` سریعتره.

    **[فهرست](#فهرست)**

70. ### هدف از عملگر delete چیه؟

    کلمه کلیدی delete برای حذف ویژگی و همچنین مقدار اون استفاده می‌شه.

     <span dir="ltr" align="left">

    ```js
    const user = { name: "John", age: 20 };
    delete user.age;

    console.log(user); // {name: "John"}
    ```

     </span>

    **[فهرست](#فهرست)**

71. ### عملگر typeof چیکار میکنه؟

    برای بدست آوردن نوع متغیر جاواسکریپت می‌تونیم از عملگر typeof استفاده کنیم و نوع یه متغیر یا یه عبارت رو به صورت یه رشته برمی‌گردونه.

     <span dir="ltr" align="left">

    ```js
    typeof "John Abraham"; // Returns "string"
    typeof (1 + 2); // Returns "number"
    ```

     </span>

    **[فهرست](#فهرست)**

72. ### undefined چیه و چه زمانی undefined می‌گیریم؟

    ویژگی undefined می‌گیریم که به یه متغیر مقداری اختصاص داده نشده یا اصلاً تعریف نشده‌ـست. هم نوع مقدار تعریف نشده هم تعریف نشده.

     <span dir="ltr" align="left">

    ```js
    let user; // Value is undefined, type is undefined
    console.log(typeof user); // undefined
    ```

     </span>

    هر متغیری رو می‌شه با تنظیم مقدار روی undefined خالی کرد.

     <span dir="ltr" align="left">

    ```js
    user = undefined;
    ```

     </span>

    **[فهرست](#فهرست)**

73. ### null چیه؟

    مقدار null عدم وجود عمدی هر مقدار شی رو نشون میده. null یکی از مقادیر اولیه جاواسکریپت‌ـه و حواسمون باید باشه که نوع مقدار null آبجکته.
    با قرار دادن مقدار null هم می‌تونیم متغیر رو خالی کنیم.

     <span dir="ltr" align="left">

    ```js
    const user = null;
    console.log(typeof user); // object
    ```

     </span>

    **[فهرست](#فهرست)**

74. ### تفاوت‌های بین null و undefined چیا هستن؟

    تفاوت‌های اصلی بین null و undefined:

    | Null                                                                     | Undefined                                                                                           |
    | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------- |
    | یه مقدار انتسابه که نشون میده متغیر به هیچ شیئی اشاره نمیکنه.            | یه مقدار انتساب نیست که تو اون متغیری اعلام شده باشه اما هنوز مقداری به اون اختصاص داده نشده.       |
    | تایپ null آبجکته                                                         | تایپ undefined همون تعریف نشده و undefined هستش                                                     |
    | مقدار null یه مقدار اولیه اس که نشون دهنده مرجع تهی، خالی یا غیر موجوده. | مقدار undefined یه مقدار اولیه اس و زمانی استفاده میشه که به یه متغیر مقداری اختصاص داده نشده باشه. |
    | عدم وجود مقدار برای یه متغیر رو نشون میده                                | عدم وجود خود متغیر رو نشون میده                                                                     |
    | در حین انجام عملیات اولیه به صفر (0) تبدیل میشه                          | در حین انجام عملیات اولیه به NaN تبدیل می‌شه                                                        |

    **[فهرست](#فهرست)**

75. ### متد eval چیه؟

    تابع eval کد جاواسکریپت‌ای رو که به صورت رشته بهش پاس داده شده رو اجرا میکنه. رشته میتونه یه عبارت جاواسکریپت، متغیر، دستور یا دنباله ای از عبارات باشه.

     <span dir="ltr" align="left">

    ```js
    console.log(eval("1 + 2")); //  3
    ```

     </span>

    **[فهرست](#فهرست)**

76. ### تفاوت‌های بین window و document چیا هستن؟

    | Window                                                                   | Document                                                                               |
    | ------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- | ------------ |
    | عنصر ریشه در هر صفحه وبه                                                 | فرزند مستقیم شی window هستش و همچنین به عنوان مدل شیء document (DOM)                   | شناخته می‌شه |
    | به طور پیش فرض شی window به طور ضمنی در هر صفحه قرار داره                | می‌تونیم از طریق window.document یا document به اون دسترسی داشته باشیم.                |
    | دارای متدهایی مانند alert، confirm و ویژگی‌هایی مانند document، location | متدهایی مانند getElementById، getElementByTagName، createElement و غیره رو فراهم میکنه |

    **[فهرست](#فهرست)**

77. ### توی جاواسکریپت چطوری می‌تونیم به history دسترسی داشته باشیم؟

    شی window.history حاوی تاریخچه مرورگره. با استفاده از متدهای `back` و `next` می‌تونیم URL‌های قبلی و بعدی رو در تاریخچه بارگذاری کنیم. مثلا:

     <br />
     <span dir="ltr" align="left">

    ```js
    function goBack() {
      window.history.back();
    }
    function goForward() {
      window.history.forward();
    }
    ```

     </span>
     <br />

    **نکته:** همچنین می‌تونیم بدون پیشوند window به آبجکت history دسترسی داشته باشیم.

    **[فهرست](#فهرست)**

78. ### انواع داده‌های جاواسکریپت کدوما هستن؟

    1. Number
    2. String
    3. Boolean
    4. Object
    5. Undefined

    **[فهرست](#فهرست)**

79. ### isNaN چیه و چیکار میکنه؟

    تابع `isNaN`(Not-a-Number) برای تعیین اینه که آیا یه مقدار یه عدد واقعیه یا نه هست یا نه استفاده می‌شه. یعنی اگه مقدار برابر با NaN باشه، این تابع true برمی‌گردونه. در غیر این صورت false برمیگرده.

     <span dir="ltr" align="left">

    ```js
    isNaN("Hello"); // true

    isNaN("100"); // false
    ```

     </span>
     <br />

    **[فهرست](#فهرست)**

80. ### تفاوت‌های بین undeclared و undefined چیا هستن؟

    | undeclared                                                                       | undefined                                                                              |
    | -------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ---------------- |
    | این متغیرها تو یه برنامه وجود ندارن و تعریف نشدن                                 | این متغیرها در برنامه هست، اما هیچ مقداری نداره                                        | اختصاص نداده اند |
    | اگه سعی کنیم مقدار یه متغیر undeclared رو بخونیم، با خطای زمان اجرا مواجه می‌شیم | اگه سعی کنیم مقدار یه متغیر تعریف نشده رو بخونیم، یه مقدار تعریف نشده برگردونده می‌شه. |

    **[فهرست](#فهرست)**

81. ### کدوم متغیرها عمومی هستن؟

    متغیرهای عمومی اونایی ان که در طول کد بدون هیچ محدوده ای در دسترسن. کلمه کلیدی var برای اعلام یه متغیر محلی استفاده می‌شه اما اگه اونو حذف کنیم تبدیل به متغیر عمومی می‌شه.

     <span dir="ltr" align="left">

    ```js
    msg = "Hello"; // var is missing, it becomes global variable
    ```

     </span>

    **[فهرست](#فهرست)**

82. ### مشکلات متغیرهای عمومی چیا هستن؟

    مشکل متغیرهای سراسری تضاد نام متغیرها با دامنه محلی و گلوباله. دیباگ و آزمایش کدی که به متغیرهای سراسری متکیه سخته.

    **[فهرست](#فهرست)**

83. ### مقدار NaN چیه؟

    ویژگی NaN یه ویژگی گلوباله که مقدار "Not-a-Number" رو نشون میده. یعنی نشون میده که یه مقدار یه متغیر واقعا عددی نیست. استفاده از NaN تو برنامه‌ها خیلی نداره، اما می‌شه از اون به عنوان مقدار بازگشتی یه سری توابع و برای یه سری موارد کم استفاده کرد:

     <span dir="ltr" align="left">

    ```js
    Math.sqrt(-1);
    parseInt("Hello");
    ```

     </span>

    **[فهرست](#فهرست)**

84. ### هدف از تابع isFinite چیه؟

    تابع`isFinite`برای تعیین اینکه آیا یه عدد یه عدد محدود و قانونیه استفاده می‌شه. اگه مقدار +infinity، -infinity یا NaN (Not-a-Number) باشه false برمی‌گردونه، در غیر این صورت true رو برمی‌گردونه.

     <span dir="ltr" align="left">

    ```js
    isFinite(Infinity); // false
    isFinite(NaN); // false
    isFinite(-Infinity); // false

    isFinite(100); // true
    ```

     </span>

    **[فهرست](#فهرست)**

85. ### یه event-flow چیه؟

    `event-flow` ترتیبیه که `event` در صفحه وب دریافت می‌شه. وقتی روی یه المنت در صفحه وب کلیک می‌کنیم و این المنت به شکل تودرتو داخل المنت‌های مختلف استفاده شده، قبل از اینکه کلیک‌مون واقعاً به مقصد یا المنت هدف برسه، باید `event` کلیک رو برای هر کدوم از عنصرهای والد خودش بفرسته و از بالا با شی پنجره گلوبال شروع شه.

    به شکل کلی **دو** راه برای جریان event وجود داره:

    1. **از بالا به پایین(Event Capturing)**
    2. **از پایین به بالا (Event Capturing)**

    3. از بالا به پایین(Event Capturing)
    4. از پایین به بالا (Event Capturing)

    **[فهرست](#فهرست)**

86. ### Event-bubbling چیه؟

    `Event-bubbling` نوعی انتشار event‌ـه که تو اون event ابتدا روی درونی‌ترین عنصر هدف فراخوانی می‌شه و سپس به‌طور متوالی روی اجداد (والد) عنصر هدف تو همون سلسله مراتب تودرتو راه‌اندازی می‌شه تا زمانی که به بیرونی‌ترین عنصر DOM برسه.

    **[فهرست](#فهرست)**

87. ### Event-capturing چیه؟

    Event-capturing نوعی انتشار event‌ـه که تو اونevent اول با بیرونی ترین عنصر ثبت می‌شه و سپس به طور متوالی بر روی children (children) عنصر هدف تو همون سلسله مراتب تودرتو راه اندازی می‌شه تا زمانی که به درونی ترین عنصر DOM برسه.

    **[فهرست](#فهرست)**

88. ### چطوری می‌شه یه فرم رو با استفاده از جاواسکریپت ثبت کرد؟

    می‌تونیم با استفاده از جاواسکریپت فرم مورد نظرمون رو با استفاده از کد document.form[0].submit ارسال کنیم. تمام اطلاعات ورودی فرم با استفاده از onsubmit event handler ارسال می‌شه

     <span dir="ltr" align="left">

    ```js
    function submit() {
      document.form[0].submit();
    }
    ```

     </span>

    **[فهرست](#فهرست)**

89. ### چطوری می‌شه به اطلاعات مربوط به سیستم عامل کاربر دسترسی داشت؟

    شی window.navigator حاوی اطلاعاتی درباره جزئیات سیستم عامل مرورگر بازدیدکننده‌ـست. بعضی از ویژگی‌های سیستم عامل روی ویژگی پلتفرم در دسترس هستن:

     <span dir="ltr" align="left">

    ```js
    console.log(navigator.platform);
    ```

     </span>

    **[فهرست](#فهرست)**

90. ### تفاوت‌های بین رخدادهای document-load و DOMContentLoaded چیا هستن؟

    رویداد `DOMContentLoaded` زمانی فراخوانی می‌شه که سند اولیه HTML به‌طور کامل بارگیری و تجزیه شده باشه، بدون اینکه منتظر بمونیم تا بارگیری asset‌ها(استایل‌ها، تصاویر و فریم‌های فرعی) تموم شه. در حالی که رویداد load روی داکیومنت زمانی فراخوانی می‌شه که کل صفحه بارگیری شه، شامل همه استایل‌ها، تصاویر و ... .

    **[فهرست](#فهرست)**

91. ### تفاوت‌های بین objectهای native ، host و user چیا هستن؟

    `Native object`ها آبجکت‌هایی هستن که به عنوان بخشی از زبان جاواسکریپت تعریف شدن و به عنوان بخشی از مشخصات ECMAScript هستن. برای مثال، اشیاء اصلی رشته، ریاضی، RegExp، Object، Function و غیره که در مشخصات `ECMAScript` تعریف شدن.
    `Host objects` آبجکت‌هایی هستن که توسط مرورگر یا محیط زمان اجرا (Node) ارائه می‌شن. برای مثال، پنجره، `XmlHttpRequest` نودهای DOM و غیره به عنوان اشیاء میزبان در نظر گرفته میشن.
    `User objects` آبجکت‌هایی هستن که تو کد جاواسکریپت تعریف شدن. برای مثال، آبجکت‌های ایجاد شده توسط برای اطلاعات پروفایل.

    **[فهرست](#فهرست)**

92. ### کدوم ابزار و تکنیک‌ها برای دیباگ کردن برنامه جاواسکریپتی استفاده میشن؟

    1. Chrome Devtools
    2. عبارت debugger
    3. متد console.log

    **[فهرست](#فهرست)**

93. ### مزایا و معایب استفاده از Promiseها به جای callback چیا هستن؟

    **مزایا:**

    **مزایا:**

    1. از جهنم callback که قابل خواندن نیست جلوگیری میکنه.
    2. نوشتن کدهای ناهمزمان متوالی با then آسون‌تره.
    3. نوشتن کد ناهمزمان موازی با Promise.all آسون‌تره.
    4. بعضی از مشکلات رایج callbackهای بازگشتی رو حل میکنه (مشکل فراخوانی بسیار دیر، خیلی زود، یا چندبار فراخوانی callback و استثناها رو مدیریتیش رو راحت‌تر میکنه).

    **معایب:**

    1. کد یه کمی پیچیده میشه.
    2. اگه ES6 پشتیبانی نشد باید یه polyfill بارگذاری بشه.

    3. کد کمی پیچیده می سازد
    4. اگه ES6 پشتیبانی نمی‌شه، باید یه polyfill بارگذاری کنیم

    **[فهرست](#فهرست)**

94. ### تفاوت‌های بین attribute و property روی DOM چیا هستن؟

    Attributeها برای نشونه گذاری HTML تعریف می‌شن در حالی که propertyها روی DOM تعریف میشن برای مثال، عنصر HTML زیر دارای 2 ویژگی نوع و مقدار هستش

     <span dir="ltr" align="left">

    ```js
    <input type="text" value="Name:">
    ```

     </span>

    می‌تونیم مقدار یه ویژگی رو به صورت زیر بدست بیاریم:

     <span dir="ltr" align="left">

    ```js
    const input = document.querySelector("input");
    console.log(input.getAttribute("value")); // Good morning
    console.log(input.value); // Good morning
    ```

     </span>

    و بعد از اینکه مقدار فیلد متن به "Good evening" تغییر داده شد، نتیجه مثل زیر می‌شه:

     <span dir="ltr" align="left">

    ```js
    console.log(input.getAttribute("value")); // Good morning
    console.log(input.value); // Good evening
    ```

     </span>

    **[فهرست](#فهرست)**

95. ### سیاست same-origin چیه؟

    سیاست یا خط مشی `same-origin` خط مشیه که از درخواست جاواسکریپت در روی کل domain جلوگیری میکنه. مبدا به عنوان ترکیبی از شمای URI، نام میزبان(hostname) و شماره پورت(port) تعریف می‌شه. اگه این خط‌مشی رو فعال کنیم، مرورگر از دسترسی یه اسکریپت مخرب تو یه صفحه به داده‌های حساس توی صفحه وب دیگه با استفاده از DOM(Document Object Model) جلوگیری میکنه.

    **[فهرست](#فهرست)**

96. ### هدف استفاده از void 0 چیه؟

    Void(0) برای جلوگیری از به ‌روز‌رسانی صفحه استفاده می‌شه. این متد برای از بین بردن ساید افکت‌های ناخواسته مفیده، چون مقدار اولیه تعریف نشده رو برمی‌گردونه. معمولاً برای اسناد HTML استفاده می‌شه که از href="JavaScript:Void(0)" روی تو یه عنصر `<a>` استفاده می‌کنن. یعنی وقتی روی یه لینک کلیک می‌کنیم مرورگر یه صفحه جدید رو بارگیری میکنه یا همون صفحه رو تازه‌سازی(reload) میکنه. ولی با استفاده از این عبارت می‌تونیم از این رفتار جلوگیری کنیم.
    :برای مثال، لینک زیر پیام رو بدون بارگیری مجدد صفحه مطلع میکنه

     <span dir="ltr" align="left">

    ```html
    <a href="JavaScript:void(0);" onclick="alert('Well done!')">Click Me!</a>
    ```

     </span>

    **[فهرست](#فهرست)**

97. ### جاواسکریپت یه زبان تفسیری هست یا کامپایلری؟

    جاواسکریپت یه زبان تفسیری‌ـه و نه یه زبان کامپایلری. یه مفسر توی مرورگر کد جاواسکریپت رو می خونه، هر خط رو تفسیر میکنه و اونو اجرا میکنه. امروزه مرورگرهای مدرن از فناوری موسوم به کامپایل Just-In-Time(JIT) استفاده می‌کنن که جاواسکریپت رو موقعی که در شرف اجراست به بایت کد اجرایی کامپایل میکنه.

    **[فهرست](#فهرست)**

98. ### آیا جاواسکریپت یه زبان حساس به بزرگی و کوچکی(case-sensitive) حروف است؟

    بله، جاواسکریپت یه زبان حساس به حروف کوچک و بزرگه. کلمات کلیدی استفاده شده توی زبان، متغیرها، توابع و اشیا، و هر شناسه دیگر باید همیشه با حروف بزرگ تایپ شن.

    **[فهرست](#فهرست)**

99. ### ارتباطی بین Java و JavaScript وجود داره؟

    نه، این دو زبان برنامه نویسی کاملاً متفاوت هستن و هیچ ارتباطی با همدیگه ندارن. اما هر دوی اونا زبان‌های برنامه نویسی شی گرا هستن و مثل خیلی از زبان‌های دیگه، از syntax مشابهی برای ویژگی‌های اساسی (if، else، for، switch، break، continue و غیره) پیروی می‌کنن.

    **[فهرست](#فهرست)**

100. ### Eventها چی هستن؟

     رویدادها «چیزهایی» هستن که روی عناصر HTML و برای اونا اتفاق می‌افتن. موقعی که جاواسکریپت توی صفحات HTML استفاده می‌شه، میتونه به این رویدادها واکنش نشون بده و ما با استفاده از این رخدادها می‌تونیم رفتار خاصی رو موقع رخداد خاص تعریف کنیم. بعضی از نمونه‌های رویدادهای HTML عبارتند از:

     1. بارگذاری صفحه وب تموم شه
     2. فیلد ورودی تغییر کنه
     3. روی یه دکمه کلیک شه

     بیاین رفتار رویداد کلیک رو برای یه button ببینیم:

      <span dir="ltr" align="left">

     ```html
     <!DOCTYPE html>
     <html>
       <head>
         <script>
           function greeting() {
             alert("Hello! Good morning");
           }
         </script>
       </head>
       <body>
         <button type="button" onclick="greeting()">Click me</button>
       </body>
     </html>
     ```

      </span>

     **[فهرست](#فهرست)**

101. ### کی جاواسکریپت رو ساخته؟

     جاواسکریپت توسط Brendan Eich تو سال 1995 و موقع فعالیت ایشون توی نت اسکیپ (Netscape Communication) ایجاد شد و با نام `Mocha` توسعه پیدا کرد، اما بعدها زمانی که برای اولین بار در نسخه‌های بتا نت اسکیپ عرضه شد، این زبان به طور رسمی `LiveScript` نامیده شد.

     **[فهرست](#فهرست)**

102. ### هدف از متد preventDefault چیه؟

     متد `preventDefault` اگه رویداد قابل لغو باشه، اونو لغو میکنه، به این معنی که عمل یا رفتار پیش‌فرض متعلق به رویداد اتفاق نمی‌افته. برای مثال، جلوگیری از ارسال فرم موقع کلیک بر روی دکمه ارسال و جلوگیری از باز شدن `URL` صفحه موقع کلیک کردن روی لینک از موارد رایج استفاده‌‌ـشه.

     <span dir="ltr" align="left">

     ```js
     document.getElementById("link").addEventListener("click", (event) => {
       event.preventDefault();
     });
     ```

     </span>

     **نکته:** همه رویدادها قابل لغو نیستن.

     **[فهرست](#فهرست)**

103. ### کاربرد متد stopPropagation چیه؟

     روش `stopPropagation` برای جلوگیری از `event bubbling` توی یه زنجیره از رویدادها استفاده می‌شه. برای مثال، div‌های تودرتو زیر با متد `stopPropagation` از انتشار پیش فرض رویداد موقع کلیک روی Div1 جلوگیری میکنه.

     <span dir="ltr" align="left">

     ```html
     <p>Click DIV1 Element</p>
     <div onclick="secondFunc()">
       DIV 2
       <div onclick="firstFunc(event)">DIV 1</div>
     </div>

     <script>
       function firstFunc(event) {
         alert("DIV 1");
         event.stopPropagation();
       }

       function secondFunc() {
         alert("DIV 2");
       }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

104. ### مراحلی که موقع استفاده از return false توی یه event-handler رخ میده چیا هستن؟

     عبارت `return false` تو `event-handler` مراحل زیر رو انجام میده:

     1. ابتدا عملکرد یا رفتار پیش فرض مرورگر رو متوقف میکنه.
     2. رویداد از انتشار `DOM` جلوگیری میکنه.
     3. اجرای `callback` رو متوقف میکنه و بلافاصله پس از فراخونی بر می‌گرده.

     **[فهرست](#فهرست)**

105. ### BOM چیه؟

     مدل آبجکتی مرورگر (BOM) به جاواسکریپت اجازه میده تا با مرورگر صحبت کنه. این مدل شامل navigation، history، page، location و document که فرزندان window هستن. BOM مدل استاندارد همه مرورگرها نیست و می‌تونه بر اساس مرورگرهای مختلف تغییر کنه.

     ![Screenshot](images/bom.png)

     <br />

     **[فهرست](#فهرست)**

106. ### موارد استفاده از setTimeout کدوما هستن؟

     متد `setTimeout` برای فراخونی یه تابع یا ارزیابی یه عبارت پس از میزان مشخصی از زمان(میلی ثانیه) استفاده می‌شه. برای مثال، بیاین یه پیام رو پس از 2 ثانیه با استفاده از متد `setTimeout` چاپ کنیم:

     <span dir="ltr" align="left">

     ```js
     setTimeout(() => {
       console.log("Good morning");
     }, 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

107. ### موارد استفاده از setInterval کدوما هستن؟

     متد `setInterval` برای فراخوانی یه تابع یا ارزیابی یه عبارت در بازه‌های زمانی مشخص (بر حسب میلی ثانیه) استفاده می‌شه. برای مثال، بیاین یه پیام رو هر 2 ثانیه با استفاده از متد `setInterval` چاپ کنیم:

     <span dir="ltr" align="left">

     ```js
     setInterval(() => {
       console.log("Good morning");
     }, 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

108. ### چرا جاواسکریپت رو به عنوان یه زبان تک thread می‌شناسن؟

     چون مشخصات زبان به برنامه نویس اجازه نمیده تا کدی بنویسه که مفسر بتونه بخش‌هایی از اونو به صورت موازی در چندین Thread یا پردازش اجرا کنه. در حالی که زبان‌هایی مانند java، go، C++ میتونن برنامه‌های چند رشته‌ای و چند فرآیندی بسازن.

     **[فهرست](#فهرست)**

109. ### Event-delegation چیه؟

     `Event-delegation` تکنیکی برای گوش دادن به رویدادهاس که تو اون یه عنصر والد رو به عنوان شنونده برای همه رویدادهایی که در داخلش اتفاق می‌افتن، تفویض می‌کنیم.

     برای مثال، اگه می‌خواین تغییرات فیلد رو تو یه فرم خاص تشخیص بدین، می‌تونیم از تکنیک `Event-delegation` استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     const form = document.querySelector("#registration-form");

     // Listen for changes to fields inside the form
     form.addEventListener(
       "input",
       (event) => {
         // Log the field that was changed
         console.log(event.target);
       },
       false
     );
     ```

     </span>

     **[فهرست](#فهرست)**

110. ### ECMAScript چیه؟

     `ECMAScript` زبان برنامه نویسیه که اساس جاواسکریپت رو تشکیل میده. `ECMAScript` توسط سازمان استانداره بین المللی `ECMA` در مشخصات `ECMA-262` و `ECMA-402` استانداره شده است. اولین نسخه `ECMAScript` در سال 1997 منتشر شد.

     **[فهرست](#فهرست)**

111. ### JSON چیه؟

     `JSON (JavaScript Object Notation)` یه فرمت سبک هستش که برای تبادل داده‌ها استفاده می‌شه. اصول اولیه جیسون بر اساس زیرمجموعه‌ای از زبان جاواسکریپت‌ـه و مشابه آبجکت اشیاییه که توی جاواسکریپت ساخته میشن.

     **[فهرست](#فهرست)**

112. ### قوانین فرمت JSON کدوما هستن؟

     1. داده‌ها به صورت جفت نام/مقدار هستن
     2. داده‌ها با کاما از هم جدا میشن
     3. براکت‌ها اجسام رو نگه می‌دارن
     4. کروشه‌ها آرایه‌ها رو نگه می‌دارن

     **[فهرست](#فهرست)**

113. ### هدف از متد JSON.stringify چیه؟

     موقع ارسال داده‌ها به وب سرور، داده‌ها باید در قالب رشته‌ای باشن. می‌تونیم با استفاده از متد `stringify` آبجکت `JSON` رو به رشته متنی تبدیل کنیم. مثل:

     <span dir="ltr" align="left">

     ```js
     const userJSON = { name: "John", age: 31 };
     const userString = JSON.stringify(user);
     console.log(userString); // "{"name":"John","age":31}"
     ```

     </span>

     **[فهرست](#فهرست)**

114. ### چطوری می‌تونیم یه رشته JSON رو تجزیه کنیم؟

     موقع دریافت داده‌ها از یه وب سرور، داده‌ها همیشه در قالب رشته‌ متنی هستن. اما می‌تونیم این مقدار رشته رو با استفاده از متد `parse` به یه آبجکت جاواسکریپت تبدیل کنیم.

     <span dir="ltr" align="left">

     ```js
     const userString = '{"name":"John","age":31}';
     const userJSON = JSON.parse(userString);
     console.log(userJSON); // {name: "John", age: 31}
     ```

     </span>

     **[فهرست](#فهرست)**

115. ### چرا به JSON نیاز داریم؟

     موقع تبادل داده بین مرورگر و سرور، داده‌ها به دلیل تبادل شدن با استفاده از پروتکل Http فقط میتونن متنی باشن. از اونجایی که `JSON` فقط متنی‌ـه میشه اونو به راحتی به سرور ارسال کرد و از اون به عنوان قالب داده برای هر زبان برنامه‌نویسی استفاده کرد.

     **[فهرست](#فهرست)**

116. ### PWAها چی هستن؟

     `Progressive web applications (PWAs)` نوعی از برنامه‌های تلفن همراه هستن که از طریق وب ارائه میشن، و با استفاده از فناوری‌های رایج وب از جمله `HTML`، `CSS` و جاواسکریپت ساخته میشن. `PWA`‌ها در سرورها قرار می‌گیرن و از طریق `آدرس صفحه وب` قابل دسترسی و نصب هستن.

     **[فهرست](#فهرست)**

117. ### هدف از متد clearTimeout چیه؟

     تابع `clearTimeout` در جاواسکریپت برای پاک کردن بازه زمانی استفاده می‌شه که قبل از اون توسط تابع `setTimeout` تنظیم شده. یعنی مقدار بازگشتی تابع `setTimeout` تو یه متغیر ذخیره می‌شه و برای پاک کردن تایمر به تابع `clearTimeout` پاس داده می‌شه.

     برای مثال، از تابع `setTimeout` موجود توی کد پایین برای نمایش پیام بعد از 3 ثانیه استفاده می‌شه. این مهلت زمانی رو می‌شه با تابع `clearTimeout` پاک کرد.

     <span dir="ltr" align="left">

     ```html
     <script>
       var msg;

       function greeting() {
         alert("Good morning");
       }

       function start() {
         msg = setTimeout(greeting, 3000);
       }

       function stop() {
         clearTimeout(msg);
       }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

118. ### هدف از متد clearInterval چیه؟

     تابع `clearInterval` تو جاواسکریپت برای پاک کردن interval که توسط تابع `setInterval` تنظیم شده استفاده می‌شه. برای مثال، مقدار بازگشتی که توسط تابع `setInterval` برمی گرده تو یه متغیر ذخیره می‌شه و برای پاک کردن interval به تابع `clearInterval` ارسال می‌شه.

     برای مثال، از تابع `setInterval` توی کد پایینی برای نمایش پیام در هر 3 ثانیه استفاده می‌شه. این بازه رو می‌شه با تابع `clearInterval` پاک کرد.

     <span dir="ltr" align="left">

     ```html
     <script>
       var msg;

       function greeting() {
         alert("Good morning");
       }

       function start() {
         msg = setInterval(greeting, 3000);
       }

       function stop() {
         clearInterval(msg);
       }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

119. ### توی جاواسکریپت، چطوری می‌شه به یه صفحه جدید redirect انجام داد؟

     در `vanila` جاواسکریپت(جاواسکریپت خام یا خالص هم میگن)، می‌تونیم با استفاده از ویژگی `location` آبجکت گلوبال `window` به صفحه جدیدی هدایت بشین.

     <span dir="ltr" align="left">

     ```js
     function redirect() {
       window.location.href = "newPage.html";
     }
     ```

     </span>

     **[فهرست](#فهرست)**

120. ### چطوری بررسی می‌کنیم که یه string شامل یه substring هست یا نه؟

     سه روش برای بررسی اینکه یه رشته دارای یه رشته فرعیه یا نه، وجود داره.

     1. **استفاده از متد includes:** ES6 روش `String.prototype.includes` رو برای آزمایش یه رشته حاوی یه رشته فرعی ارائه کرد.

     <span dir="ltr" align="left">

     ```js
     const mainString = "hello";
     const subString = "hell";
     mainString.includes(subString);
     ```

     </span>

     2. **استفاده از متد indexOf:** توی محیط ES5 یا قدیمی‌تر، می‌تونیم از `String. prototype.indexOf` استفاده کنیم که index یه رشته فرعی رو برمی‌گردونه. اگه مقدار برابر با 1 نباشه، یعنی رشته فرعی توی رشته اصلی وجود داره.

     <span dir="ltr" align="left">

     ```js
     const mainString = "hello";
     const subString = "hell";
     mainString.indexOf(subString) !== -1;
     ```

     </span>

     3. **استفاده از Regex:** راه حل پیشرفته از روش `test` عبارت `Regular ('RegExp.test') `استفاده میکنه، که امکان آزمایش در برابر عبارات منظم رو فراهم میکنه.

     <span dir="ltr" align="left">

     ```js
     const mainString = "hello";
     const regex = /hell/;
     regex.test(mainString);
     ```

     </span>

     **[فهرست](#فهرست)**

121. ### توی جاواسکریپت، چطوری مقدار یه آدرس email رو اعتبارسنجی می‌کنیم؟

     می‌تونیم با استفاده از `Regex` ایمیل رو توی جاواسکریپت تأیید کنیم. توصیه می‌شه به جای سمت کلاینت، اعتبارسنجی سمت سرور انجام شه. چون جاواسکریپت رو می‌شه سمت کلاینت غیرفعال کرد.

     <span dir="ltr" align="left">

     ```js
     function validateEmail(email) {
       const re =
         /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
       return re.test(String(email).toLowerCase());
     }
     ```

     </span>

     **[فهرست](#فهرست)**

     `Regex` بالا کاراکترهای یونیک رو می پذیرد.

122. ### چطوری می‌تونیم مقدار آدرس url جاری رو بخونیم؟

     می‌تونیم از عبارت `window.location.href` برای دریافت مسیر آدرس فعلی استفاده کنیم و می‌تونیم از همون عبارت برای به‌روزرسانی URL هم استفاده کنیم. همچنین می‌تونیم از `document.URL` برای اهداف فقط خواندنی استفاده کنیم اما این راه‌حل مشکلاتی در FF داره.

     <span dir="ltr" align="left">

     ```js
     console.log("location.href", window.location.href); // Returns full URL
     ```

     </span>

     **[فهرست](#فهرست)**

123. ### ویژگی‌های مختلف url روی object مربوط به history کدوما هستن؟

     برای دسترسی به اجزای URL صفحه می‌توان از ویژگی‌های شی `location` زیر استفاده کرد.

     1. href - ورودی URL
     2. protocol - پروتکل استفاده شده URL
     3. host -‌هاست و پورت URL
     4. hostname -‌هاست URL
     5. port - شماره پورت URL
     6. pathname - مسیر URL
     7. search - قسمت جستجو URL
     8. hash - محل جای‌گیری URL

     **[فهرست](#فهرست)**

124. ### توی جاواسکریپت چطوری می‌تونیم مقدار یه query-string رو بخونیم؟

     می‌تونیم از `URLSearchParams` برای دریافت مقادیر رشته پرس و جو توی جاواسکریپت استفاده کنیم. بیاین مثالی برای دریافت مقدار کد مشتری از رشته پرس و جو `URL` ببینیم:

     <span dir="ltr" align="left">

     ```js
     const urlParams = new URLSearchParams(window.location.search);
     const clientCode = urlParams.get("clientCode");
     ```

     </span>

     **[فهرست](#فهرست)**

125. ### چطوری می‌تونیم بررسی کنیم که آیا یه پراپرتی روی آبجکت وجود داره یا نه؟

     1. **استفاده از عملگر‌ها:** می‌تونیم از عملگر in استفاده کنیم که آیا کلیدی توی آبجکت وجود داره یا نه

     <span dir="ltr" align="left">

     ```js
     "key" in obj;
     ```

     </span>

     برای بررسی وجود یا عدم وجود کلید، باید از پرانتز استفاده کنیم

     <span dir="ltr" align="left">

     ```js
     !("key" in obj);
     ```

     </span>

     2. **استفاده از متد hasOwnProperty:** می‌تونیم از `hasOwnProperty` برای آزمایش ویژگی‌های نمونه آبجکت (و نه ویژگی‌های ارثی) استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     obj.hasOwnProperty("key"); // true
     ```

     </span>

     3. **استفاده از مقایسه undifiend:** اگه بخوایم از یه آبجکت به یه ویژگی غیر موجود دسترسی پیدا کنیم، بهمون undifiend برمیگردونه. بیاین ویژگی‌ها را با undefined مقایسه کنیم تا وجود ویژگی را مشخص کنیم.

     <span dir="ltr" align="left">

     ```js
     const user = {
       name: "John",
     };

     console.log(user.name !== undefined); // true
     console.log(user.nickName !== undefined); // false
     ```

     </span>

     **[فهرست](#فهرست)**

126. ### چطوری روی یه object حلقه میزنی؟

     می‌تونیم از حلقه `for-in` برای حلقه زدن آبجکت جاواسکریپت استفاده کنیم. همچنین می‌تونیم مطمئن شیم که کلیدی که دریافت می‌کنیم ویژگی واقعی یه آبجکته و با استفاده از روش `hasOwnProperty` از prototype، نیست.

     <span dir="ltr" align="left">

     ```js
     const object = {
       k1: "value1",
       k2: "value2",
       k3: "value3",
     };

     for (const key in object) {
       if (object.hasOwnProperty(key)) {
         console.log(`${key} -> ${object[key]}`); // k1 -> value1 ...
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

127. ### چطوری تست می‌کنی که یه object خالیه؟

     راه حل‌های مختلفی بر اساس نسخه‌های `ECMAScript` وجود داره

     1. **استفاده Object entries(ECMA 7+):**
        میتونیم از `object entries` استفاده کنیم و `length` اونا رو چک کنیم

     <span dir="ltr" align="left">

     ```js
     Object.entries(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
     ```

     </span>

     2. **استفاده از Object keys(ECMA 5+):**
        می‌تونیم از`object keys` استفاده کنیم و `length` اونو چک کنیم

     <span dir="ltr" align="left">

     ```js
     Object.keys(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
     ```

     </span>

     3. **استفاده از for-in با متد hasOwnProperty (Pre-ECMA 5):**
        می‌تونیم از حلقه `for-in`استفاده کنیم و هر پارامتر رو با `hasOwnProperty` چک کنیم

     <span dir="ltr" align="left">

     ```js
     function isEmpty(obj) {
       for (const prop in obj) {
         if (obj.hasOwnProperty(prop)) {
           return false;
         }
       }

       return JSON.stringify(obj) === JSON.stringify({});
     }
     ```

     </span>

     **[فهرست](#فهرست)**

128. ### arguments object چیه؟

     آبجکت arguments یه آبجکت آرایه ماننده که داخل توابع قابل دسترسیه و حاوی مقادیر آرگومان‌های ارسال شده به اون تابعه. برای مثال، بیاین ببینیم چطوری از آبجکت arguments توی تابع sum استفاده کنیم:

     <span dir="ltr" align="left">

     ```js
     function sum() {
       let total = 0;
       for (let i = 0, len = arguments.length; i < len; ++i) {
         total += arguments[i];
       }
       return total;
     }

     sum(1, 2, 3); // returns 6
     ```

     </span>

     **نکته:** ما نمی‌تونیم از متد‌های ارایه برای آبجکت `arguments` استفاده کنیم اما می‌تونیم به ارایه تبدیلش کنیم

     <span dir="ltr" align="left">

     ```js
     const argsArray = [...arguments];
     ```

     </span>

     **[فهرست](#فهرست)**

129. ### چطوری حرف اول یه رشته رو به حرف بزرگ تبدیل می‌کنی؟

     می‌تونیم با درست کردن یه تابع و با استفاده از زنجیره ای از متد‌های string مثلا `charAt` و `toUpperCase` و `slice` یه string با حرف اول بزرگ ایجاد کنیم

     <span dir="ltr" align="left">

     ```js
     function capitalizeFirstLetter(string) {
       return string.charAt(0).toUpperCase() + string.slice(1);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

130. ### مزایا و معایب حلقه for چیا هستن؟

     حلقه `for` یه syntax تکرار رایجه که از مزایا و معایبش میشه به موارد زیر اشاره کرد:

     #### مزایا

     1. توی همه‌ی محیط‌ها `env` کار میکنه
     2. می‌تونیم از `break` و `continue` برای کنترل جریان داده استفاده کنیم

     #### معایب

     1. از لحاظ نوشتاری کد بیشتری باید نوشته بشه
     2. Imperative هست
     3. ممکنه با خطاهای one-by-off روبرو بشیم

     **[فهرست](#فهرست)**

131. ### چطوری تاریخ جاری رو توی جاواسکریپت نشون میدی؟

     می‌تونیم از کلاس `new Date` استفاده کنیم و با اجرای متد `toLocaleString()` تاریخ و زمان جدا شده توسط کاما رو بدست بیاریم :

     <span dir="ltr" align="left">

     ```js
     const today = new Date().toLocaleString();
     console.log(today.split(",")[0]); // 5/19/2022
     ```

     </span>

     **[فهرست](#فهرست)**

132. ### چطوری دو تا date object رو با هم مقایسه می‌کنی؟

     برای این مقایسه نباید از اپراتور‌ها استفاده کنیم. میتونیم مثل کد زیر از متد getTime که بر روی آبجکت Date قرار داره استفاده کنیم

     <span dir="ltr" align="left">

     ```js
     const d1 = new Date();
     const d2 = new Date(d1);
     console.log(d1.getTime() === d2.getTime()); // True
     console.log(d1 === d2); // False
     ```

     </span>

     **[فهرست](#فهرست)**

133. ### چطوری بررسی می‌کنی که یه رشته با یه رشته دیگه شروع می‌شه؟

     می‌تونیم از متد startWith که بر روی پروتوتایپ String وجود داره استفاده کنیم که یه رشته رو می‌گیره و چک میکنه که رشته مورد نظر با اون رشته شروع میشه یا نه، برای مثال کد زیر رو براش مینویسیم:

     <span dir="ltr" align="left">

     ```js
     "Good morning".startsWith("Good"); // true
     "Good morning".startsWith("morning"); // false
     ```

     </span>

     **[فهرست](#فهرست)**

134. ### چطوری یه رشته رو trim می‌کنی؟

     جاواسکریپت یه متد به ما میده به اسم `trim` که روی رشته‌ها قرار داره با استفاده از این متد همه ی فضاهای خالی بین اون رشته برداشته می‌شه

     <span dir="ltr" align="left">

     ```js
     "  Hello World   ".trim(); // Hello World
     ```

     </span>

     </span>

     **[فهرست](#فهرست)**

135. ### توی جاواسکریپت چطوری می‌تونیم یه زوج مرتب از key یه valueها بسازیم؟

     برای اضافه کردن key جدید به آبجکت‌ها دو روش وجود داره

     <span dir="ltr" align="left">

     ```js
     const object = {
       key1: value1,
       key2: value2,
     };
     ```

     </span>

     1. **استفاده از dot:** این روش زمانی موثر هستش که اسم پراپرتی رو میدونیم

     <span dir="ltr" align="left">

     ```js
     object.key3 = "value3";
     ```

     </span>

     1. **استفاده از کروشه[]:** این روش زمانی موثر هستش که اسم پراپرتی داینامیک باشه

     <span dir="ltr" align="left">

     ```js
     obj.key3 = "value3";
     ```

     </span>

     **[فهرست](#فهرست)**

136. ### آیا عبارت '--!' عملگر خاصی هست؟

     نه! اپراتور خاص نیست اما ترکیب دو تا اپراتور استاندار هستش یکی بعد اون یکی

     1. اپراتور نقییض (!)
     2. کاهش کننده(--)

     اول یه شماره از مقدار متغیر به مثال کم می‌شه بعد تست می‌شه که مساوی صفر هستش یا نه، که مشخص‌کننده درست یا غلط بودن شرط هست

     **[فهرست](#فهرست)**

137. ### چطوری می‌تونیم به متغیرهامون مقادیر اولیه بدیم؟

     می‌تونیم از عملگر یا اپراتور `||` برای تعریف یه مقدار پیش‌فرض استفاده کرد:

     <span dir="ltr" align="left">

     ```js
     const a = b || c;
     ```

     </span>

     مثال تعریف شده بالا مقدار متغیر a زمانی برابر مقدار متغیر c خواهد شد که b خالی false یا undifined باشه.

     **[فهرست](#فهرست)**

138. ### چطوری می‌تونیم متن‌های چند خطی درست کنیم؟

     می‌تونیم از `/` برای تعریف کردن رشته‌های چند خطی استفاده کنیم برای مثال:

     <span dir="ltr" align="left">

     ```js
     const str =
       "This is a \
     very lengthy \
     sentence!";
     ```

     </span>

     اما اگه یه فاصله بعد `/` داشته باشیم,کد دقیقا به همون حالتی که هست نشون داده می‌شه اما یه ارور خطای نوشتاری کد قراره داشته باشیم

     <br />

     روش بعدی استفاده کردن از `backtick` هست که وقتی موقع تعریف رشته به جای کوتیشن مارک ازش استفاده بشه میتونیم راحت یه رشته چند خطی تعریف کنیم. برای مثال میشه کد زیر رو براش نوشت:

     <span dir="ltr" align="left">

     ```js
     const str = `This is a 
     very lengthy 
     sentence!`;
     ```

     </span>

     **[فهرست](#فهرست)**

139. ### مدل app-shell چیه؟

     application shell (shell) یکی از راه‌های ساخت PWA هستش که به طور قابل اعتماد و فوری بر روی صفحه نمایش کاربران شما بارگیری می‌شه، مشابه اونی‌که توی برنامه‌های کاربردی native به کاربر نشون داده میشه. برای رسوندن سریع HTML اولیه به صفحه بدون نیاز به شبکه مفیده.

     **[فهرست](#فهرست)**

140. ### چطوری می‌تونیم روی یه تابع property اضافه کنیم؟

     می‌تونیم برای توابع پراپرتی تعیین کنیم چون توابع اصولا آبجکت هستن.

     <span dir="ltr" align="left">

     ```js
     const fn = function (x) {
       // Function code goes here
     };

     fn.userName = "John";

     fn.profile = function (y) {
       // Profile code goes here
     };
     ```

     </span>

     **[فهرست](#فهرست)**

141. ### چطوری می‌تونیم تعداد پارامترهای ورودی یه تابع رو به دست بیاریم؟

     با استفاده کردن از `function.length` می‌تونیم به تعداد پارامتر‌هایی که یه تابع انتظار داره بگیره دسترسی داشته باشیم.
     بریم یه مثال درموردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     function sum(num1, num2, num3, num4) {
       return num1 + num2 + num3 + num4;
     }
     sum.length; // 4 is the number of parameters expected.
     ```

     </span>

     **[فهرست](#فهرست)**

142. ### Polyfill چیه؟

     `plyfill` یه قسمت از کد جاواسکریپت‌ـه که با استفاده از اون ما می‌تونیم توابع پیشرفته رو روی مروگر‌هایی که به طور طبیعی پشتیبانی نمیکنن,استفاده کنیم. پلاگین `Silverlight` که برای تقلید کردن توابع بر روی `canvas` یا مروگر `IE7` استفاده کرد

     **[فهرست](#فهرست)**

143. ### عبارات Break و continue چی هستن؟

     دستور `break` برای "پرش به بیرون" از یه حلقه استفاده می‌شه. یعنی حلقه رو می‌شکنه و اجرای کد رو بعد از حلقه ادامه میده.

     <span dir="ltr" align="left">

     ```js
     for (i = 0; i < 10; i++) {
       if (i === 5) {
         break;
       }
       text += `Number: ${i}<br>`;
     }
     ```

     </span>

     دستور `continue` برای "پرش از روی" یه تکرار در حلقه استفاده می‌شه. یعنی یه تکرار (در حلقه) رو می‌شکنه، اگه شرایط مشخصی رخ بده، و با تکرار بعدی در حلقه ادامه میده.

     <span dir="ltr" align="left">

     ```js
     for (i = 0; i < 10; i++) {
       if (i === 5) {
         continue;
       }
       text += `Number: ${i}<br>`;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

144. ### توی جاواسکریپت labelها چیکار می‌کنن؟

     دستور `label` به ما اجازه میده تا حلقه‌ها و بلوک‌ها رو توی جاواسکریپت نام گذاری کنیم. بعد می‌تونیم از این برچسب‌ها برای مراجعه به کد استفاده کنیم. برای مثال، کد زیر با استفاده از برچسب‌ها از چاپ اعداد وقتی که یکسان هستن، جلوگیری میکنه.

     <span dir="ltr" align="left">

     ```js
     loop1: for (let i = 0; i < 3; i++) {
       for (let j = 0; j < 3; j++) {
         if (i === j) {
           continue loop1;
         }
         console.log(`i = ${i}, j = ${j}`);
       }
     }

     // Output is:
     //   "i = 1, j = 0"
     //   "i = 2, j = 0"
     //   "i = 2, j = 1"
     ```

     </span>

     **[فهرست](#فهرست)**

145. ### مزایای declare کردن متغیرها در اوایل کد چیه؟

     توصیه می‌شه که تمام تعریف متغیر‌ها رو بالای هر اسکریپت یا تابع انجام بدیم. مزیت این کار:

     1. کد ما تمیز تر می‌شه
     2. یه مکان واحد برای جستجوی متغیرهای محلی فراهم میکنه
     3. می‌شه راحت از استفاده متفیر‌های ناخواسته جلوگیری کرد
     4. این کار محاسبات ناخواسته رو کمتر میکنه

     **[فهرست](#فهرست)**

146. ### مزایای مقداردهی اولیه متغیرها چیه؟

     توضیه می‌شه که حتما یه مقدار اولیه برای متغیرها تعیین بشه که دلایلشو چک می‌کنیم

     1. خروجیمون کد تمیز تری می‌شه
     2. این کار باعث می‌شه یه جا برای این متغییر رزرو بشه
     3. از برگشتن خطای `undefind`جلوگیری می‌شه

     **[فهرست](#فهرست)**

147. ### روش توصیه شده برای ایجاد object چیه؟

     برای ساخت یه `object` با مقادیر پیش‌فرض میتونیم به صورت زیر عمل کنیم

     1. استفاده از {} به جای `new Object`
     2. استفاده از "" به جای `new String`
     3. استفاده از 0 به جای `new Number`
     4. استفاده از false به جای `new Boolean`
     5. استفاده از [] به جای `new Array`
     6. استفاده از /()/ به جای `new RegExp`
     7. استفاده از (){} به جای`new Function`

     بریم چند تا مثال ببینیم:

     <span dir="ltr" align="left">

     ```js
     const v1 = {};
     const v2 = "";
     const v3 = 0;
     const v4 = false;
     const v5 = [];
     const v6 = /()/;
     const v7 = function () {};
     ```

     </span>

     **[فهرست](#فهرست)**

148. ### چطوری می‌تونیم آرایه‌ JSON تعریف کنیم؟

     برای تعریف آرایه‌های JSON از براکت استفاده میکنیم و هر تعداد که آبجکت خواستیم داخلش تعریف میکنیم.
     بیاین یه مثال در موردش ببینیم

     <span dir="ltr" align="left">

     ```js
     "users":[
       {"firstName":"John", "lastName":"Abrahm"},
       {"firstName":"Anna", "lastName":"Smith"},
       {"firstName":"Shane", "lastName":"Warn"}
     ]
     ```

     </span>

     **[فهرست](#فهرست)**

149. ### چطوری می‌تونیم اعداد تصادفی تولید کنیم؟

     می‌تونیم از متد `Math.random` برای ساخت یه عدد رندوم بین 0 تا 1 و از متد `Math.floor` برای رند کردن اون عدد استفاده کنیم حالا اگه حاصل عدد به دست اومده رو ضربدر ده کنیم عددی بین یک تا ده خواهیم داشت

     <span dir="ltr" align="left">

     ```js
     Math.floor(Math.random() * 10) + 1; // returns a random integer from 1 to 10
     Math.floor(Math.random() * 100) + 1; // returns a random integer from 1 to 100
     ```

     </span>

     **نکته:** `Math.random` یه عدد تصادفی بین 0 تا 1 ایجاد میکنه، یادمون باشه که استفاده از `Math.floor` قبل ضرب کردن عدد رندوم به دست اومده در ده به عنوان کمترین مقدار، باعث میشه که خروجیمون همیشه به صفر رند بشه.

     **[فهرست](#فهرست)**

150. ### می‌تونی یه تابع تولید اعداد تصادفی توی یه بازه مشخص بنویسی؟

     بله ما می‌تونیم کد زیر رو برای این تابع داشته باشیم که مقادیر حداکثر و حداقل رو بگیره و برای ما عدد رندوم ایجاد کنه:

     <span dir="ltr" align="left">

     ```js
     function randomInteger(min, max) {
       return Math.floor(Math.random() * (max - min + 1)) + min;
     }
     randomInteger(1, 100); // returns a random integer from 1 to 100
     randomInteger(1, 1000); // returns a random integer from 1 to 1000
     ```

     </span>

     **[فهرست](#فهرست)**

151. ### Tree-shaking چیه؟

     `Tree Shaking` نوعی حذف کد مرده هستش و به این معنیه که ماژول‌های استفاده نشده در طول فرآیند ساخت در بسته گنجونده نمی‌شن و برای اون بر ساختار استاتیک ماژول ES2015 متکیه (یعنی import و export). توی باندلر ماژول ES2015 'rollup' از این عملکرد استفاده شده.

     **[فهرست](#فهرست)**

152. ### دلایل نیاز به tree-shaking کدوما هستن؟

     `Tree Shaking` می‌تونه اندازه کد رو در هر برنامه ای به میزان قابل توجهی کاهش بده. یعنی هرچی کد کمتری از طریق سیم بفرستیم برنامه کاربردی تره. به عنوان مثال، اگه فقط بخواهیم یه برنامه Hello World با استفاده از چارچوب‌های SPA ایجاد کنیم، حدود چند مگابایت حافظه رو اشغال میکنه، اما tree-shaking می‌تونه اندازه رو به چند صد کیلوبایت کاهش بده. tree-shaking تو باندلرهای `Rollup` و `Webpack` پیاده سازی شده.

     **[فهرست](#فهرست)**

153. ### آیا استفاده از eval توصیه می‌شه؟

     نه، `eval` اجازه اجرای کد دلخواه رو میده که باعث ایجاد مشکل امنیتی می‌شه. همونطور که میدونیم از تابع `eval` برای اجرای متن به عنوان کد استفاده می‌شه. در بیشتر موارد استفاده از اون ضروری نیست.

     **[فهرست](#فهرست)**

154. ### Regular-Expression چیه؟

     `regular expression` یا همون `Regex` یه توالیه که یه ساختار جستجو ایجاد میکنه با استفاده از این ساختار ما می‌تونیم دیتامون رو جستجو کنیم و به قولی دیتامون رو اعتبارسنجی کنیم.

     <span dir="ltr" align="left">

     ```js
     /pattern/modifiers;
     ```

     </span>

     برای مثال Regex حساس به حروف کوچک و بزرگ زبان انگلیسی به صورت ریر نوشته می‌شه:

     <span dir="ltr" align="left">

     ```js
     /John/i;
     ```

     </span>

     **[فهرست](#فهرست)**

155. ### متدهای رشته که روی Regular-expression مجاز هستن کدوماست؟

     Regular Expressions دو تا متد برای رشته‌ها داره :‌ `search` و `replace`. متد `search` یه عبارت رو می‌گیره اونو جستجو میکنه و محل اون عبارت رو برمی‌گردونه:

     <span dir="ltr" align="left">

     ```js
     const msg = "Hello John";
     const n = msg.search(/John/i); // 6
     ```

     </span>

     متد replace برای برگردوندن رشته اصلاح شده تو جایی که الگو جایگزین می‌شه، استفاده می‌شه:

     <span dir="ltr" align="left">

     ```js
     const msg = "Hello John";
     const n = msg.replace(/John/i, "Buttler"); // Hello Buttler
     ```

     </span>

     **[فهرست](#فهرست)**

156. ### توی Regex بخش modifiersها چیکار میکنه؟

     `Modifiers`‌ها میتونن زمانی استفاده بشن که به جستجو‌های بدون حروف کوچک و بزرگ سراسری نیاز داریم بیاین یه مثال درموردشون ببینیم:

     | اصلاح کننده |                توضیح                 |
     | :---------: | :----------------------------------: |
     |      i      |          تظبیق حساس به حروف          |
     |      g      | تطبیق کلی به جای توقف در اولین تشابه |
     |      m      |             تطبیق چندخطی             |

     بریم یه مثال از modifier گلوبال ببینیم:

     <span dir="ltr" align="left">

     ```js
     const text = "Learn JS one by one";
     const pattern = /one/g;
     const result = text.match(pattern); // one,one
     ```

      </span>

     **[فهرست](#فهرست)**

157. ### پترن‌های regular-expression چیه؟

     Regex یه گروهی از ساختار‌ها برامون اماده کرده که با اونا کاراکتر‌ها رو چک کنیم اونا تو سه مدل طبفه بندی میشن.

     <br />

     1. **براکت‌ها:** برای پیدا کردن رنجی از کاراکتر استفاده میشن
        برای مثال پایین چن تا مورد استفاده لیست شدن
        1. [abc]: برای پیدا کردن هر کاراکتری بین این سه کاراکتر استفاده میشه
        2. [0-9]: برای پیدا کردن ارقام بین این دو عدد استفاده میشه
        3. (a|b): برای پیدا کردن هر یه از گزینه‌های جدا شده با | استفاده می‌شه

     <br />

     2. **کاراکتر برابر با:** این عبارت‌ها کاراکتر‌هایی با معنی خاص هستن
        برای مثال پایین سه تا مورد که استفاده می‌شه ازشون رو ببینیم
        1. \\d: برای پیدا کردن اعداد استفاده میشه
        2. \\s: برای پیدا کردن فاصله‌ها استفاده میشه
        3. \\b: برای پیدا کردن کاراکتر‌های همخوانی داشته با شروع شدن یا پایانشون استفاده میشه

     <br />

     3. **کمیت کننده‌ها:** این‌ها برای تعریف کمیت‌ها موثر هستن
        برای مثال پایین دو تا مورد استفاده براشون اوردیم
        1. n+: برای پیدا کردن رشته همخوانی داشته با حداقل یه کاراکتر
        2. n\*: برای پیدا کردن همخوانی هر رشته شامل صفر یا بیشتر
        3. n?: برای پیدا کردن هر رشته که شامل صفر یا یه کاراکنر می‌شه

     **[فهرست](#فهرست)**

158. ### آبجکت RegExp چیه؟

     `object`‌های `Regex` یه عبارت معمولی با پراپرتی‌ها و متد‌های تعریف شده از قبل هس. بریم یه مثال از نحوه استفادشون ببینیم.

     <span dir="ltr" align="left">

     ```js
     const regexp = new RegExp("\\w+");
     console.log(regexp);
     // expected output: /\w+/
     ```

     </span>

     **[فهرست](#فهرست)**

159. ### چطوری روی یه رشته دنبال یه پترن RegExp می‌گردی؟

     می‌تونیم از متد test عبارت منظم برای جستجوی یه رشته برای الگو استفاده کنیم که بسته به نتیجه، true یا false رو برمیگردونه.

     <span dir="ltr" align="left">

     ```js
     const pattern = /you/;
     console.log(pattern.test("How are you?")); // true
     ```

     </span>

     **[فهرست](#فهرست)**

160. ### هدف از متد exec چیه؟

     هدف متد exec شبیه به روش تسته اما جستجوی یه تطابق تو یه رشته مشخص رو انجام میده و یه آرایه نتیجه یا null رو به جای برگردوندن true/false برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     const pattern = /you/;
     console.log(pattern.exec("How are you?")); // ["you", index: 8, input: "How are you?", groups: undefined]
     ```

     </span>

     **[فهرست](#فهرست)**

161. ### چطوری استایل‌های یه المنت HTML رو تغییر میدی؟

     می‌تونیم سبک درون خطی یا اسم کلاس یه عنصر HTML رو با استفاده از جاواسکریپت تغییر بدین

     <br />

     1. **استفاده از پراپرتی style:** با استفاده از ویژگی style می‌تونیم استایل درون خطی رو تغییر بدین

     <span dir="ltr" align="left">

     ```js
     document.getElementById("title").style.fontSize = "30px";
     ```

     </span>

     2. **استفاده از پراپرتی className:** تغییر کلاس عنصر با استفاده از ویژگی className آسان است

     <span dir="ltr" align="left">

     ```js
     document.getElementById("title").style.className = "custom-title";
     ```

     </span>

     **[فهرست](#فهرست)**

162. ### نتیجه عبارت 1+2+'3' چی می‌شه؟

     خروجی '33' می‌شه. از اونجایی که «1» و «2» مقادیر عددی هستن، نتیجه دو رقم اول یه مقدار عددی «3» خواهد بود. رقم بعدی یه مقدار نوع رشته اس چون افزودن مقدار عددی «3» و مقدار رشته «3» فقط یه مقدار الحاقی «33» می‌شه.

     **[فهرست](#فهرست)**

163. ### عبارت debugger چیکار میکنه؟

     دستور debugger هر گونه عملکرد اشکال زدایی موجود رو فراخوانی میکنه، مانند تعیین breakpoint. اگه هیچ عملکرد اشکال زدایی در دسترس نباشه، این عبارت تاثیری نداره.
     برای مثال، در تابع زیر یه دستور debugger درج شده. بنابراین اجرا تو دستور debugger مثل یه breakpoint در منبع اسکریپت متوقف می‌شه.

     <span dir="ltr" align="left">

     ```js
     function getProfile() {
       // code goes here
       debugger;
       // code goes here
     }
     ```

     </span>

     **[فهرست](#فهرست)**

164. ### هدف از breakpointها توی debugging چیه؟

     پس از اجرای دستور debugger و باز شدن پنجره دیباگر، می‌تونیم breakpointها رو در کد جاواسکریپت تنظیم کنیم. در هر breakpoint، جاواسکریپت اجرا نمی‌شه و به ما اجازه میده مقادیر جاواسکریپت رو بررسی کنیم. پس از بررسی مقادیر، می‌تونیم با استفاده از دکمه پخش، اجرای کد رو ادامه بدیم.

     **[فهرست](#فهرست)**

165. ### آیا می‌تونیم از عبارت‌های رزرو شده در تعریف identifierها(اسم متغیر، کلاس و ...) استفاده کنیم؟

     نه، ما نمی‌تونیم از کلمات رزرو شده به عنوان متغیر، برچسب، اسم آبجکت یا تابع استفاده کنیم. بیاین یه مثال ساده رو ببینیم:

     <span dir="ltr" align="left">

     ```js
     let else = "hello"; // Uncaught SyntaxError: Unexpected token else
     ```

     </span>

     **[فهرست](#فهرست)**

166. ### چطوری تشخیص بدیم که یه مرورگر mobile هست یا نه؟

     ما می‌تونیم با استفاده از Regex که یه boolean به ما برمی‌گردونه بفهمیم که مرورگری که کاربر داره ازش استفاده میکنه موبایل هست یا نه، کد تشخیص به این صورت نوشته میشه:

     <span dir="ltr" align="left">

     ```js
     window.mobilecheck = function () {
       let mobileCheck = false;
       (function (a) {
         if (
           /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
             a
           ) ||
           /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
             a.substr(0, 4)
           )
         )
           mobileCheck = true;
       })(navigator.userAgent || navigator.vendor || window.opera);
       return mobileCheck;
     };
     ```

     </span>

     **[فهرست](#فهرست)**

167. ### چطوری بدون Regex تشخیص بدیم که یه مرورگر mobile هست یا نه؟

     می‌تونیم مرورگرهای تلفن همراه رو با اجرای فهرستی از دستگاه‌ها و بررسی اینکه آیا `useragent` با چیزی مطابقت داره یا نه، شناسایی کنیم. این یه راه حل جایگزین برای استفاده از RegExp هستش

     <span dir="ltr" align="left">

     ```js
     function detectmob() {
       if (
         navigator.userAgent.match(/Android/i) ||
         navigator.userAgent.match(/webOS/i) ||
         navigator.userAgent.match(/iPhone/i) ||
         navigator.userAgent.match(/iPad/i) ||
         navigator.userAgent.match(/iPod/i) ||
         navigator.userAgent.match(/BlackBerry/i) ||
         navigator.userAgent.match(/Windows Phone/i)
       ) {
         return true;
       }

       return false;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

168. ### چطوری طول و عرض یه تصویر رو با جاواسکریپت به دست میاری؟

     می‌تونیم با استفاده از جاواسکریپت به صورت برنامه‌ریزی شده تصویر رو بدست بیاریم و ابعاد (عرض و ارتفاع) رو بررسی کنیم، برای مثال syntax بررسی میتونه طبق مثال زیر انجام بشه:

     <span dir="ltr" align="left">

     ```js
     const img = new Image();

     img.onload = function () {
       console.log(`${this.width}x${this.height}`);
     };

     img.src = "http://www.google.com/intl/en_ALL/images/logo.gif";
     ```

     </span>

     **[فهرست](#فهرست)**

169. ### چطوری درخواست‌های synchronous HTTP بزنیم؟

     مرورگرها یه کلاس `XMLHttpRequest` ارائه می‌دن که می‌تونه برای ایجاد درخواست‌های `HTTP` همزمان از جاواسکریپت استفاده شه.

     <span dir="ltr" align="left">

     ```js
     function httpGet(theUrl) {
       const xmlHttpReq = new XMLHttpRequest();
       xmlHttpReq.open("GET", theUrl, false); // false for synchronous request
       xmlHttpReq.send(null);
       return xmlHttpReq.responseText;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

170. ### چطوری درخواست‌های asynchronous HTTP بزنیم؟

     مرورگرها یه کلاس `XMLHttpRequest` رو ارائه می‌دن که می‌تونن برای درخواست‌های `HTTP` ناهمزمان از جاواسکریپت با ارسال پارامتر سوم به عنوان `true` استفاده کنن.

     <span dir="ltr" align="left">

     ```js
     function httpGetAsync(theUrl, callback) {
       const xmlHttpReq = new XMLHttpRequest();
       xmlHttpReq.onreadystatechange = function () {
         if (xmlHttpReq.readyState == 4 && xmlHttpReq.status == 200)
           callback(xmlHttpReq.responseText);
       };
       xmlHttp.open("GET", theUrl, true); // true for asynchronous
       xmlHttp.send(null);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

171. ### چطوری یه تاریخ رو به یه تاریخ در timezone دیگه تبدیل کنیم؟

     می‌تونیم از متد `toLocaleString` برای تبدیل تاریخ‌ها تو یه منطقه زمانی به منطقه زمانی دیگه استفاده کنیم.بریم یه مثال درموردش ببینیم.

     <span dir="ltr" align="left">

     ```js
     console.log(event.toLocaleString("en-GB", { timeZone: "UTC" })); // 29/06/2019, 09:56:00
     ```

     </span>

     **[فهرست](#فهرست)**

172. ### چه propertyهایی برای اندازه‌گیزی سایز window به کار میره؟

     می‌تونیم از ویژگی‌های `innerWidth،` `innerHeight،` `clientWidth،` `clientHeight` ویندوز، عنصر document و آبجکت body document برای پیدا کردن اندازه یه پنجره استفاده کنیم. بیاین از ترکیب اونا برای محاسبه اندازه یه window یا document استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     const width =
       window.innerWidth ||
       document.documentElement.clientWidth ||
       document.body.clientWidth;

     const height =
       window.innerHeight ||
       document.documentElement.clientHeight ||
       document.body.clientHeight;
     ```

     </span>

     **[فهرست](#فهرست)**

173. ### عملگر شرطی سه گانه توی جاواسکریپت چیه؟

     عملگر شرطی `ternary` تنها عملگر جاواسکریپت هستش که سه عملوند رو می‌گیره که به عنوان میانبر برای دستور if عمل میکنه.

     <span dir="ltr" align="left">

     ```js
     const isAuthenticated = false;
     console.log(
       isAuthenticated ? "Hello, welcome" : "Sorry, you are not authenticated"
     ); // Sorry, you are not authenticated
     ```

     </span>

     **[فهرست](#فهرست)**

174. ### آیا می‌شه روی عملگر شرطی زنجیره شرط‌ها رو اعمال کرد؟

     بله، می‌تونیم زنجیره‌سازی رو روی عملگرهای شرطی مشابه `if … else if … else if… other chain` اعمال کنیم.

     <span dir="ltr" align="left">

     ```js
     function traceValue(someParam) {
       return condition1
         ? value1
         : condition2
         ? value2
         : condition3
         ? value3
         : value4;
     }

     // The above conditional operator is equivalent to:

     function traceValue(someParam) {
       if (condition1) {
         return value1;
       } else if (condition2) {
         return value2;
       } else if (condition3) {
         return value3;
       } else {
         return value4;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

175. ### روش‌های اجرای جاواسکریپت بعد از لود شدن صفحه کدوما هستن؟

     1. **window.onload:**

     <span dir="ltr" align="left">

     ```js
     window.onload = function ...
     ```

     </span>

     2. **document.onload:**

     <span dir="ltr" align="left">

     ```js
     document.onload = function ...
     ```

     </span>

     3. **body onload:**

     <span dir="ltr" align="left">

     ```js
     <body onload="script();">
     ```

     </span>

     **[فهرست](#فهرست)**

176. ### تفاوت‌های بین proto و prototype کدوما هستن؟

     `__proto__` آبجکت واقعیه که در زنجیره جستجو برای حل متدها و غیره استفاده می‌شه. در حالی که `prototype` آبجکت‌ای‌ـه که برای ساخت `__proto__`استفاده می‌شه زمانی که یه آبجکت با `new Object()` ایجاد می‌کنیم.

     <span dir="ltr" align="left">

     ```js
     new Employee().__proto__ === Employee.prototype;
     new Employee().prototype === undefined;
     ```

     </span>

     **[فهرست](#فهرست)**

177. ### میتونی یه مثال از زمانی که واقعا به سمیکولون( ; ) نیاز هست بزنی؟

     توصیه می‌شه که بعد از هر عبارت در جاواسکریپت از سیمیکالن استفاده کنیم. برای مثال، توی مثال زیر نذاشتن سیمیکالن، خطای `.. is not a function` رو در زمان اجرا ایجاد میکنه:

     <span dir="ltr" align="left">

     ```js
     // define a function
     const fn = (function () {
       // ...
     })(() => {
       // ...
     })();
     ```

     </span>

     از مثال بالا جاواسکریپت اینطور برداشت میکنه

     <span dir="ltr" align="left">

     ```js
     const fn = (function () {
       // ...
     })(() => {
       // ...
     })();
     ```

     </span>

     در این حالت، تابع دوم رو به عنوان آرگومان به تابع اول ارسال می‌کنیم و سعی می‌کنیم نتیجه فراخوانی تابع اول رو به عنوان تابع فراخوانی کنیم.بخاطر همین برای تابع دوم خطای`.. is not a function` رو موقع اجرا می‌گیریم.

     **[فهرست](#فهرست)**

178. ### متد freeze چیکار میکنه؟

     متد **freeze** برای فریز کردن یه آبجکت استفاده می‌شه. ثابت کردن یه آبجکت اجازه افزودن ویژگی‌های جدید به یه آبجکت رو نمی‌ده. از حذفش جلوگیری میکنه و از تغییر قابلیت شمارش پذیری، پیکربندی یا قابلیت نوشتن ویژگی‌های موجود جلوگیری میکنه. یعنی آبجکتء ارسال شده رو برمی‌گردونه و کپی ثابتی ایجاد نمیکنه.

     <span dir="ltr" align="left">

     ```js
     const obj = {
       prop: 100,
     };

     Object.freeze(obj);
     obj.prop = 200; // Throws an error in strict mode

     console.log(obj.prop); // 100
     ```

     </span>

     **نکته:** یه تایپ ارور بهمون می‌ده که ارگومان داده شده `object` نیست

     **[فهرست](#فهرست)**

179. ### هدف از متد freeze چیه؟

     1. برای فریز کردن آبجکت‌ها و آرایه‌ها
     2. برای `imutable` کردن آبجکت‌ها

     **[فهرست](#فهرست)**

180. ### چرا به متد freeze نیاز داریم؟

     در پارادایم شی گرا، یه `API` موجود حاوی عناصر خاصیه که قصد توسعه، اصلاح یا استفاده مجدد رو خارج از زمینه فعلی خودشون ندارن. در زبان‌های مختلف کلمه کلیدیه `final`برای داشتن همچین خاصیتی استفاده می‌شه.

     **[فهرست](#فهرست)**

181. ### چطوری می‌تونیم زبان ترجیحی یه مرورگر رو تشخیص بدیم؟

     ما می‌تونیم از آبجکت `navigator` که بر روری مرورگر وجود داره این کارو انجام بدیم

     <span dir="ltr" align="left">

     ```js
     const language =
       (navigator.languages && navigator.languages[0]) || // Chrome / Firefox
       navigator.language || // All browsers
       navigator.userLanguage; // IE <= 10

     console.log(language);
     ```

     </span>

     **[فهرست](#فهرست)**

182. ### چطوری می‌تونیم حرف اول همه کلمات یه رشته رو به حرف بزرگ تبدیل کنیم؟

     ما می‌تونیم با تابع زیر این کارو انجام بدیم:

     <span dir="ltr" align="left">

     ```js
     function toTitleCase(str) {
       return str.replace(
         /\w\S*/g,
         (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
       );
     }
     toTitleCase("good morning john"); // Good Morning John
     ```

     </span>

     **[فهرست](#فهرست)**

183. ### چطوری می‌شه تشخیص داد که جاواسکریپت یه صفحه وب غیرفعال شده؟

     برای تشخیص غیرفعال بودن یا نبودن جاواسکریپت می‌تونیم از تگ `<noscript>` استفاده کنیم. بلوک کد داخل `<noscript>` زمانی اجرا می‌شه که جاواسکریپت غیرفعاله و معمولاً برای نمایش محتوای جایگزین زمانی که صفحه در جاواسکریپت تولید می‌شه، استفاده می‌شه.

     <span dir="ltr" align="left">

     ```html
     <script type="javascript">
       // JS related code goes here
     </script>
     <noscript>
       <a href="next_page.html?noJS=true"
         >JavaScript is disabled in the page. Please click Next Page</a
       >
     </noscript>
     ```

     </span>

     **[فهرست](#فهرست)**

184. ### عملگرهای پشتیبانی شده توسط جاواسکریپت کدوما هستن؟

     یه عملگر قادر به دستکاری (محاسبات ریاضی و منطقی) مقدار یا عملوند معینه. اپراتورهای مختلفی توسط جاواسکریپت پشتیبانی میشن این اپراتور‌ها هستن

     1. **عملگر‌های حسابی:** شامل + (اضافه),– (منها), \* (ضرب), / (تقسیم), % (درصد), + + (اضافه کردن) و – – (کم کردن)
     2. **عملگر‌های مقایسه ای:** شامل = =(برابر),!= (غیر برابر), ===(برابر و تایپ برابر), > (بزرگتر),> = (بزرگتر مساوی),< (کوچکتر),<= (کوچکتر مساوی)
     3. **عملگر‌های منطقی:** شامل &&("و"منطقی),||("یا"منظقی),!( منطقی"نه")
     4. **عملگر‌های تعیین مقدار:** شامل = (اپراتور تعیین مقدار), += (اضافه کردن و تعیین مقدار), – = (منها کردن و تعیین مقدار), \*= (ضرب و تعیین مقدار), /= (تقسیم و تعیین مقدار), %= (باقی مانده و تعیین مقدار)
     5. **اپراتور سه تایی:** شامل اپراتور‌های شرطی سه تایی
     6. **اپراتور تایپ:** از اون برای پیدا کردن تایپ متغیر‌ها استفاده می‌شه به صورت `typeof variable`

     **[فهرست](#فهرست)**

185. ### پارامتر rest چیکار میکنه؟

     پارامتر `Rest` یه روش بهبود یافته برای مدیریت پارامترهای تابع هستش که به ما امکان میده تعداد نامحدودی از آرگومان‌ها رو به عنوان یه آرایه دریافت کنیم:

     <span dir="ltr" align="left">

     ```js
     function f(a, b, ...theArgs) {
       // ...
     }
     ```

     </span>

     برای مثال، بیاین یه مثال مجموع برای محاسبه تعداد پویا پارامترها در نظر بگیریم،

     <span dir="ltr" align="left">

     ```js
     function total(...args) {
       let sum = 0;
       for (let i of args) {
         sum += i;
       }
       return sum;
     }
     console.log(fun(1, 2)); //3
     console.log(fun(1, 2, 3)); //6
     console.log(fun(1, 2, 3, 4)); //13
     console.log(fun(1, 2, 3, 4, 5)); //15
     ```

     </span>

     **نکته:** پارامتر`Rest` در ES6 به استاندارد جاوااسکریپت اضافه شد

     **[فهرست](#فهرست)**

186. ### اگه پارامتر rest رو به عنوان آخرین پارامتر استفاده نکنیم چی می‌شه؟

     پارامتر `Rest` چون وظیفه اش جمع آوری تمام آرگومان‌های باقی مونده تو یه آرایه اس پس باید همیشه آخرین پارامتر باشه. برای مثال، اگه تابعیو مثل کد زیر تعریف کنیم معنی نداره و یه خطا ایجاد میکنه:

     <span dir="ltr" align="left">

     ```js
     function someFunc(a,...b,c){
          //You code goes here
          return;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

187. ### عملگرهای منطقی باینری توی جاواسکریپت کدوما هستن؟

     1. به صورت بیتی AND ( & )
     2. به صورت بیتی OR ( | )
     3. به صورت بیتی XOR ( ^ )
     4. به صورت بیتی NOT ( ~ )
     5. تغییر مکان به چپ ( << )
     6. علامت در حال انتشار به سمت راست ( >> )
     7. صفر پر کردن Shift راست ( >>> )

     **[فهرست](#فهرست)**

188. ### عملگر spread چیکار میکنه؟

     عملگر Spread به تکرارپذیرها (آرایه‌ها / اشیاء / رشته‌ها) اجازه میده تا به آرگومان‌ها / عناصر منفرد گسترش پیدا کنن. برای مشاهده این رفتار مثالی بزنیم:

     <span dir="ltr" align="left">

     ```js
     function calculateSum(x, y, z) {
       return x + y + z;
     }

     const numbers = [1, 2, 3];

     console.log(calculateSum(...numbers)); // 6
     ```

     </span>

     **[فهرست](#فهرست)**

189. ### چطوری تشخیص میدی که یه آبجکت freeze شده یا نه؟

     متد `Object.isFrozen` برای تعیین اینکه آیا یه آبجکت منجمد هس یا نه استفاده می‌شه. اگه همه شرایط زیر درست باشه، یه آبجکت منجمد می‌شه.

     1. اگه قابل توسعه نباشه.
     2. اگه تمام خصوصیاتش غیر قابل تنظیم باشن.
     3. اگه تمام خصوصیات داده اون غیر قابل نوشتن باشه.

     <span dir="ltr" align="left">

     ```js
     const object = {
       property: "Welcome JS world",
     };
     Object.freeze(object);
     console.log(Object.isFrozen(object));
     ```

     </span>

     **[فهرست](#فهرست)**

190. ### چطوری بررسی کنیم که دو تا مقدار(شامل آبجکت) با هم برابرن یا نه؟

     متد `Object.is` تعیین میکنه که آیا دو مقدار یه مقدار هستن یا نه. برای مثال، استفاده با انواع مختلف مقادیر،

     <span dir="ltr" align="left">

     ```js
     Object.is("hello", "hello"); // true
     Object.is(window, window); // true
     Object.is([], []); // false
     ```

     </span>

     اگه یکی از موارد زیر برقرار باشه، دو مقدار یکسان در نظر گرفته میشه:

     1. هردو undefined
     2. هردو null
     3. هردو true یا هر دو false
     4. هر دو رشته با طول یکسان با کاراکترهای مشابه به ترتیب یکسان
     5. هر دو یه آبجکت (یعنی هر دو شی رفرنس یکسان دارن)
     6. هر دو عدد و
        هر دو +0
        هر دو -0
        هر دو NaN
        هر دو غیر صفر و هر دو NaN نیستن و هر دو دارای یه مقدار هستن.

     **[فهرست](#فهرست)**

191. ### هدف از متد is روی object چیه؟

     برای مقایسه دو رشته یا عدد و یا آبجکت با همدیگه و یا پیدا کردن قطبیت دو عدد استفاده میشه:

     **[فهرست](#فهرست)**

192. ### چطوری propertyهای یه object رو به یه object دیگه کپی می‌کنی؟

     می‌تونیم از متد `Object.assign` استفاده کنیم که برای کپی کردن مقادیر و ویژگی‌ها از یه یا چند آبجکت منبع به یه آبجکت هدف استفاده می‌شه. آبجکت مورد نظر رو که دارای خواص و مقادیر کپی شده از آبجکت اولیه اس رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     Object.assign(target, ...sources);
     ```

     </span>

     بیاین با یه منبع و یه شی هدف مثال بزنیم،

     <span dir="ltr" align="left">

     ```js
     const target = { a: 1, b: 2 };
     const source = { b: 3, c: 4 };

     const returnedTarget = Object.assign(target, source);

     console.log(target); // { a: 1, b: 3, c: 4 }

     console.log(returnedTarget); // { a: 1, b: 3, c: 4 }
     ```

     </span>

     همونطور که در کد بالا مشاهده شد، یه ویژگی مشترک (`b`) از منبع به مقصد وجود داره، بنابراین مقداش بازنویسی شده.

     **[فهرست](#فهرست)**

193. ### کاربردهای متد assign چیه؟

     1. برای شبیه سازی یه آبجکت .
     2. برای ادغام آبجکت‌ها با ویژگی‌های یکسان .

     **[فهرست](#فهرست)**

194. ### آبجکت proxy چیه؟

     آبجکت Proxy برای تعریف رفتار سفارشی برای عملیات‌های اساسی مثل جستجوی ویژگی، تخصیص، شمارش، فراخوانی تابع و غیره استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const p = new Proxy(target, handler);
     ```

     </span>

     بیاین مثالی از شیء پروکسی بزنیم،

     <span dir="ltr" align="left">

     ```js
     const handler = {
       get(obj, prop) {
         return prop in obj ? obj[prop] : 100;
       },
     };

     const p = new Proxy({}, handler);
     p.a = 10;
     p.b = null;

     console.log(p.a, p.b); // 10, null
     console.log("c" in p, p.c); // false, 100
     ```

     </span>

     در کد بالا، از کنترل‌کننده «get» استفاده میکنه که رفتار پراکسی رو موقع انجام عملیات روی اون تعریف میکنه.

     **[فهرست](#فهرست)**

195. ### هدف از متد seal چیه؟

     روش **Object.seal** برای مهر و موم کردن یه آبجکت با جلوگیری از اضافه شدن ویژگی‌های جدید بهش و علامت گذاری تمام ویژگی‌های موجود به عنوان غیر قابل تنظیم، استفاده می‌شه. اما مقادیر پراپرتی‌های فعلی تا زمانی که قابل نوشتن باشن , قابل تغییر هستن. بیاین مثال زیرو برای درک بیشتر در مورد روش seal ببینیم

     <span dir="ltr" align="left">

     ```js
     const object = {
       property: "Welcome JS world",
     };
     Object.seal(object);
     object.property = "Welcome to object world";
     console.log(Object.isSealed(object)); // true
     delete object.property; // You cannot delete when sealed
     console.log(object.property); // Welcome to object world
     ```

     </span>

     **[فهرست](#فهرست)**

196. ### کاربردهای متد seal چیه؟

     1. برای آب بندی آبجکت‌ها و آرایه‌ها استفاده می‌شه.
     2. برای غیرقابل تغییر کردن یه آبجکت استفاده می‌شه.

     **[فهرست](#فهرست)**

197. ### تفاوت‌های بین متدهای freeze و seal چیا هست؟

     اگه یه آبجکت با استفاده از متد `Object.freeze` منجمد شه، ویژگی‌هاش تغییرناپذیر می‌شن و هیچ تغییری در اونا نمیتونیم ایجاد کنیم در حالی که اگه یه آبجکت با استفاده از متد `Object.seal` مهر و موم شده باشه، می‌شه تغییرات روی ویژگی‌های موجود ایجاد کرد.

     **[فهرست](#فهرست)**

198. ### چطوری تشخیص میدی که یه آبجکت seal شده یا نه؟

     متد `Object.isSealed` برای تعیین مهر و موم بودن یا نبودن یه آبجکت استفاده می‌شه. اگه همه شرایط زیر درست باشه یه شی مهر و موم می‌شه

     1. اگه قابل توسعه نباشه.
     2. اگه تمام خصوصیات اون غیر قابل تنظیم باشن.
     3. اگه قابل جابجایی نباشه (اما لزوماً غیرقابل نوشتن نیست).
        بیاین اونو در عمل ببینیم:

     <span dir="ltr" align="left">

     ```js
     const object = {
       property: "Hello, Good morning",
     };

     Object.seal(object); // Using seal() method to seal the object

     console.log(Object.isSealed(object)); // checking whether the object is sealed or not
     ```

     </span>

     **[فهرست](#فهرست)**

199. ### چطوری کلید و مقدارهای enumerable رو به دست میاری؟

     متد `Object.entries` برای برگردوندن آرایه‌ای از جفت‌های [key, value] دارای کلید رشته‌ای شمارش‌پذیر یه شی معین، به همون ترتیبی که توسط یه حلقه for...in ارائه می‌شه، استفاده می‌شه. بیاین عملکرد متد `object.entries` رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const object = {
       a: "Good morning",
       b: 100,
     };

     for (const [key, value] of Object.entries(object)) {
       console.log(`${key}: ${value}`);
       // a: 'Good morning'
       // b: 100
     }
     ```

     </span>

     **نکته:** ترتیب به عنوان آبجکت تعریف شده تضمین نمی‌شه.

200. ### تفاوت‌های بین متدهای Object.values و Object.entries چیا هست؟

     رفتار متد `Object.values` مشابه روش `Object.entries` هست اما به جای جفت [key,value] آرایه ای از مقادیر را برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     const object = {
       a: "Good morning",
       b: 100,
     };

     for (const value of Object.values(object)) {
       console.log(`${value}`); // 'Good morning' 100
     }
     ```

     </span>

     **[فهرست](#فهرست)**

201. ### چطوری لیست کلیدهای یه object رو بدست میاری؟

     می‌تونیم از متد `Object.keys` استفاده کنیم که برای برگردوندن آرایه‌ای از اسم ویژگی‌های یه آبجکت معین استفاده می‌شه، به همون ترتیبی که با یه حلقه معمولی دریافت می‌کنیم. برای مثال:

     <span dir="ltr" align="left">

     ```js
     const user = {
       name: "John",
       gender: "male",
       age: 40,
     };

     console.log(Object.keys(user)); // ['name', 'gender', 'age']
     ```

     </span>

     **[فهرست](#فهرست)**

202. ### چطوری یه object با prototype درست می‌کنی؟

     متد `Object.create` برای ایجاد یه object جدید با object prototype و ویژگی‌های مشخص شده استفاده می‌شه. برای مثال، از یه object موجود به عنوان prototype object جدید ایجاد شده استفاده میکنه. یه object جدید رو با object prototype و ویژگی‌های مشخص شده برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     const user = {
       name: "John",
       printInfo() {
         console.log(`My name is ${this.name}.`);
       },
     };

     const admin = Object.create(user);

     admin.name = "Nick"; // Remember that "name" is a property set on "admin" but not on "user" object

     admin.printInfo(); // My name is Nick
     ```

     </span>

     **[فهرست](#فهرست)**

203. ### WeakSet چیه؟

     WeakSet برای ذخیره مجموعه ای از اشیاء ضعیف (مرجع ضعیف) استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     new WeakSet([iterable]);
     ```

     </span>

     بیاین مثال زیرو برای توضیح رفتارش ببینیم،

     <span dir="ltr" align="left">

     ```js
     const ws = new WeakSet();
     const user = {};
     ws.add(user);
     ws.has(user); // true
     ws.delete(user); // removes user from the set
     ws.has(user); // false, user has been removed
     ```

     </span>

     **[فهرست](#فهرست)**

204. ### تفاوت‌های بین WeakSet و Set کدوما هستن؟

     تفاوت اصلی اینه که ارجاع به اشیاء تو Set قویه در حالی که ارجاع به اشیا تو WeakSet ضعیفه. برای مثال، یه شی تو WeakSet میتونه زباله جمع آوری شه اگه مرجع دیگری به اون وجود نداشته باشه.
     تفاوت‌های دیگر عبارتند از

     1. مجموعه‌ها میتونن هر مقداری رو ذخیره کنن در حالی که WeakSets میتونه تنها مجموعه ای از اشیاء رو ذخیره کنه
     2. WeakSet برخلاف Set دارای ویژگی اندازه نیست
     3. WeakSet متدهایی مانند پاک کردن، کلیدها، مقادیر، ورودی‌ها، forEach رو نداره.
     4. WeakSet قابل تکرار نیست.

     **[فهرست](#فهرست)**

205. ### لیست متدهایی که رو WeakSet قابل استفاده هستن رو می‌تونی بگی؟

     در زیر لیستی از روش‌های موجود در WeakSet آمده است،

     1. add(value): یه شی جدید با مقدار داده شده به مجموعه ضعیف اضافه می‌شه
     2. delete(value): مقدار رو از مجموعه WeakSet حذف میکنه.
     3. has(value): اگه مقدار در مجموعه WeakSet وجود داشته باشه true رو برمی‌گردونه در غیر این صورت false رو برمی‌گردونه.
     4. length: طول ضعیف SetObject رو برمی‌گردونه
        بیاین عملکرد تمام روش‌های بالا رو توی یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const weakSetObject = new WeakSet();
     const firstObject = {};
     const secondObject = {};
     // add(value)
     weakSetObject.add(firstObject);
     weakSetObject.add(secondObject);
     console.log(weakSetObject.has(firstObject)); // true
     console.log(weakSetObject.length()); // 2
     weakSetObject.delete(secondObject);
     ```

     </span>

     **[فهرست](#فهرست)**

206. ### WeakMap چیه؟

     آبجکت WeakMap مجموعه ای از جفت‌های کلید/مقداره که تو اون کلیدها به صورت ضعیف ارجاع داده شدن. در این حالت، کلیدها باید اشیا باشن و مقادیر میتونن مقادیر دلخواه باشن.برای مثال:

     <span dir="ltr" align="left">

     ```js
     new WeakMap([iterable]);
     ```

     </span>

     بیاین مثال زیرو برای توضیح رفتار اون ببینیم،

     <span dir="ltr" align="left">

     ```js
     const ws = new WeakMap();
     const user = {};
     ws.set(user);
     ws.has(user); // true
     ws.delete(user); // removes user from the map
     ws.has(user); // false, user has been removed
     ```

     </span>

     **[فهرست](#فهرست)**

207. ### تفاوت‌های بین WeakMap و Map کدوما هستن؟

     تفاوت اصلی اینه که ارجاعات به آبجکت‌ها کلیدی در نقشه قوی هستن در حالی که ارجاعات به اشیاء کلیدی در WeakMap ضعیف هستن. برای مثال، یه شی کلیدی در WeakMap در صورتی که هیچ مرجع دیگری بهش وجود نداشته باشه، میتونه زباله جمع آوری شه.
     تفاوت‌های دیگر عبارتند از

     1. Map‌ها میتونن هر نوع کلیدی رو ذخیره کنن، در حالی که WeakMaps فقط میتونه مجموعه ای از اشیاء کلیدی رو ذخیره کنه
     2. WeakMap برخلاف Map دارای ویژگی size نیست
     3. WeakMap متدهایی مثل clear, keys, values, entries forEach رو نداره.
     4. WeakMap قابل تکرار نیست.

     **[فهرست](#فهرست)**

208. ### لیست متدهایی که رو WeakMap قابل استفاده هستن رو می‌تونی بگی؟

     1. set(key, value): مقدار کلید رو در آبجکت WeakMap تنظیم میکنه. آبجکت WeakMap رو برمی‌گردونه.
     2. delete(key): هر مقدار مربوط به کلید رو حذف میکنه.
     3. has(key): یه Boolean رو برمی‌گردونه که نشون میده آیا مقداری به کلید در آبجکت WeakMap مرتبط شده اس یا نه.
     4. get(key): مقدار مربوط به کلید رو برمی‌گردونه، یا اگه کلیدی وجود نداشته باشه، تعریف نشده.
        بیاین عملکرد تمام روش‌های بالا رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const weakMapObject = new WeakMap();
     const firstObject = {};
     const secondObject = {};
     // set(key, value)
     weakMapObject.set(firstObject, "John");
     weakMapObject.set(secondObject, 100);
     console.log(weakMapObject.has(firstObject)); // true
     console.log(weakMapObject.get(firstObject)); // John
     weakMapObject.delete(secondObject);
     ```

     </span>

     **[فهرست](#فهرست)**

209. ### هدف از متد uneval چیه؟

     `uneval` یه تابع داخلی‌ـه که برای ایجاد نمایش رشته‌ای از کد منبع یه شی استفاده می‌شه. این یه تابع سطح بالاس و با هیچ آبجکت‌ای مرتبط نیست. بیاین مثال زیر رو درموردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     const a = 1;
     uneval(a); // returns a String containing 1
     uneval(() => {}); // returns "(function user(){})"
     ```

     </span>

     **[فهرست](#فهرست)**

210. ### چطوری یه URL رو encode می‌کنی؟

     تابع `encodeURI` برای رمزگذاری URI کامل استفاده می‌شه که دارای کاراکترهای خاص به جز (, / ? : @ & = + $ #) هست.

     <span dir="ltr" align="left">

     ```js
     const uri = "https://mozilla.org/?x=шеллы";
     const encoded = encodeURI(uri);
     console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     ```

     </span>

     **[فهرست](#فهرست)**

211. ### چطوری یه URL رو decode می‌کنی؟

     تابع `decodeURI` برای رمزگشایی یه شناسه منبع یکنواخت (URI) که قبلا توسط encodeURI ایجاد شده اس، استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const uri = "https://mozilla.org/?x=шеллы";
     const encoded = encodeURI(uri);
     console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     try {
       console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
     } catch (e) {
       // catches a malformed URI
       console.error(e);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

212. ### چطوری محتوای یه صفحه رو پرینت می‌گیری؟

     آبجکت window یه متد print ارائه میکنه که برای چاپ محتویات پنجره فعلی استفاده می‌شه. یه کادر محاوره ای چاپ رو باز میکنه که بهمون این امکان رو میده که بین گزینه‌های مختلف برای چاپ انتخاب کنیم. بیاین استفاده از روش چاپ رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```html
     <input type="button" value="Print" onclick="window.print()" />
     ```

     </span>

     **نکته:** بیشتر مرورگرها، زمانی که کادر چاپ بازه صفحه قفل می‌شه.

     **[فهرست](#فهرست)**

213. ### تفاوت‌های بین uneval و eval چیا هستن؟

     تابع 'uneval' منبع یه شی معین رو برمی‌گردونه. در حالی که تابع "eval" با ارزیابی اون کد منبع تو یه ناحیه حافظه متفاوت، برعکس عمل میکنه. بیاین مثالی رو برای روشن شدن تفاوت ببینیم،

     <span dir="ltr" align="left">

     ```js
     const msg = uneval(() => "Hello, Good morning");
     const greeting = eval(msg);
     greeting(); // returns "Hello, Good morning"
     ```

     </span>

     **[فهرست](#فهرست)**

214. ### تابع anonymous چیه؟

     تابع ناشناس یه تابع بدون اسمه! توابع ناشناس معمولاً به یه نام متغیر اختصاص داده میشن یا به عنوان یه تابع callback استفاده میشن بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```js
     function (optionalParameters) {
       //do something
     }

     const myFunction = function(){ //Anonymous function assigned to a variable
       //do something
     };

     [1, 2, 3].map(function(element){ //Anonymous function used as a callback function
       //do something
     });
     ```

     </span>

     بیاین تابع ناشناس بالا رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const x = function (a, b) {
       return a * b;
     };
     const z = x(5, 10);
     console.log(z); // 50
     ```

     </span>

     **[فهرست](#فهرست)**

215. ### تفاوت تقدم بین متغیرهای local و global چطوریه؟

     یه متغیر local بر یه متغیر global با همون اسم ارجعیت داره. بیاین این رفتار رو تو یه مثال ببینیم.

     <span dir="ltr" align="left">

     ```js
     const msg = "Good morning";
     function greeting() {
       msg = "Good Evening";
       console.log(msg);
     }
     greeting();
     ```

     </span>

     **[فهرست](#فهرست)**

216. ### accessorهای جاواسکریپت چیکار می‌کنن؟

     ECMAScript 5 `accessor`‌های آبجکت جاواسکریپت یا ویژگی‌های محاسبه‌شده رو از طریق گیرنده‌ها و تنظیم‌کندنه‌ها معرفی کرد. Getters از کلمه کلیدی "get" استفاده میکنه در حالی که Setters از کلمه کلیدی "set" استفاده میکنه.

     <span dir="ltr" align="left">

     ```js
     const user = {
       firstName: "John",
       lastName : "Abraham",
       language : "en",
       get lang() {
         return this.language;
       }
       set lang(lang) {
       this.language = lang;
       }
     };
     console.log(user.lang); // getter access lang as en
     user.lang = 'fr';
     console.log(user.lang); // setter used to set lang as fr
     ```

     </span>

     **[فهرست](#فهرست)**

217. ### چطوری روی constructor یه Object یه مقدار تعریف می‌کنی؟

     متد استاتیک `Object.defineProperty` برای تعریف یه ویژگی جدید به طور مستقیم بر روی یه آبجکت یا تغییر ویژگی موجود روی یه آبجکت استفاده می‌شه و آبجکت رو برمی‌گردونه. بیاین مثالی رو ببینیم تا بدونیم چجوری ویژگی رو تعریف کنیم:

     <span dir="ltr" align="left">

     ```js
     const newObject = {};

     Object.defineProperty(newObject, "newProperty", {
       value: 100,
       writable: false,
     });

     console.log(newObject.newProperty); // 100

     newObject.newProperty = 200; // It throws an error in strict mode due to writable setting
     ```

     </span>

     **[فهرست](#فهرست)**

218. ### تفاوت‌های بین get و defineProperty چیا هست؟

     هر دو نتایج مشابهی دارن مگه اینکه از کلاس‌ها استفاده کنیم. اگه از «get» استفاده می‌کنیم ویژگی روی prototype شی تعریف می‌شه، در حالی که با استفاده از `Object.defineProperty`، ویژگی روی نمونه‌ای که بهش اعمال می‌شه، تعریف می‌شه.

     **[فهرست](#فهرست)**

219. ### مزایای استفاده از Getter و Setter چیه؟

     1. اونا syntax ساده تری ارائه میدن
     2. اونا برای تعریف ویژگی‌های محاسبه شده یا دسترسی‌ها در JS استفاده میشن
     3. برای ارائه رابطه هم ارزی بین خواص و روش‌ها مفیدن
     4. اونا میتونن کیفیت داده‌های بهتری رو ارائه بدن
     5. برای انجام کارها در پشت صحنه با منطق محصور شده مفیدن.

     **[فهرست](#فهرست)**

220. ### می‌تونیم getter و setter رو با استفاده از متد defineProperty تعریف کنیم؟

     بله، می‌تونیم از روش `Object.defineProperty` برای اضافه کردن Getters و Setter استفاده کنیم. برای مثال،آبجکت شمارنده زیر از ویژگی‌های افزایش، کاهش، جمع و تفریق استفاده میکنه:

     <span dir="ltr" align="left">

     ```js
     const obj = { counter: 0 };

     // Define getters
     Object.defineProperty(obj, "increment", {
       get() {
         this.counter++;
       },
     });
     Object.defineProperty(obj, "decrement", {
       get() {
         this.counter--;
       },
     });

     // Define setters
     Object.defineProperty(obj, "add", {
       set(value) {
         this.counter += value;
       },
     });
     Object.defineProperty(obj, "subtract", {
       set(value) {
         this.counter -= value;
       },
     });

     obj.add = 10;
     obj.subtract = 5;
     console.log(obj.increment); // 6
     console.log(obj.decrement); // 5
     ```

     </span>

     **[فهرست](#فهرست)**

221. ### هدف استفاده از switch-case چیه؟

     عبارت `switch case` تو جاواسکریپت برای اهداف تصمیم گیری استفاده می‌شه. توی چند مورد، استفاده از دستور switch case راحت‌تر از if-else هست. بریم یه مثال در موردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     switch (expression)
     {
         case value1:
             statement1;
             break;
         case value2:
             statement2;
             break;
         .
         .
         case valueN:
             statementN;
             break;
         default:
             statementDefault;
     }
     ```

     </span>

     دستور چند حالته بالا یه راه آسون برای انجام عملیات مختلف بهمون میده که بر اساس مقدار مبنا میشه عملکرد‌های مختلفی رو در نظر گرفت.

     **[فهرست](#فهرست)**

222. ### چه قواعدی برای استفاده از swtich-case باید رعایت بشه؟

     1. عبارت میتونه از نوع عددی یا رشته‌ای باشه.
     2. مقادیر تکراری برای عبارت مجاز نیستن.
     3. بیانیه default اختیاریه. اگه عبارت ارسال شده به سوئیچ با هیچ مقدار case مطابقت نداشته باشه، دستور تو حالت پیش فرض اجرا میشه.
     4. دستور break در داخل سوئیچ برای پایان دادن به دنباله دستور استفاده می‌شه.
     5. عبارت break اختیاریه. اما اگه حذف شه، اجرا در مورد بعدی ادامه پیدا میکنه

     **[فهرست](#فهرست)**

223. ### نوع داده‌های primitive کدوما هستن؟

     یه نوع داده `primitive` داده‌ایه که دارای یه مقدار اولیه اس (که هیچ ویژگی یا روشی نداره). 5 نوع نوع داده اولیه وجود داره.

     1. string
     2. number
     3. boolean
     4. null
     5. undefined

     **[فهرست](#فهرست)**

224. ### روش‌های مختلف دسترسی به propertyهای object کدوما هستن؟

     1. **دسترسی با نقطه:** از نقطه برای دسترسی به ویژگی‌ها استفاده میکنه

     <span dir="ltr" align="left">

     ```js
     objectName.property;
     ```

     </span>

     1. **دسترسی با کروشه:** از کروشه برای دسترسی به دیتا استفاده میکنه

     <span dir="ltr" align="left">

     ```js
     objectName.property;
     ```

     </span>

     1. **دسترسی عبارتی:** از عبارت توی کروشه استفاده میکنه

     <span dir="ltr" align="left">

     ```js
     objectName[expression];
     ```

     </span>

     **[فهرست](#فهرست)**

225. ### قوانین پارامترهای توابع کدوما هستن؟

     1. تعاریف تابع انواع داده‌ها رو برای پارامترها مشخص نمیکنه.
     2. بررسی نوع آرگومان‌های ارسال شده رو انجام ندین.
     3. تعداد آرگومان‌های دریافتی رو بررسی نکنیم.
        تابع زیر از قوانین بالا پیروی میکنه،

     <span dir="ltr" align="left">

     ```js
     function functionName(parameter1, parameter2, parameter3) {
       console.log(parameter1); // 1
     }
     functionName(1);
     ```

     </span>

     **[فهرست](#فهرست)**

226. ### آبجکت error چیه؟

     `error object` یه آبجکت خطای داخلیه که موقع بروز خطا، اطلاعات خطا رو ارائه میده و این دو ویژگی رو داخلش داره: name و messge. برای مثال، تابع زیر جزئیات خطا رو ثبت میکنه:

     <span dir="ltr" align="left">

     ```js
     try {
       greeting("Welcome");
     } catch (err) {
       console.log(`${err.name}<br>${err.message}`);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

227. ### چه موقعی خطای syntax دریافت می‌کنیم؟

     اگه بخواییم کد رو با یه خطای syntax ارزیابی کنیم یه SyntaxError ارسال می‌شه. برای مثال، کد زیر برای پارامتر تابع یه خطای syntax ایجاد میکنه:

     <span dir="ltr" align="left">

     ```js
     try {
       eval("greeting('welcome)"); // Missing ' will produce an error
     } catch (err) {
       console.log(err.name);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

228. ### عنوان خطاهای مختلف که روی error-object برمیگردن کدوما هستن؟

     | نام خطا     | توضیحات                       |
     | ----------- | ----------------------------- | ------- |
     | EvalError   | خطایی تو تابع eval رخ داده    |
     | RangeError  | خطایی با عدد "خارج از محدوده" | رخ داده |
     | خطای مرجع   | خطا به دلیل ارجاع غیرقانونی   |
     | SyntaxError | خطای ناشی از خطای syntax      |
     | TypeError   | خطای ناشی از خطای type        |
     | خطای URIE   | یه خطا به دلیل encodeURI      |

     **[فهرست](#فهرست)**

229. ### عبارات مختلف که در هنگام مدیریت error استفاده میشن کدوما هستن؟

     1. **try:** این عبارت برای آزمایش یه بلوک کد برای خطاها استفاده می‌شه
     2. **catch:** این عبارت برای رسیدگی به خطا استفاده می‌شه
     3. **throw:** این عبارت برای ایجاد خطاهای سفارشی استفاده می‌شه.
     4. **finally:** این عبارت برای اجرای کد پس از تلاش و گرفتن بدون توجه به نتیجه استفاده می‌شه.

     **[فهرست](#فهرست)**

230. ### دو نوع مختلف حلقه‌ها تو جاواسکریپت کدوما هستن؟

     1. **حلقه‌های کنترل شده توسط ورودی:** تو این نوع حلقه، شرایط تست قبل از ورود به بدنه حلقه آزمایش می‌شه. برای مثال For Loop و while Loop تو این دسته قرار می‌گیرن.
     2. **حلقه‌های کنترل شده توسط خروجی:** در این نوع حلقه، شرایط تست در انتهای بدنه حلقه آزمایش یا ارزیابی می‌شه. یعنی بدنه حلقه حداقل یه بار بدون در نظر گرفتن شرایط تست true یا false اجرا می‌شه. برای مثال، حلقه do-while در این دسته قرار می‌گیره.

     **[فهرست](#فهرست)**

231. ### nodejs چیه؟

     Node.js یه پلتفرم سمت سروره که بر اساس زمان اجرا جاواسکریپت کروم برای ساخت آسان برنامه‌های شبکه سریع و مقیاس پذیر ساخته شده. این یه زمان اجرا I/O ناهمزمان مبتنی بر رویداد، غیر مسدود کننده اس که از موتور جاواسکریپت V8 گوگل و کتابخونه libuv استفاده میکنه.

     **[فهرست](#فهرست)**

232. ### آبجکت Intl چیه؟

     آبجکت `Intl` فضای نامی برای `ECMAScript Internationalization` API اس که مقایسه رشته‌های حساس زبان، قالب بندی اعداد و قالب بندی تاریخ و زمان رو ارائه میده. دسترسی به چندین سازنده و توابع حساس به زبان رو فراهم میکنه.

     **[فهرست](#فهرست)**

233. ### چطوری تاریخ و زمان رو بر اساس زبان جاری سیستم کاربر نمایش بدیم؟

     می‌تونیم از کلاس `Intl.DateTimeFormat` استفاده کنیم که سازنده آبجکت‌هاییه که قالب بندی تاریخ و زمان حساس به زبان رو فعال میکنه. بیاین این رفتار رو با یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     var date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));
     console.log(new Intl.DateTimeFormat("en-GB").format(date)); // 07/08/2019
     console.log(new Intl.DateTimeFormat("en-AU").format(date)); // 07/08/2019
     ```

     </span>

     **[فهرست](#فهرست)**

234. ### Iterator چیه؟

     `Iterator` آبجکت‌ای‌ـه که پس از خاتمه، یه توالی و یه مقدار بازگشتی رو تعریف میکنه. پروتکل Iterator رو با متد «next» پیاده‌سازی میکنه که یه شی رو با دو ویژگی برمی‌گردونه: «value» (مقدار بعدی در دنباله) و «done» (که اگه آخرین مقدار در دنباله مصرف شده باشه درسته. ).

     **[فهرست](#فهرست)**

235. ### حلقه‌های synchronous(همزمان) چطوری کار می‌کنن؟

     تکرار همزمان در ES6 معرفی شد و با مجموعه ای از اجزای زیر کار میکنه:

     **Iterable:** این یه آبجکت‌ای‌ـه که میتونه از طریق روشی که کلید اون Symbol.iterator هس تکرار شه.
     **Iterator:** این یه آبجکت‌ای‌ـه که با فراخوانی «[Symbol.iterator]» بر روی یه تکرار برگردونده می‌شه. این آبجکت تکرار شونده هر عنصر تکرار شده رو تو یه آبجکت پیچیده میکنه و اونو از طریق متد «next» یکی یکی برمی‌گردونه.
     **IteratorResult:** این یه آبجکت‌ای‌ـه که با متد «next» برگردونده می‌شه. آبجکت شامل دو ویژگی است. ویژگی "value" حاوی یه عنصر تکرار شده و ویژگی "done" تعیین میکنه که آیا عنصر آخرین عنصر هست یا نه.

     بیاین تکرار همزمان رو با آرایه ای مانند زیر نشون بدیم،

     <span dir="ltr" align="left">

     ```js
     const iterable = ["one", "two", "three"];
     const iterator = iterable[Symbol.iterator]();
     console.log(iterator.next()); // { value: 'one', done: false }
     console.log(iterator.next()); // { value: 'two', done: false }
     console.log(iterator.next()); // { value: 'three', done: false }
     console.log(iterator.next()); // { value: 'undefined, done: true }
     ```

     </span>

     **[فهرست](#فهرست)**

236. ### Event-loop چیه؟

     `event loop` یه صف از توابع callback موقعی که یه تابع async اجرا می‌شه، تابع callback در صف قرار می‌گیرد. موتور جاواسکریپت پردازش حلقه رویداد رو شروع نمیکنه تا زمانی که تابع async اجرای کد رو تموم کنه.

     **نکته:** این به Node.js اجازه میده تا عملیات I/O غیر مسدود کننده رو انجام بده حتی اگه جاواسکریپت تک رشته‌ای باشه.

     **[فهرست](#فهرست)**

237. ### Call-stack چیه؟

     Call Stack یه ساختار داده برای مفسران جاواسکریپت‌ـه تا فراخونی‌های تابع تو برنامه رو پیگیری کنه و دو عمل عمده داره،

     1. هر زمان که یه تابع رو برای اجرای آن فراخوانی می‌کنیم اونو به `stack` هدایت می‌شه.
     2. هر زمان که اجرا کد تموم شه، تابع از `stack` خارج می‌شه.

     بیاین یه مثال و توضیح خلاصه اون در قالب نمودار رو باهم ببینیم:

     <span dir="ltr" align="left">

     ```js
     function hungry() {
       eatFruits();
     }
     function eatFruits() {
       return "I'm eating fruits";
     }

     // Invoke the `hungry` function
     hungry();
     ```

     </span>

     کد بالا تو یه call-stack به صورت زیر پردازش می‌شه.

     1. تابع 'hungry' رو به لیست call-stack اضافه میشه و کد رو اجرا میشه.
     2. تابع 'eatFruits' رو به لیست call-stack اضافه میشه و کد رو اجرا میشه.
     3. تابع 'eatFruits' از لیست call-stack ما حذف میشه.
     4. تابع 'eatFruits' از لیست call-stack ما حذف میشه.

     ![Screenshot](images/call-stack.png)

     **[فهرست](#فهرست)**

238. ### Event-queue چیه؟

     `Event-queue` مسئول ارسال توابع جدید به stack برای پردازشه. ساختارش به صورت صف داده اس تا توالی درستی رو نگه داره و همه عملیات باید برای اجرا ارسال شن.

     **[فهرست](#فهرست)**

239. ### Decorator چیه؟

     `Decorator` عبارتیه که یه تابع رو ارزیابی میکنه و هدف، نام و توصیف‌کننده تزئین رو به عنوان آرگومان می‌گیره. همچنین، به صورت اختیاری یه توصیفگر دکوراتور رو برای نصب بر روی آبجکت مورد نظر برمی‌گردونه. بیاین در زمان طراحی، دکوراتور ادمین رو برای کلاس کاربر تعریف کنیم:

     <span dir="ltr" align="left">

     ```js
     function admin(isAdmin) {
        return function(target) {
            target.isAdmin = isAdmin;
        }
     }

     @admin(true)
     class User() {
     }
     console.log(User.isAdmin); //true

      @admin(false)
      class User() {
      }
      console.log(User.isAdmin); //false
     ```

     </span>

     **[فهرست](#فهرست)**

240. ### مقادیر موجود روی آبجکت Intl کدوما هستن؟

     1. **Collator:** آبجکت‌هایی هستن که مقایسه رشته‌های حساس به زبان رو امکان پذیر می‌کنن.
     2. **DateTimeFormat:** آبجکت‌هایی هستن که قالب بندی تاریخ و زمان حساس به زبان رو فعال می‌کنن.
     3. **ListFormat:** آبجکت‌هایی هستن که قالب بندی لیست حساس به زبان رو فعال می‌کنن.
     4. **NumberFormat:** آبجکت‌هایی که قالب بندی اعداد حساس به زبان رو فعال می‌کنن.
     5. **PluralRules:** آبجکت‌هایی که قالب بندی حساس به جمع و قوانین خاص زبان رو برای جمع فعال می‌کنن.
     6. **RelativeTimeFormat:** آبجکت‌هایی که قالب بندی زمان نسبی حساس به زبان رو فعال می‌کنن.

     **[فهرست](#فهرست)**

241. ### عملگر Unary چیه؟

     عملگر unary(+) برای تبدیل یه متغیر به عدد استفاده می‌شه. اگه متغیر قابل تبدیل نباشه، همچنان به عدد تبدیل می‌شه اما با مقدار NaN. بیاین این رفتار رو تو یه عمل ببینیم:

     <span dir="ltr" align="left">

     ```js
     const x = "100";
     const y = +x;
     console.log(typeof x, typeof y); // string, number

     const a = "Hello";
     const b = +a;
     console.log(typeof a, typeof b, b); // string, number, NaN
     ```

     </span>

     **[فهرست](#فهرست)**

242. ### چطوری المنت‌های موجود تو یه آرایه رو مرتب می‌کنی؟

     متد `sort` برای مرتب سازی عناصر یه آرایه در جای خود استفاده می‌شه و آرایه مرتب شده رو برمی‌گردونه. برای مثال

     <span dir="ltr" align="left">

     ```js
     const months = ["Aug", "Sep", "Jan", "June"];
     months.sort();
     console.log(months); //  ["Aug", "Jan", "June", "Sep"]
     ```

     </span>

     **[فهرست](#فهرست)**

243. ### هدف از تابع مرتب‌سازی موقع استفاده از متد sort چیه؟

     از `compareFunction` برای تعریف ترتیب مرتب سازی استفاده می‌شه. اگه حذف شه، عناصر آرایه به رشته تبدیل می‌شن، سپس بر اساس مقدار نقطه کد یونیک هر کاراکتر مرتب میشن بیاین مثالی بزنیم تا کاربرد compareFunction رو ببینیم،

     <span dir="ltr" align="left">

     ```js
     const numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     console.log(numbers); // [5, 4, 3, 2, 1]
     ```

     </span>

     **[فهرست](#فهرست)**

244. ### چطوری آیتم‌های یه آرایه رو معکوس مرتب کنیم؟

     برای معکوس کردن عناصر یه آرایه می‌تونیم از متد reverse استفاده کنیم. این روش برای مرتب کردن یه آرایه به ترتیب نزولی مفید است. بیاین استفاده از متد reverse رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     console.log(numbers); // [5 ,4 ,3 ,2 ,1]
     ```

     </span>

     **[فهرست](#فهرست)**

245. ### چطوری حداقل و حداکثر مقدار یه آرایه رو بدست بیاریم؟

     می‌تونیم از روش‌های `Math.mix` و `Math.max` روی متغیرهای آرایه برای یافتن حداقل و حداکثر عناصر تو یه آرایه استفاده کنیم. بیاین دو تابع برای پیدا کردن مقدار min و max تو یه آرایه ایجاد کنیم:

     <span dir="ltr" align="left">

     ```js
     const marks = [50, 20, 70, 60, 45, 30];
     function findMin(arr) {
       return Math.min(...arr)
     }
     function findMax(arr) {
       return Math.max(...arr));
     }

     console.log(findMin(marks));
     console.log(findMax(marks));
     ```

     </span>

     **[فهرست](#فهرست)**

246. ### چطوری حداقل و حداکثر مقدار یه آرایه رو بدون استفاده از متدهای Math بدست بیاریم؟

     ما میتونیم توابعی بنویسیم که تو یه آرایه حلقه می‌زنن و هر مقدار را با کمترین یا بالاترین مقدار مقایسه می‌کنن تا مقادیر حداقل و حداکثر رو پیدا کنن. بریم یه مثال درموردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     const marks = [50, 20, 70, 60, 45, 30];
     function findMin(arr) {
       let min = arr[0];
       for (let i = 0; i < arr.length; i++) {
         if (arr[i] < minNumber) {
           min = arr[i];
         }
       }
       return min;
     }

     function findMax(arr) {
       let max = arr[0];
       for (let i = 0; i < arr.length; i++) {
         if (arr[i] > minNumber) {
           max = arr[i];
         }
       }
       return max;
     }

     console.log(findMin(marks));
     console.log(findMax(marks));
     ```

     </span>

     **[فهرست](#فهرست)**

247. ### عبارت خالی چیه و هدف از استفاده ازش چیه؟

     سیمیکالن `;` هس که نشون میده هیچ دستوری اجرا نمیشه، حتی اگه syntax جاواسکریپت به اون نیاز داشته باشه. از اونجایی که هیچ اقدامی با دستور خالی وجود نداره، ممکنه فکر کنیم که استفاده از اون خیلی کمه اما دستور خالی موقعی مفیده که می‌خواین یه حلقه ایجاد کنیم که بدنه‌اش خالیه. برای مثال، می‌تونیم یه آرایه با مقادیر صفر رو مثل کد زیر مقداردهی اولیه کنیم.

     <span dir="ltr" align="left">

     ```js
     // Initialize an array a
     for(int i=0; i < a.length; a[i++] = 0) ;
     ```

     </span>

     **[فهرست](#فهرست)**

248. ### چطوری metadata یه ماژول رو بدست میاری؟

     میتونیم از آبجکت `import.meta` استفاده کنیم که یه ویژگی متاعه که متا داده‌های متنی خاص رو تو یه ماژول جاوا اسکریپت قرار می‌ده. این شامل اطلاعاتی در مورد ماژول فعلی، مانند URL ماژوله. در مرورگرها، ممکنه متا داده‌های متفاوتی نسبت به NodeJS دریافت کنیم.

     <span dir="ltr" align="left">

     ```html
     <script type="module" src="welcome-module.js"></script>

     <script>
       console.log(import.meta);
       // { url: "file:///home/user/welcome-module.js" }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

249. ### عملگر comma چیه و چیکار میکنه؟

     عملگر کاما برای ارزیابی هر یه از عملوندهاش از چپ به راست استفاده می‌شه و مقدار آخرین عملوند رو برمی‌گردونه. این کاملاً با استفاده از کاما در آرایه‌ها، اشیاء و آرگومان‌ها و پارامترهای تابع متفاوته. بریم یه مثال در موردش ببینیم.

     <span dir="ltr" align="left">

     ```js
     let x = 1;
     x = (x++, x);

     console.log(x); // 2
     ```

     </span>

     **[فهرست](#فهرست)**

250. ### مزایای استفاده از عملگر comma چیه؟

     معمولاً برای گنجوندن چن تا عبارت تو جایی که به یه عبارت واحد نیاز داره استفاده می‌شه. یکی از کاربردهای رایج این عملگر کاما، ارائه چندین پارامتر تو یه حلقه «for» اس. برای مثال، حلقه for زیر از چند عبارت تو یه مکان واحد با استفاده از عملگر کاما استفاده میکنه.

     <span dir="ltr" align="left">

     ```js
     for (var a = 0, b = 10; a <= 10; a++, b--) {}
     ```

     </span>

     همچنین می‌تونیم از عملگر کاما تو یه عبارت بازگشتی استفاده کنیم جایی که قبل از بازگشت پردازش میکنه.

     <span dir="ltr" align="left">

     ```js
     function myFunction() {
       let a = 1;
       return (a += 10), a; // 11
     }
     ```

     </span>

     **[فهرست](#فهرست)**

251. ### Typescript چیه؟

     TypeScript یه ابر مجموعه تایپ شده از جاواسکریپت‌ـه که توسط مایکروسافت ایجاد شده که انواع اختیاری، کلاس‌ها، async/wait و بسیاری ویژگی‌های دیگر رو اضافه میکنه و به جاواسکریپت ساده کامپایل میکنه. Angular به طور کامل در TypeScript ساخته شده و به عنوان زبان اصلی استفاده می‌شه. می‌تونیم اونو به صورت گلوبال نصب کنیم:

     <span dir="ltr" align="left">

     ```bash
     npm install -g typescript
     ```

     </span>

     بیاین یه مثال ساده از استفاده از TypeScript رو ببینیم،

     <span dir="ltr" align="left">

     ```typescript
     function greeting(name: string): string {
       return "Hello, " + name;
     }

     let user = "Ali Karimi";

     console.log(greeting(user));
     ```

     </span>

     متد `greeting` فقط نوع رشته رو به عنوان آرگومان مجاز میکنه.

     **[فهرست](#فهرست)**

252. ### تفاوت‌های بین javascript و typescript کدوما هستن؟

     | ویژگی              | typescript                                  | javascript                                    |
     | ------------------ | ------------------------------------------- | --------------------------------------------- |
     | پارادایم زبان      | زبان برنامه نویسی شی گرا                    | زبان اسکریپت                                  |
     | پشتیبانی از تایپ   | پشتیبانی از تایپ استاتیک                    | دارای تایپ پویا                               |
     | ماژول‌ها           | پشتیبانی شده                                | پشتیبانی نمی‌شه                               |
     | رابط               | دارای مفهوم رابط                            | از رابط‌ها پشتیبانی نمیکنه                    |
     | پارامترهای اختیاری | توابع از پارامترهای اختیاری پشتیبانی می‌کنن | عدم پشتیبانی از پارامترهای اختیاری برای توابع |

     **[فهرست](#فهرست)**

253. ### مزایای typescript نسبت به javascript چیاست؟

     1. TypeScript میتونه خطاهای زمان کامپایل رو فقط در زمان توسعه پیدا کنه و باعث می‌شه خطاهای زمان اجرا کمتر شه. در حالی که جاواسکریپت یه زبان تفسیر شده است.
     2. TypeScript به شدت تایپ می‌شه یا از تایپ استاتیک پشتیبانی میکنه که امکان بررسی صحت نوع رو در زمان کامپایل فراهم میکنه. این در جاواسکریپت در دسترس نیست.
     3. کامپایلر TypeScript برخلاف ویژگی‌های ES6 جاواسکریپت که ممکنه در بعضی از مرورگرها پشتیبانی نشه، میتونه فایل‌های .ts رو در ES3، ES4 و ES5 کامپایل کنه.

     **[فهرست](#فهرست)**

254. ### object-initializer چیه؟

     `object-initializer` عبارتیه که مقدار دهی اولیه یه آبجکت رو توصیف میکنه. syntax این عبارت به صورت فهرستی با کاما از صفر یا چند جفت نام ویژگی و مقادیر مرتبط یه آبجکت، محصور در براکت ({}) نشون داده می‌شه. این همچنین به عنوان نماد تحت اللفظی شناخته می‌شه. یکی از راه‌های ایجاد یه آبجکته.

     <span dir="ltr" align="left">

     ```js
     const initObject = { a: "John", b: 50, c: {} };

     console.log(initObject.a); // John
     ```

     </span>

     **[فهرست](#فهرست)**

255. ### متد constructor چیه؟

     متد `constructor` یه متد خاص برای ایجاد و مقداردهی اولیه یه آبجکت ایجاد شده تو یه کلاسه. اگه متد constructor رو مشخص نکنیم از constructor پیش فرض استفاده می‌شه. بریم یه مثال در موردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     class Employee {
       constructor() {
         this.name = "John";
       }
     }

     const employeeObject = new Employee();

     console.log(employeeObject.name); // John
     ```

     </span>

     **[فهرست](#فهرست)**

256. ### اگه متد constructor رو بیش از یه بار توی کلاس بنویسیم چی می‌شه؟

     `constructor` تو یه کلاس یه متد خاصه و باید فقط یه بار تو یه کلاس تعریف شه. اگه یه متد سازنده رو بیش از یه بار تو یه کلاس بنویسیم، یه خطای `SyntaxError` ایجاد میشه.

     <span dir="ltr" align="left">

     ```js
      class Employee {
        constructor() {
          this.name = "John";
        }
        constructor() {   //  Uncaught SyntaxError: A class may only have one constructor
          this.age = 30;
        }
      }

      const employeeObject = new Employee();

      console.log(employeeObject.name);
     ```

     </span>

     **[فهرست](#فهرست)**

257. ### چطوری متد constructor کلاس والد رو صدا بزنیم؟

     می‌تونیم از کلمه کلیدی `super` برای فراخوانی constructor کلاس والد استفاده کنیم. یادمون باشه که `super` باید قبل از استفاده از مرجع `this` فراخوانی شه. در غیر این صورت باعث خطای `Reference error` می‌شه. بیاین از اون استفاده کنیم:

     <span dir="ltr" align="left">

     ```js
     class Square extends Rectangle {
       constructor(length) {
         super(length, length);
         this.name = "Square";
       }

       get area() {
         return this.width * this.height;
       }

       set area(value) {
         this.area = value;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

258. ### چطوری prototype یه object رو به دست میاری؟

     می‌تونیم از روش `Object.getPrototypeOf`(obj) برای برگردوندن `prototype` آبجکت مشخص شده استفاده کنیم. یعنی مقدار ویژگی `prototype` داخلی. اگه هیچ ویژگی ارثی وجود نداشته باشه، مقدار `null` برگردونده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const newPrototype = {};
     const newObject = Object.create(newPrototype);

     console.log(Object.getPrototypeOf(newObject) === newPrototype); // true
     ```

     </span>

     **[فهرست](#فهرست)**

259. ### اگه به متد getPrototype رشته پاس بدیم چی می‌شه؟

     در ES5، اگه پارامتر obj یه آبجکت نباشه، یه استثنا TypeError ایجاد میکنه. در حالی که در ES2015، پارامتر به یه آبجکت اجباری تبدیل می‌شه.

     <span dir="ltr" align="left">

     ```js
     // ES5
     Object.getPrototypeOf("James"); // TypeError: "James" is not an object
     // ES2015
     Object.getPrototypeOf("James"); // String.prototype
     ```

     </span>

     **[فهرست](#فهرست)**

260. ### چطوری prototype یه object روی یه object دیگه ست کنیم؟

     می‌تونیم از متد `Object.setPrototypeOf` استفاده کنیم که prototype (یعنی ویژگی داخلی «Prototype») یه آبجکت مشخص شده رو روی یه آبجکت دیگه یا تهی تنظیم میکنه. برای مثال، اگه بخوایم prototype آبجکت Square رو روی آبجکت Rectangle تنظیم کنیم این شکلی میشه این کارو انجام داد:

     <span dir="ltr" align="left">

     ```js
     Object.setPrototypeOf(Square.prototype, Rectangle.prototype);
     Object.setPrototypeOf({}, null);
     ```

     </span>

     **[فهرست](#فهرست)**

261. ### چطوری بررسی می‌کنی که یه object قابل extend هست یا نه؟

     متد `Object.isExtensible` برای تعیین اینکه یه آبجکت قابل توسعه هس یا نه ( یعنی اینکه میتونه ویژگی‌های جدیدی به اون اضافه شه یا نه) استفاده میشه.

     <span dir="ltr" align="left">

     ```js
     const newObject = {};
     console.log(Object.isExtensible(newObject)); // true
     ```

     </span>

     **نکته:** به طور پیش فرض، همه ی آبجکت‌ها قابل گسترش هستن. برای مثال، ویژگی‌های جدید رو می‌تونیم اضافه یا تغییر بدیم.

     **[فهرست](#فهرست)**

262. ### چطوری جلوی extend یه object رو بگیریم؟

     متد `Object.preventExtensions` برای جلوگیری از افزودن ویژگی‌های جدید به یه آبجکت استفاده می‌شه. به عبارت دیگر، از پسوندهای بعدی به آبجکت جلوگیری میکنه. بیاین استفاده از این ویژگی رو ببینیم:

     <span dir="ltr" align="left">

     ```js
     const newObject = {};
     Object.preventExtensions(newObject); // NOT extendable

     try {
       Object.defineProperty(newObject, "newProperty", {
         // Adding new property
         value: 100,
       });
     } catch (e) {
       console.log(e); // TypeError: Cannot define property newProperty, object is not extensible
     }
     ```

     </span>

     **[فهرست](#فهرست)**

263. ### روش‌های مختلف برای تبدیل یه object به object غیرقابل extend چیه؟

     می‌تونیم یه آبجکت غیر قابل گسترش رو به 3 روش علامت گذاری کنیم.

     1. Object.preventExtensions
     2. Object.seal
     3. Object.freeze

     <span dir="ltr" align="left">

     ```js
     let newObject = {};

     Object.preventExtensions(newObject); // Prevent objects are non-extensible
     Object.isExtensible(newObject); // false

     let sealedObject = Object.seal({}); // Sealed objects are non-extensible
     Object.isExtensible(sealedObject); // false

     let frozenObject = Object.freeze({}); // Frozen objects are non-extensible
     Object.isExtensible(frozenObject); // false
     ```

     </span>

     **[فهرست](#فهرست)**

264. ### چطوری propertyهای متعددی رو روی یه object تعریف می‌کنی؟

     متد `Object.defineProperties` برای تعریف یا اصلاح ویژگی‌های موجود مستقیماً روی یه آبجکت و برگردوندن آبجکت استفاده می‌شه. بیاین چندین ویژگی رو روی یه آبجکت خالی تعریف کنیم:

     <span dir="ltr" align="left">

     ```js
     const newObject = {};

     Object.defineProperties(newObject, {
       newProperty1: {
         value: "John",
         writable: true,
       },
       newProperty2: {},
     });
     ```

     </span>

     **[فهرست](#فهرست)**

265. ### منظور از MEAN توی جاواسکریپت چیه؟

     دسته‌ MEAN (MongoDB، Express، AngularJS و Node.js) محبوب‌ترین دسته‌بندی فناوری نرم‌افزار جاواسکریپت منبع بازه که برای ساخت برنامه‌های وب پویا در دسترسه، جایی که می‌تونیم کدهای سمت سرور و سمت کلاینت پروژه وب رو کاملا با جاواسکریپت بنویسین.

     **[فهرست](#فهرست)**

266. ### Obfuscation توی جاواسکریپت چیه و چیکار میکنه؟

     `Obfuscation` عمل عمدی ایجاد کد جاواسکریپت مبهم (یعنی کد منبع یا ماشین) هس که درک اون برای انسان سخته. این چیزی شبیه به رمزگذاریه، اما یه ماشین میتونه کد رو درک کنه و اونو اجرا کنه.
     بیاین تابع زیر رو قبل از Obfuscation ببینیم،

     <span dir="ltr" align="left">

     ```js
     function greeting() {
       console.log("Hello, welcome to JS world");
     }
     ```

     </span>

     و بعد از کد Obfuscation به صورت زیر ظاهر می‌شه

     <span dir="ltr" align="left">

     ```js
     eval(
       (function (p, a, c, k, e, d) {
         e = function (c) {
           return c;
         };
         if (!"".replace(/^/, String)) {
           while (c--) {
             d[c] = k[c] || c;
           }
           k = [
             function (e) {
               return d[e];
             },
           ];
           e = function () {
             return "\\w+";
           };
           c = 1;
         }
         while (c--) {
           if (k[c]) {
             p = p.replace(new RegExp(`\\b${e(c)}\\b`, "g"), k[c]);
           }
         }
         return p;
       })(
         "2 1(){0.3('4, 7 6 5 8')}",
         9,
         9,
         "console|greeting|function|log|Hello|JS|to|welcome|world".split("|"),
         0,
         {}
       )
     );
     ```

     </span>

     **[فهرست](#فهرست)**

267. ### چه نیازی به Obfuscate کردن داریم؟

     1. اندازه کد کمتر میشه. که باعث انتقال سریع تر داده بین سرور و کلاینت میشه.
     2. این منطق کسب و کار رو از دنیای خارج پنهان میکنه و از کد در برابر دیگران محافظت میکنه
     3. مهندسی معکوس کردن کد رو سخت میکنه
     4. زمان دانلود کاهش پیدا میکنه

     **[فهرست](#فهرست)**

268. ### Minification چیه؟

     `Minification` حذف تمام کاراکترهای غیر ضروریه (فضاهای خالی حذف می‌شن) و متغیرها بدون تغییر در عملکر اون تغییر نام میدن همچنین برای مبهم سازی کد هم استفاده میشه.

     **[فهرست](#فهرست)**

269. ### مزایای minification یا کم حجم‌سازی چیه؟

     به طور معمول توصیه می‌شه برای ترافیک سنگین و نیازهای فشرده منابع از Minification استفاده کنیم. اندازه فایل رو با مزایای زیر کاهش میده

     1. زمان بارگذاری یه صفحه وب رو کاهش میده
     2. در مصرف پهنای باند صرفه جویی میکنه

     **[فهرست](#فهرست)**

270. ### تفاوت‌های بین Obfuscation و Encryption چیه؟

     | ویژگی               | Obfuscation                           | Encryption                                           |
     | ------------------- | ------------------------------------- | ---------------------------------------------------- |
     | تعریف               | تغییر فرم هر داده به هر شکل دیگر      | تغییر فرم اطلاعات به فرمت ناخوانا با استفاده از کلید |
     | کلیدی برای رمزگشایی | می‌شه اونو بدون هیچ کلید رمزگشایی کرد | برای رمز گشایی کلید لازمه                            |
     | فرمت داده‌های هدف   | به فرم پیچیده تبدیل می‌شه             | تبدیل به فرمت ناخوانا                                |

     **[فهرست](#فهرست)**

271. ### ابزارهای مختلف برای minification کدوما هستن؟

     1. کامپایلر بسته شدن گوگل
     2. UglifyJS2
     3. jsmin
     4. javascript-minifier.com/
     5. prettydiff.com

     **[فهرست](#فهرست)**

272. ### چطوری اعتبارسنجی فرم رو با javascript انجام میدی؟

     می‌شه از جاواسکریپت برای اعتبار سنجی فرم HTML استفاده کرد. برای مثال، اگه فیلد فرم خالی باشه، تابع باید اطلاع بده و false رو برگردونه تا از ارسال فرم جلوگیری شه.
     بریم ورود کاربر رو در فرم html انجام بدیم:

     <span dir="ltr" align="left">

     ```html
     <form name="myForm" onsubmit="return validateForm()" method="post">
       User name: <input type="text" name="uname" />
       <input type="submit" value="Submit" />
     </form>
     ```

     </span>

     و اعتبار سنجی ورود کاربر به این شکل هست.

     <span dir="ltr" align="left">

     ```js
     function validateForm() {
       const x = document.forms.myForm["uname"].value;
       if (x == "") {
         alert("The username shouldn't be empty");
         return false;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

273. ### چطوری اعتبارسنجی فرم رو بدون javascript انجام میدی؟

     می‌تونیم بدون استفاده از جاواسکریپت اعتبار سنجی فرم HTML رو به صورت خودکار انجام بدین. اعتبار سنجی با اعمال ویژگی `required` برای جلوگیری از ارسال فرم زمانی که ورودی خالیه فعال می‌شه.

     <span dir="ltr" align="left">

     ```html
     <form method="post">
       <input type="text" name="uname" required />
       <input type="submit" value="Submit" />
     </form>
     ```

     </span>

     **نکته:** اعتبار سنجی فرم خودکار برای IE9 یا ورژن‌های قبل از اون کار نمیکنه.

     **[فهرست](#فهرست)**

274. ### متدهای موجود روی DOM برای اعتبارسنجی کدوما هستن؟

     1. checkValidity: اگه یه عنصر ورودی حاوی داده‌های معتبر باشه، مقدار true رو برمی‌گردونه.
     2. setCustomValidity: برای تنظیم خاصیت validationMessage یه عنصر ورودی استفاده می‌شه.
        بیاین یه فرم ورود کاربر با اعتبارسنجی DOM بگیریم

     <span dir="ltr" align="left">

     ```js
     function myFunction() {
       let userName = document.getElementById("uname");
       if (!userName.checkValidity()) {
         document.getElementById("message").innerHTML =
           userName.validationMessage;
       } else {
         document.getElementById("message").innerHTML =
           "Entered a valid username";
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

275. ### مقادیر موجود روی DOM برای اعتبارسنجی کدوما هستن؟

     1. validity: فهرستی از ویژگی‌های بولین مربوط به اعتبار یه عنصر ورودی رو ارائه میده.
     2. validationMessage: زمانی که اعتبار نادرست باشه، پیام رو نمایش میده.
     3. willValidate: این نشون میده که آیا یه عنصر ورودی اعتبار سنجی می‌شه یا نه.

     **[فهرست](#فهرست)**

276. ### مقادیر موجود روی input برای اعتبارسنجی کدوما هستن؟

     ویژگی `validity` یه عنصر ورودی مجموعه ای از ویژگی‌های مربوط به اعتبارسنجی داده‌ها رو ارائه میده.

     1. customError: اگه یه پیام اعتبار سفارشی تنظیم شده باشه، true رو برمی‌گردونه.
     2. patternMismatch: اگه مقدار یه عنصر با ویژگی الگوی آن مطابقت نداشته باشه، مقدار true رو برمی‌گردونه.
     3. rangeOverflow: اگه مقدار یه عنصر از ویژگی max آن بیشتر باشه، مقدار true رو برمی‌گردونه.
     4. rangeUnderflow:اگه مقدار یه عنصر کمتر از ویژگی min باشه، مقدار true رو برمی‌گردونه.
     5. stepMismatch:اگه مقدار عنصر مطابق با ویژگی step نامعتبر باشه، مقدار true رو برمی‌گردونه.
     6. tooLong: اگه مقدار یه عنصر از ویژگی maxLength آن بیشتر شه، مقدار true رو برمی‌گردونه.
     7. typeMismatch: اگه مقدار یه عنصر بر اساس ویژگی نوع نامعتبر باشه، مقدار true رو برمی‌گردونه.
     8. valueMissing: اگه عنصری با ویژگی مورد نیاز ارزش نداشته باشه، مقدار true رو برمی‌گردونه.
     9. valid: اگه مقدار یه عنصر معتبر باشه، مقدار true رو برمی‌گردونه.

     **[فهرست](#فهرست)**

277. ### یه مثال از استفاده ویژگی rangeOverflow می‌تونی بزنی؟

     اگه مقدار یه عنصر از ویژگی max اون بیشتر باشه، ویژگی `rangeOverflow` مقدار true رو برمی‌گردونه. برای مثال، توی فرم پایین اگه مقدار ورودی بیش از 100 باشه، خطا میده.

     <span dir="ltr" align="left">

     ```html
     <input id="age" type="number" max="100" />
     <button onclick="myOverflowFunction()">OK</button>
     ```

     </span>

     <span dir="ltr" align="left">

     ```js
     function myOverflowFunction() {
       if (document.getElementById("age").validity.rangeOverflow) {
         alert("The mentioned age is not allowed");
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

278. ### جاواسکریپت قابلیت استفاده از enum رو پیش‌فرض توی خودش داره؟

     نه، جاواسکریپت به صورت بومی از `enum‌`ها پشتیبانی نمیکنه. اما انواع مختلفی از راه‌حل‌ها برای شبیه‌سازی اونا وجود داره، اگرچه ممکنه معادل‌های دقیقی ارائه نکنن. برای مثال، می‌تونیم از `freeze` یا `seal` روی آبجکت استفاده کنیم:

     <span dir="ltr" align="left">

     ```js
     const DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
     ```

     </span>

     **[فهرست](#فهرست)**

279. ### enum چیه؟

     `enum` نوعیه که متغیرها رو به یه مقدار از مجموعه ای از ثابت‌های از پیش تعریف شده محدود میکنه. جاواسکریپت هیچ enum نداره اما تایپ‌اسکریپت از enum داخلی پشتیبانی میکنه.

     <span dir="ltr" align="left">

     ```js
     enum Color {
      RED, GREEN, BLUE
     }
     ```

     </span>

     **[فهرست](#فهرست)**

280. ### چطوری همه propertyهای یه object رو به دست بیاریم؟

     می‌تونیم از متد `Object.getOwnPropertyNames` استفاده کنیم که آرایه‌ای از تمام ویژگی‌هایی رو که مستقیماً تو آبجکت داده شده یافت می‌شه رو برمی‌گردونه. بیاین استفاده از اونو تو یه مثال ببینیم:

     <span dir="ltr" align="left">

     ```js
     const newObject = {
       a: 1,
       b: 2,
       c: 3,
     };

     console.log(Object.getOwnPropertyNames(newObject));
     ["a", "b", "c"];
     ```

     </span>

     **[فهرست](#فهرست)**

281. ### چطوری property-descriptorهای یه آبجکت رو بدست بیاریم؟

     می‌تونیم از متد `Object.getOwnPropertyDescriptors` استفاده کنیم که تمام توصیف‌گرهای ویژگی یه آبجکت معین رو برمی‌گردونه. بیاین استفاده از اونو توی یه مثال ببینیم:

     <span dir="ltr" align="left">

     ```js
     const newObject = {
       a: 1,
       b: 2,
       c: 3,
     };
     const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);
     console.log(descriptorsObject.a.writable); // true
     console.log(descriptorsObject.a.configurable); // true
     console.log(descriptorsObject.a.enumerable); // true
     console.log(descriptorsObject.a.value); // 1
     ```

     </span>

     **[فهرست](#فهرست)**

282. ### گزینه‌هایی که موقع تعریف ویژگی object با descriptor داریم کدوما هستن؟

     1. value: ارزش مرتبط با پراپرتی
     2. writable:تعیین میکنه که آیا مقدار مرتبط با ویژگی قابل تغییر هس یا نه
     3. configurable: اگه بتونیم نوع descriptor این ویژگی رو تغییر بدیم و اگه بتونیم ویژگی رو از آبجکت مربوطه حذف کنیم، مقدار true رو برمی‌گردونه.
     4. enumerable: تعیین میکنه که ویژگی در موقع شمارش خصوصیات روی آبجکت مربوطه ظاهر می‌شه یا نه.
     5. set: تابعی که به عنوان تنظیم کننده برای ویژگی عمل میکنه
     6. get: تابعی که به عنوان یه گیرنده برای ملک عمل میکنه

     **[فهرست](#فهرست)**

283. ### چطوری کلاس‌ها رو extend می‌کنی؟

     کلمه کلیدی `extends` در اعلان‌ها/عبارات کلاس برای ایجاد کلاسی که فرزند کلاس دیگه ایه استفاده می‌شه. می‌شه از اون برای زیر کلاس بندی کلاس‌های سفارشی و همچنین اشیاء داخلی استفاده کرد. بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```js
     class ChildClass extends ParentClass { ... }
     ```

     </span>

     بیاین یه نمونه از زیر کلاس مربع از کلاس والد Polygon رو مثال بزنیم:

     <span dir="ltr" align="left">

     ```js
     class Square extends Rectangle {
       constructor(length) {
         super(length, length);
         this.name = "Square";
       }

       get area() {
         return this.width * this.height;
       }

       set area(value) {
         this.area = value;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

284. ### چطوری آدرس صفحه رو بدون رفرش صفحه عوض کنیم؟

     برای تغییر url میشه از`window.location.url` استفاده کرد اما این کار باعث بارگیری دوباره صفحه میشه. HTML5 متدهای `history.pushState` و `history.replaceState` رو معرفی کرد که به شما اجازه میده به ترتیب ورودی‌های تاریخ رو اضافه و تغییر بدین. برای مثال، می‌تونیم از pushState مثل کد زیر استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     window.history.pushState("page2", "Title", "/page2.html");
     ```

     </span>

     **[فهرست](#فهرست)**

285. ### چطوری بررسی می‌کنی که یه آرایه یه مقدار مشخص رو داره یا نه؟

     متد `Array.includes` برای تعیین اینکه آیا یه آرایه مقدار خاصی رو بین ورودی‌های خودش داره یا نه با برگردوندن true یا false استفاده می‌شه. بیاین مثالی برای پیداکردن یه عنصر (عددی و رشته‌ای) تو یه آرایه ببینیم:

     <span dir="ltr" align="left">

     ```js
     const numericArray = [1, 2, 3, 4];
     console.log(numericArray.includes(3)); // true

     const stringArray = ["green", "yellow", "blue"];
     console.log(stringArray.includes("blue")); // true
     ```

     </span>

     **[فهرست](#فهرست)**

286. ### چطوری آرایه‌های scalar رو با هم مقایسه می‌کنی؟

     می‌تونیم از length و هر روش آرایه برای مقایسه دو آرایه اسکالر (مقایسه مستقیم با استفاده از ===) استفاده کنیم. ترکیب این دو تا روش میتونه نتیجه مورد نیازمون رو به ما بده:

     <span dir="ltr" align="left">

     ```js
     const arrayFirst = [1, 2, 3, 4, 5];
     const arraySecond = [1, 2, 3, 4, 5];
     console.log(
       arrayFirst.length === arraySecond.length &&
         arrayFirst.every((value, index) => value === arraySecond[index])
     ); // true
     ```

     </span>

     اگه بخوایم آرایه‌ها رو بدون توجه به ترتیب مقایسه کنیم باید اونا رو قبل از مقایسه، مرتب کنیم.

     <span dir="ltr" align="left">

     ```js
     const arrayFirst = [2, 3, 1, 4, 5];
     const arraySecond = [1, 2, 3, 4, 5];
     console.log(
       arrayFirst.length === arraySecond.length &&
         arrayFirst.sort().every((value, index) => value === arraySecond[index])
     ); // true
     ```

     </span>

     **[فهرست](#فهرست)**

287. ### چطوری می‌شه پارامترهای صفحه رو از متد GET گرفت؟

     کلاس `URL` رشته url رو می‌پذیرد و از ویژگی `searchParams` این آبجکت میتونیم برای دسترسی به پارامترهای get استفاده کنیم. ممکنه برای دسترسی به URL در مرورگرهای قدیمی (از جمله IE) نیاز به استفاده از polyfill یا `window.location` داشته باشیم.

     <span dir="ltr" align="left">

     ```js
     const urlString = "http://www.some-domain.com/about.html?x=1&y=2&z=3"; // window.location.href
     const url = new URL(urlString);
     const parameterZ = url.searchParams.get("z");
     console.log(parameterZ); // 3
     ```

     </span>

     **[فهرست](#فهرست)**

288. ### چطوری اعداد رو می‌شه سه رقم سه رقم جدا کرد؟

     می‌تونیم از متد `Number.prototype.toLocaleString` استفاده کنیم که رشته‌ای رو با نمایشی حساس به زبان مثل جداکننده هزار، ارز و غیره از این عدد برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     function convertToThousandFormat(x) {
       return x.toLocaleString(); // 12,345.679
     }

     console.log(convertToThousandFormat(12345.6789));
     ```

     </span>

     **[فهرست](#فهرست)**

289. ### تفاوت‌ بین java و javascript چیه؟

     هر دو زبان برنامه نویسی کاملاً نامرتبط هستن و هیچ ارتباطی بین اونا وجود نداره. جاوا بصورت ایستا تایپ می‌شه، کامپایل می‌شه، روی ماشین مجازی خودش اجرا می‌شه. در حالی که جاواسکریپت به صورت پویا تایپ می‌شه، تفسیر می‌شه و در محیط‌های مرورگر و nodejs اجرا می‌شه. بیاین تفاوت‌های عمده رو در قالب جدولی ببینیم:

     | ویژگی    | جاوا                                | جاواسکریپت                                                             |
     | -------- | ----------------------------------- | ---------------------------------------------------------------------- |
     | تایپ شده | یه زبان حساس به لحاظ تایپ دار بودنه | این یه زبان تایپ شده پویاس                                             |
     | پارادایم | برنامه نویسی شی گرا                 | برنامه نویسی مبتنی بر prototype                                        |
     | محدوده   | محدوده بلوک                         | محدوده عملکردی                                                         |
     | همزمانی  | بر اساس موضوع                       | مبتنی بر رویداد                                                        |
     | حافظه    | از حافظه بیشتر استفاده میکنه        | از حافظه کمتری استفاده میکنه. از این رو برای صفحات وب استفاده خواهد شد |

     **[فهرست](#فهرست)**

290. ### آیا جاواسکریپت namespace رو پشتیبانی میکنه؟

     جاواسکریپت به طور پیش فرض از namespace پشتیبانی نمیکنه. بنابراین اگه هر عنصری (تابع، متد، آبجکت، متغیر) ایجاد کنیم گلوبال می‌شه و namespace گلوبال رو آلوده میکنه. بیاین مثالی از تعریف دو تابع بدون namespace بزنیم،

     <span dir="ltr" align="left">

     ```js
     function func1() {
       console.log("This is a first definition");
     }
     function func1() {
       console.log("This is a second definition");
     }
     func1(); // This is a second definition
     ```

     </span>

     همیشه تعریف تابع دوم رو فراخوانی میکنه. در این صورت namespace مشکل برخورد نام رو حل میکنه.

     **[فهرست](#فهرست)**

291. ### چطوری namespace تعریف می‌کنی؟

     حتی اگه جاواسکریپت فاقد namespace باشه، می‌تونیم از Objects، IIFE برای ایجاد namespace استفاده کنیم.

     1. **استفاده از Object literal:** بیاین متغیرها و توابع رو درون یه Object literal بپیچیم که به عنوان namespace عمل میکنه. پس از اون می‌تونیم با استفاده از نماد آبجکت به اونا دسترسی داشته باشیم

     <span dir="ltr" align="left">

     ```js
     const namespaceOne = {
        function func1() {
            console.log("This is a first definition");
        }
     }
     const namespaceTwo = {
          function func1() {
              console.log("This is a second definition");
          }
      }
     namespaceOne.func1(); // This is a first definition
     namespaceTwo.func1(); // This is a second definition
     ```

     </span>

     2. **استفاده از IIFE (توابع بیانی بلافاصله صدازده شده ):** جفت پرانتز بیرونی IIFE یه محدوده محلی برای تمام کدهای داخلش ایجاد میکنه و تابع ناشناس رو به یه عبارت تابع تبدیل میکنه. به همین دلیل، می‌تونیم یه تابع رو در تو دو عبارت تابع مختلف ایجاد کنیم تا به عنوان namespace عمل کنه.

     <span dir="ltr" align="left">

     ```js
     (function () {
       function fun1() {
         console.log("This is a first definition");
       }
       fun1();
     })();

     (function () {
       function fun1() {
         console.log("This is a second definition");
       }
       fun1();
     })();
     ```

     </span>

     3. **استفاده کردن از بلوک و تعریف‌کننده let و const:** در ES6، می‌تونیم از یه بلوک و یه اعلان let برای محدود کردن دامنه یه متغیر به یه بلوک استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     {
       const myFunction = function fun1() {
         console.log("This is a first definition");
       };
       myFunction();
     }
     // myFunction(): ReferenceError: myFunction is not defined.

     {
       const myFunction = function fun1() {
         console.log("This is a second definition");
       };
       myFunction();
     }
     // myFunction(): ReferenceError: myFunction is not defined.
     ```

     </span>

     **[فهرست](#فهرست)**

292. ### چطوری می‌تونیم تکه کد جاواسکریپت داخل یه iframe رو از صفحه والد صدا بزنیم؟

     در ابتدا باید `iFrame` با استفاده از `document.getElementBy` یا `window.frames` قابل دسترسی باشه. پس از اون ویژگی `contentWindow iFrame` به `targetFunction` دسترسی میده

     <span dir="ltr" align="left">

     ```js
     document.getElementById("targetFrame").contentWindow.targetFunction();
     window.frames[0].frameElement.contentWindow.targetFunction(); // Accessing iframe this way may not work in latest versions chrome and firefox
     ```

     </span>

     **[فهرست](#فهرست)**

293. ### چطوری می‌شه اختلاف timezone رو از آبجکت date بگیریم؟

     می‌تونیم از روش `getTimezoneOffset` کلاس Date استفاده کنیم. این روش اختلاف منطقه زمانی رو بر حسب دقیقه از محلی فعلی (تنظیمات سیستم میزبان) به UTC برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     const offset = new Date().getTimezoneOffset();
     console.log(offset); // -480
     ```

     </span>

     **[فهرست](#فهرست)**

294. ### چطوری فایل‌های CSS و JS رو به شکل داینامیک بارگذاری کنیم؟

     می‌تونیم هر دو عنصر پیوند و اسکریپت رو توی DOM ایجاد کنیم و اونا رو به عنوان child به تگ head اضافه کنیم. بیاین یه تابع برای اضافه کردن منابع اسکریپت و سبک مثل زیر ایجاد کنیم:

     <span dir="ltr" align="left">

     ```js
     function loadAssets(filename, filetype) {
       if (filetype == "css") {
         // External CSS file
         const fileReference = document.createElement("link");
         fileReference.setAttribute("rel", "stylesheet");
         fileReference.setAttribute("type", "text/css");
         fileReference.setAttribute("href", filename);
       } else if (filetype == "js") {
         // External JavaScript file
         const fileReference = document.createElement("script");
         fileReference.setAttribute("type", "text/javascript");
         fileReference.setAttribute("src", filename);
       }
       if (typeof fileReference !== "undefined")
         document.getElementsByTagName("head")[0].appendChild(fileReference);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

295. ### روش‌های مختلف برای پیدا کردن elementها توی DOM کدوما هستن؟

     اگه بخوایم به هر عنصری در صفحه HTML دسترسی داشته باشیم، باید با دسترسی به آبجکت document شروع کنیم. بعداً می‌تونیم از یکی از روش‌های زیر برای پیداکردن عنصر HTML استفاده کنیم.

     1. document.getElementById(id): یه عنصر رو با Id پیدا میکنه
     2. document.getElementsByTagName(name): یه عنصر رو با اسم تگ پیدا میکنه
     3. document.getElementsByClassName(name):یک عنصر رو با اسم کلاس پیدا میکنه

     **[فهرست](#فهرست)**

296. ### jQuery چیه؟

     jQuery یه کتابخونه جاواسکریپت متقابل مرورگر محبوبه که با به حداقل رسوندن اختلاف بین مرورگرها، پیمایش مدل آبجکت document (DOM)، مدیریت رویداد، انیمیشن‌ها و تعاملات AJAX رو فراهم میکنه. با فلسفه اش «کمتر بنویس، بیشتر انجام بده» شهرت زیادی داره. برای مثال، می‌تونیم پیام خوش آمدگویی رو موقع بارگذاری صفحه با استفاده از jQuery به صورت زیر نمایش بدین.

     <span dir="ltr" align="left">

     ```js
     $(document).ready(() => {
       // It selects the document and apply the function on page load
       alert("Welcome to jQuery world");
     });
     ```

     </span>

     **نکته:**می‌تونیم اونو از سایت رسمی jquery دانلود کنیم یا از CDN‌ها مثل گوگل نصب کنیم.

     **[فهرست](#فهرست)**

297. ### موتور V8 جاواسکریپت چیه؟

     V8 یه موتور جاواسکریپت با کارایی بالا منبع بازه که توسط مرورگر Google Chrome استفاده می‌شه و به زبان C++ نوشته شده است. توی پروژه node.js استفاده می‌شه. ECMAScript و WebAssembly رو پیاده‌سازی میکنه و روی ویندوز 7 یا بالاتر، macOS 10.12+ و سیستم‌های لینوکس که از پردازنده‌های x64، IA-32، ARM یا MIPS استفاده میکنن اجرا می‌شه.
     **نکته:** میتونه به صورت مستقل اجرا شه یا میتونه در هر برنامه C++ تعبیه شه.

     **[فهرست](#فهرست)**

298. ### چرا ما جاواسکریپت رو به عنوان یه زبان داینامیک می‌شناسیم؟

     جاواسکریپت یه زبان ساده تایپ شده یا یه زبان پویاعه چون متغیرها در جاواسکریپت مستقیماً با هیچ نوع مقدار خاصی مرتبط نیستن و هر متغیری رو می‌شه با مقادیری از همه نوع تخصیص/تخصیص مجدد داد.

     <span dir="ltr" align="left">

     ```js
     let age = 50; // age is a number now
     age = "old"; // age is a string now
     age = true; // age is a boolean
     ```

     </span>

     **[فهرست](#فهرست)**

299. ### عملگر void چیکار میکنه؟

     عملگر `void` عبارت داده شده رو ارزیابی میکنه و بعد تعریف نشده (یعنی بدون برگشتن مقدار) رو برمی‌گردونه. بریم یه مثال در موردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     void expression;
     void expression;
     ```

     </span>

     بیاین پیامی رو بدون هیچ گونه تغییر مسیر یا بارگیری مجدد نمایش بدیم

     <span dir="ltr" align="left">

     ```js
     <a href="javascript:void(alert('Welcome to JS world'))">
       Click here to see a message
     </a>
     ```

     </span>

     **نکته:** این عملگر بیشتر برای بدست آوردن مقدار اولیه تعریف نشده با استفاده از "void(0)" استفاده می‌شه.

     **[فهرست](#فهرست)**

300. ### چطوری می‌شه نمایشگر موس صفحه رو به درحال لود تغییر داد؟

     مکان نما رو می‌شه برای انتظار در جاواسکریپت با استفاده از ویژگی `cursor`تنظیم کرد. بیاین این رفتار رو در بارگذاری صفحه با استفاده از تابع زیر انجام بدیم:

     <span dir="ltr" align="left">

     ```js
     function myFunction() {
       window.document.body.style.cursor = "wait";
     }
     ```

     </span>

     و این تابع در بارگذاری صفحه فراخوانی می‌شه

     <span dir="ltr" align="left">

     ```html
     <body onload="myFunction()"></body>
     ```

     </span>

     **[فهرست](#فهرست)**

301. ### چطوری می‌شه یه حلقه بی‌نهایت درست کرد؟

     می‌تونیم حلقه‌های بی نهایت با استفاده از حلقه‌های for و while بدون استفاده از هیچ عبارتی ایجاد کنیم. ساختار یا syntax حلقه for از نظر ESLint و ابزارهای بهینه ساز کد، رویکرد بهتری برای این کار هست.

     <span dir="ltr" align="left">

     ```js
     for (;;) {}

     while (true) {}
     ```

     </span>

     **[فهرست](#فهرست)**

302. ### چرا باید در استفاده از عبارت with تجدیدنظر کرد؟

     دستور with جاواسکریپت در نظر گرفته شده بود که مختصری برای نوشتن دسترسی‌های تکرارشونده به آبجکت ارائه بده. بنابراین میتونه با کاهش نیاز به تکرار یه مرجع طولانی بدون جریمه عملکرد، به کاهش اندازه فایل کمک کنه. بیاین مثالی بزنیم که تو اون برای جلوگیری از افزونگی موقع چندین بار دسترسی به یه آبجکت استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     a.b.c.greeting = "welcome";
     a.b.c.age = 32;
     ```

     </span>

     استفاده از "with" کد رو به این شکل تبدیل میکنه:

     <span dir="ltr" align="left">

     ```js
     with (a.b.c) {
       greeting = "welcome";
       age = 32;
     }
     ```

     </span>

     اما این عبارت `with` مشکلات عملکردی ایجاد میکنه، چون نمی‌شه پیش‌بینی کرد که آیا یه آرگومان به یه متغیر واقعی اشاره میکنه یا به یه ویژگی توی آرگومان with.

     **[فهرست](#فهرست)**

303. ### خروجی این حلقه‌ها چی می‌شه؟

     <span dir="ltr" align="left">

     ```js
     for (var i = 0; i < 4; i++) {
       // global scope
       setTimeout(() => console.log(i));
     }

     for (let i = 0; i < 4; i++) {
       // block scope
       setTimeout(() => console.log(i));
     }
     ```

     </span>

     خروجی حلقه‌های بالا 4 4 4 4 و 0 1 2 3 است
     **توضیح:** با توجه به صف رویداد/حلقه جاواسکریپت، تابع 'setTimeout' بعد از اجرای حلقه فراخونی می‌شه. از اونجایی که متغیر i با کلمه کلیدی `var` تعریف می‌شه، به یه متغیر گلوبال تبدیل می‌شه و با استفاده از تکرار زمانی که تابع time setTimeout فراخوانی می‌شه، مقدارش برابر با 4. بنابراین، خروجی حلقه اول '4 4 4 4' میشه. حالا توی حلقه دوم، متغیر i به‌عنوان کلمه کلیدی `let` تعریف می‌شه، به متغیری با محدوده بلوک تبدیل می‌شه و یه مقدار جدید (0, 1,2 3) برای هر تکرار داره. بنابراین، خروجی حلقه دوم «0 1 2 3» میشه.

     **[فهرست](#فهرست)**

304. ### می‌تونی یه سری از ویژگی‌های ES6 رو اسم ببری؟

     1. پشتیبانی از ثابت‌ها یا متغیرهای تغییرناپذیر
     2. پشتیبانی Block-scope برای متغیرها، ثابت‌ها و توابع
     3. Arrow functions
     4. پارامترهای پیش فرض
     5. پارامتر‌های Rest and Spread
     6. Template Literals
     7. Multi-line Strings
     8. Destructuring Assignment
     9. Enhanced Object Literals
     10. Promises
     11. Classes
     12. Modules

     **[فهرست](#فهرست)**

305. ### ES6 چیه؟

     ES6 ششمین نسخه از زبان جاواسکریپت‌ـه و در ژوئن 2015 منتشر شد. در ابتدا با نام ECMAScript 6 (ES6) شناخته شد و بعداً به ECMAScript 2015 تغییر نام داد. تقریباً همه مرورگرهای مدرن از ES6 پشتیبانی می‌کنن اما برای مرورگرهای قدیمی ترانسپایلرهای زیادی وجود داره.، مثل Babel.js و غیره

     **[فهرست](#فهرست)**

306. ### آیا می‌تونیم متغیرهای تعریف شده با let و const رو مجددا declare کنیم؟

     نه، ما نمی‌تونیم متغیرهای let و const رو مجدداً تعریف کنیم. اگه این کار رو انجام بدیم، یه خطای syntax دریافت می‌کنیم:

     <span dir="ltr" align="left">

     ```bash
     Uncaught SyntaxError: Identifier 'someVariable' has already been declared
     ```

     </span>

     **توضیح:** اعلان متغیر با کلمه کلیدی "var" به یه محدوده تابع اشاره داره و با متغیر به دلیل ویژگی hoisting به گونه ای رفتار می‌شه که مثلا در بالای محدوده محصور تعریف شده. پس همه اعلان‌های چندگانه بدون هیچ خطایی تو ایجاد یه متغیر hoisted مشترک نقش دارن. بیاین مثالی از اعلان مجدد متغیرها تو یه محدوده برای متغیرهای var و let/const بزنیم.

     <span dir="ltr" align="left">

     ```js
     const name = "John";
     function myFunc() {
       var name = "Nick";
       var name = "Abraham"; // Re-assigned in the same function block
       alert(name); // Abraham
     }
     myFunc();
     alert(name); // John
     ```

     </span>

     اعلان چندگانه با محدوده بلوک، خطای syntax ایجاد میکنه،

     <span dir="ltr" align="left">

     ```js
     let name = "John";
     function myFunc() {
       let name = "Nick";
       let name = "Abraham"; // Uncaught SyntaxError: Identifier 'name' has already been declared
       alert(name);
     }

     myFunc();
     alert(name);
     ```

     </span>

     **[فهرست](#فهرست)**

307. ### آیا استفاده از const برای تعریف متغیر اونا رو immutable میکنه؟

     نه، متغیر const مقدار رو تغییرناپذیر نمیکنه. اما تخصیص‌های بعدی رو مجاز نمی‌دونه (یعنی می‌تونیم با ایجاد متغیر اعلام کنیم اما بعداً نمی‌تونیم مقدار دیگه ای رو یا نوع اون متغیر رو عوض کنیم)

     <span dir="ltr" align="left">

     ```js
     const userList = [];
     userList.push("John"); // Can mutate even though it can't re-assign
     console.log(userList); // ['John']
     uerList = 123; // throws an error
     ```

     </span>

     **[فهرست](#فهرست)**

308. ### parameterهای پیش‌فرض چی هستن؟

     در E5، برای مدیریت مقادیر پیش‌فرض پارامترهای تابع، باید به عملگرهای OR منطقی وابسته باشیم.ولی در ES6، ویژگی پارامترهای تابع پیش‌فرض اجازه میده تا پارامترها با مقادیر پیش‌فرض مقداردهی اولیه بشن، اگه مقداری یا تعریف‌نشده ارسال نشه. بیاین رفتار رو با یه مثال مقایسه کنیم:

     <span dir="ltr" align="left">

     ```js
     // ES5
     const calculateArea = function (height, width) {
       height = height || 50;
       width = width || 60;

       return width * height;
     };
     console.log(calculateArea()); // 300
     ```

     </span>

     پارامترهای پیش فرض، مقداردهی اولیه رو ساده تر میکنه،

     <span dir="ltr" align="left">

     ```js
     // ES6
     const calculateArea = function (height = 50, width = 60) {
       return width * height;
     };

     console.log(calculateArea()); // 300
     ```

     </span>

     **[فهرست](#فهرست)**

309. ### template-literalها چی هستن؟

     حروف الفبای الگو یا رشته‌های الگو، حروف الفبای رشته‌ای هستن که امکان عبارات تعبیه‌شده رو میدن. اینا به جای گیومه‌های دوتایی یا تکی با کاراکتر بک تیک (`) محصور میشن در E6، این ویژگی استفاده از عبارات پویا رو به شرح زیر امکان پذیر میکنه.

     <span dir="ltr" align="left">

     ```js
     const greeting = `Welcome to JS World, Mr. ${firstName} ${lastName}.`;
     ```

     </span>

     توی ES5 لازمه که ما کدمون رو این شکلی بنویسیم.

     <span dir="ltr" align="left">

     ```js
     var greeting = 'Welcome to JS World, Mr. ' + firstName + ' ' + lastName.`
     ```

     </span>

     **نکته:** می‌تونیم از رشته‌های چند خطی و ویژگی‌های درون‌یابی رشته‌ای با الفبای الگو استفاده کنیم.

     **[فهرست](#فهرست)**

310. ### چطوری رشته‌های چند خطی رو توی template-literalها می‌نویسیم؟

     در ES5، برای بدست آوردن رشته‌های چند خطی، باید از کاراکترهای فرار از خط جدید ('\\n') و نمادهای الحاقی (+) استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     console.log("This is string sentence 1\n" + "This is string sentence 2");
     ```

     </span>

     در حالی که در ES6، نیازی به ذکر کاراکتر دنباله خط جدید نیست،

     <span dir="ltr" align="left">

     ```js
     console.log(`This is string sentence
     'This is string sentence 2`);
     ```

     </span>

     **[فهرست](#فهرست)**

311. ### template-literal‌های تودرتو چی هستن؟

     الگوی تودرتو یه ویژگیه که در نحو تحت اللفظی الگو پشتیبانی می‌شه تا امکان بکتیک‌های درونی تو یه مکان‌نمای ${ } رو در قالب فراهم کنه. برای مثال، الگوی تودرتو زیر برای نمایش نمادها بر اساس مجوزهای کاربر استفاده می‌شه، در حالی که الگوی بیرونی نوع پلت فرم رو بررسی میکنه.

     <span dir="ltr" align="left">

     ```js
     const iconStyles = `icon ${
       isMobilePlatform()
         ? ""
         : `icon-${user.isAuthorized ? "submit" : "disabled"}`
     }`;
     ```

     </span>

     می‌تونیم مورد استفاده بالا رو بدون ویژگی‌های الگوی تودرتو هم بنویسین. با این حال، ویژگی الگوی تودرتو فشرده‌تر و خواناتر است.

     <span dir="ltr" align="left">

     ```js
     //Without nesting templates
      const iconStyles = `icon ${ isMobilePlatform() ? '' :
       (user.isAuthorized ? 'icon-submit' : 'icon-disabled'}`;
     ```

     </span>

     **[فهرست](#فهرست)**

312. ### tagged-templateها چی هستن؟

     الگوهای برچسب‌گذاری شده شکل پیشرفته‌ای از قالب‌ها هستن که تو اون برچسب‌ها بهمون اجازه میدن تا کلمات قالب رو با یه تابع تجزیه کنیم. تابع تگ اولین پارامتر رو به عنوان آرایه ای از رشته‌ها و پارامترهای باقی مانده رو به عنوان strings می‌گیره. این تابع همچنین میتونه رشته‌های دستکاری شده رو بر اساس پارامترها برگردونه.

     بیاین نحوه استفاده از رفتار الگوی برچسب گذاری شده مجموعه مهارت‌های حرفه ای فناوری اطلاعات تو یه سازمان رو ببینیم.

     <span dir="ltr" align="left">

     ```js
     var user1 = 'John';
     var skill1 = 'JavaScript';
     var experience1 = 15;

     var user2 = 'Kane';
     var skill2 = 'JavaScript';
     var experience2 = 5;

     function myInfoTag(strings, userExp, experienceExp, skillExp) {
       var str0 = strings[0]; // "Mr/Ms. "
       var str1 = strings[1]; // " is a/an "
       var str2 = strings[2]; // "in"

       var expertiseStr;
       if (experienceExp > 10){
         expertiseStr = 'expert developer';
       } else if(skillExp > 5 && skillExp <= 10) {
         expertiseStr = 'senior developer';
       } else {
         expertiseStr = 'junior developer';
       }

       return ${str0}${userExp}${str1}${expertiseStr}${str2}${skillExp};
     }

     var output1 = myInfoTag`Mr/Ms. ${ user1 } is a/an ${ experience1 } in ${skill1}`;
     var output2 = myInfoTag`Mr/Ms. ${ user2 } is a/an ${ experience2 } in ${skill2}`;

     console.log(output1);// Mr/Ms. John is a/an expert developer in JavaScript
     console.log(output2);// Mr/Ms. Kane is a/an junior developer in JavaScript
     ```

     </span>

     **[فهرست](#فهرست)**

313. ### رشته‌های خام چی هستن؟

     ES6 با استفاده از روش «String.raw» ویژگی رشته‌های خام رو ارائه میکنه که برای دریافت شکل رشته خام رشته‌های الگو استفاده می‌شه. این ویژگی به ما این امکان رو میده تا به رشته‌های خام همونطور که وارد شده‌اند، بدون پردازش دنباله‌های فرار دسترسی داشته باشیم. بریم یه مثال در موردش ببینیم،

      <span dir="ltr" align="left">

     ```js
     const calculationString = String.raw`The sum of numbers is \n${
       1 + 2 + 3 + 4
     }!`;
     console.log(calculationString); // The sum of numbers is 10
     ```

      </span>

     اگه از رشته‌های خام استفاده نمی‌کنیم دنباله کاراکترهای خط جدید با نمایش خروجی در چندین خط پردازش می‌شه.

     <span dir="ltr" align="left">

     ```js
     const calculationString = `The sum of numbers is \n${1 + 2 + 3 + 4}!`;
     console.log(calculationString);
     // The sum of numbers is
     // 10
     ```

      </span>

     همچنین، ویژگی خام در اولین آرگومان تابع تگ موجود است

      <span dir="ltr" align="left">

     ```js
     function tag(strings) {
       console.log(strings.raw[0]);
     }
     ```

      </span>

     **[فهرست](#فهرست)**

314. ### assign کردن با destructuring چیه و چطوری انجام می‌شه؟

     تخصیص `destructuring` یه عبارت جاواسکریپت‌ـه که امکان باز کردن مقادیر آرایه‌ها یا خصوصیات از اشیاء به متغیرهای مجزا رو فراهم میکنه.
     بیاین مقادیر ماه رو از یه آرایه با استفاده از تخصیص ساختارشکن به دست آوریم

     <span dir="ltr" align="left">

     ```js
     const [one, two, three] = ["JAN", "FEB", "MARCH"];

     console.log(one); // "JAN"
     console.log(two); // "FEB"
     console.log(three); // "MARCH"
     ```

     </span>

     و می‌تونیم ویژگی‌های کاربر یه آبجکت رو با استفاده از انتساب destructuring به دست بیارین،

     <span dir="ltr" align="left">

     ```js
     const { name, age } = { name: "John", age: 32 };

     console.log(name); // John
     console.log(age); // 32
     ```

     </span>

     **[فهرست](#فهرست)**

315. ### موقع assign کردن با destructuring چطوری می‌شه مقدار اولیه تعریف کرد؟

     زمانی که مقدار باز شده از آرایه یا شیء در طول تخصیص ساختارشکن تعریف نشده باشه، می‌شه به یه متغیر یه مقدار پیش فرض اختصاص داد. این کمک میکنه تا از تنظیم مقادیر پیش فرض جداگانه برای هر انتساب جلوگیری کنیم. بیاین برای هر دو آرایه و موارد استفاده از شی مثالی بزنیم،

     **Arrays destructuring:**

     <span dir="ltr" align="left">

     ```js
     let x;
     let y;
     let z;

     [x = 2, y = 4, z = 6] = [10];
     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     </span>

     **Objects destructuring:**

     <span dir="ltr" align="left">

     ```js
     const { x = 2, y = 4, z = 6 } = { x: 10 };

     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     </span>

     **[فهرست](#فهرست)**

316. ### چطوری می‌تونیم مقدار یه آرایه رو با استفاده از destructuring-assignment تعویض کنیم؟

     اگه از destructuring-assignment استفاده نمی‌کنیم تعویض دو مقدار به یه متغیر موقت نیاز داره. در حالی که با استفاده از یه ویژگی ساختارشکن، دو مقدار متغیر رو می‌شه تو یه عبارت ساختار شکن جایگزین کرد. بیاین دو متغیر عددی رو در انتساب ساختارزدایی آرایه با هم عوض کنیم:

     <span dir="ltr" align="left">

     ```js
     let x = 10;
     let y = 20;

     [x, y] = [y, x];
     console.log(x); // 20
     console.log(y); // 10
     ```

     </span>

     **[فهرست](#فهرست)**

317. ### Enhanced-object-literalها چی هستن؟

     Enhanced-object-literal ایجاد سریع اجسام با ویژگی‌های درون براکت رو آسان میکنه. برای مثال، نحو کوتاه‌تری رو برای تعریف ویژگی شی مشترک به شرح زیر ارائه میکنه.

     <span dir="ltr" align="left">

     ```js
     // ES6
     var x = 10;
     var y = 20;
     obj = { x, y };
     console.log(obj); // {x: 10, y:20}
     // ES5
     var x = 10;
     var y = 20;
     obj = { x, y };
     console.log(obj); // {x: 10, y:20}
     ```

     </span>

     **[فهرست](#فهرست)**

318. ### importهای داینامیک چی هستن؟

     واردات پویا با استفاده از نحو تابع «import» به ما اجازه میده تا ماژول‌ها رو در صورت تقاضا با استفاده از دستورات یا دستور async/await بارگذاری کنیم. در حال حاضر این ویژگی در [پیشنهاد مرحله4] (https://github.com/tc39/proposal-dynamic-import) هستش. مزیت اصلی واردات پویا کاهش اندازه بسته‌های ما، پاسخ حجم/بار بار درخواست‌های ما و بهبود کلی در تجربه کاربر است.

     <span dir="ltr" align="left">

     ```js
     import("./Module").then((Module) => Module.method());
     ```

     </span>

     **[فهرست](#فهرست)**

319. ### کاربرد importهای داینامیک چیه؟

     در زیر بعضی از موارد استفاده از واردات پویا نسبت به واردات استاتیک آورده شده است.

     1. یه ماژول رو به صورت درخواستی یا مشروط وارد کنیم. برای مثال، اگه می‌خواین یه polyfill رو در مرورگر قدیمی بارگذاری کنیم

     <span dir="ltr" align="left">

     ```js
     if (isLegacyBrowser()) {
         import(···)
         .then(···);
     }
     ```

     </span>

     2. تعیین کننده ماژول رو در زمان اجرا محاسبه کنیم. برای مثال می‌تونیم از اون برای گلوبال سازی استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     import(`messages_${getLocale()}.js`).then(···);
     ```

     </span>

     3. یه ماژول رو از داخل یه اسکریپت معمولی به جای یه ماژول وارد کنیم.

     **[فهرست](#فهرست)**

320. ### آرایه‌های نوع‌دار(typed-arrays) چیه؟

     آرایه‌های تایپ شده آبجکت‌هایی آرایه مانند از ECMAScript 6 API برای مدیریت داده‌های باینری هستن. جاواسکریپت 8 نوع آرایه تایپ شده رو ارائه میده،

     1. Int8Array: آرایه ای از اعداد صحیح امضا شده 8 بیتی
     2. Int16Array: آرایه ای از اعداد صحیح امضا شده 16 بیتی
     3. Int32Array: آرایه ای از اعداد صحیح امضا شده 32 بیتی
     4. Uint8Array: آرایه ای از اعداد صحیح بدون علامت 8 بیتی
     5. Uint16Array: آرایه ای از اعداد صحیح بدون علامت 16 بیتی
     6. Uint32Array: آرایه ای از اعداد صحیح بدون علامت 32 بیتی
     7. Float32Array:آرایه ای از اعداد ممیز شناور 32 بیتی
     8. Float64Array: آرایه ای از اعداد ممیز شناور 64 بیتی

     برای مثال، می‌تونیم یه آرایه از اعداد صحیح امضا شده 8 بیتی مانند زیر ایجاد کنیم

     <span dir="ltr" align="left">

     ```js
     const a = new Int8Array();
     // You can pre-allocate n bytes
     const bytes = 1024;
     const a = new Int8Array(bytes);
     ```

     </span>

     **[فهرست](#فهرست)**

321. ### مزایای لودر ماژول‌ها چیه؟

     ماژول لودر ویژگی‌های زیر رو ارائه میده

     1. Dynamic loading
     2. State isolation
     3. Global namespace isolation
     4. Compilation hooks
     5. Nested virtualization

     **[فهرست](#فهرست)**

322. ### collation چیه؟

     Collation برای مرتب سازی مجموعه ی رشته‌ها و جستجو در مجموعه ای از رشته‌ها استفاده می‌شه. این پارامتر توسط محلی و از Unicode آگاهه. بیاین ویژگی‌های مقایسه و مرتب سازی رو در نظر بگیریم،

     1. **Comparison:**

     <span dir="ltr" align="left">

     ```js
     const list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     const l10nDE = new Intl.Collator("de");
     const l10nSV = new Intl.Collator("sv");
     console.log(l10nDE.compare("ä", "z") === -1); // true
     console.log(l10nSV.compare("ä", "z") === +1); // true
     ```

     </span>

     2. **Sorting:**

     <span dir="ltr" align="left">

     ```js
     const list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     const l10nDE = new Intl.Collator("de");
     const l10nSV = new Intl.Collator("sv");
     console.log(list.sort(l10nDE.compare)); // [ "a", "ä", "z" ]
     console.log(list.sort(l10nSV.compare)); // [ "a", "z", "ä" ]
     ```

     </span>

     **[فهرست](#فهرست)**

323. ### عبارت for...of چیه؟

     دستور for...of یه حلقه تکرار بر روی اشیاء یا عناصر قابل تکرار مثل رشته داخلی، آرایه، اشیاء آرایه مانند (مثل آرگومان‌ها یا NodeList)، TypedArray، Map، Set و تکرارهای تعریف شده توسط کاربر ایجاد میکنه.

     <span dir="ltr" align="left">

     ```js
     const arrayIterable = [10, 20, 30, 40, 50];

     for (let value of arrayIterable) {
       value++;
       console.log(value); // 11 21 31 41 51
     }
     ```

     </span>

     **[فهرست](#فهرست)**

324. ### خروجی عملگر spread روی آرایه زیر چیه؟

     <span dir="ltr" align="left">

     ```js
     [..."John Resig"];
     ```

     </span>

     خروجی آرایه ['J', 'o', 'h', 'n', ', 'R', 'e', 's', 'i', 'g'] است.
     **توضیح:** رشته یه نوع تکرارپذیره و عملگر spread تو یه آرایه هر کاراکتر یه تکرارپذیر رو به یه عنصر نگاشت میکنه. از این رو، هر کاراکتر یه رشته به عنصری تو یه آرایه تبدیل می‌شه.

     **[فهرست](#فهرست)**

325. ### آیا PostMessage امنه؟

     بله، تا زمانی که برنامه‌نویس/توسعه‌دهنده مراقب منشأ و منبع پیام دریافتی باشه، postMessages رو می‌شه بسیار امن در نظر گرفت. اما اگه بخواییم پیامی رو بدون تأیید منبع آن ارسال یا دریافت کنیم حملات اسکریپت بین سایتی ایجاد می‌شه.

     **[فهرست](#فهرست)**

326. ### مشکلات استفاده از postmessage با origin روی wildcard چیه؟

     آرگومان دوم متد postMessage مشخص میکنه که کدوم مبدا مجاز به دریافت پیامه. اگه از علامت "\*" به عنوان آرگومان استفاده کنیم هر منبعی مجاز به دریافت پیامه. در این حالت، هیچ راهی برای پنجره فرستنده وجود نداره که بفهمه پنجره هدف در موقع ارسال پیام در مبدأ هدف قرار داره یا نه. اگه پنجره هدف به مبدأ دیگری هدایت شه، مبدا دیگر داده‌ها رو دریافت میکنه. از این رو، این ممکنه منجر به آسیب پذیری‌های XSS شه.

     <span dir="ltr" align="left">

     ```js
     targetWindow.postMessage(message, "*");
     ```

     </span>

     **[فهرست](#فهرست)**

327. ### چطوری از دریافت postMessageهای ناخواسته و ناامن از طرف هکرها جلوگیری کنیم؟

     از اونجایی که شنونده به هر پیامی گوش میده، مهاجم میتونه برنامه رو با ارسال پیامی از مبدأ مهاجم فریب بده که این تصور رو ایجاد میکنه که گیرنده پیام رو از پنجره فرستنده واقعی دریافت کرده. می‌تونیم با اعتبارسنجی مبدا پیام در انتهای گیرنده با استفاده از ویژگی "message.origin" از این مشکل جلوگیری کنیم. برای مثال، اجازه بدین مبدا فرستنده [http://www.some-sender.com](http://www.some-sender.com) در سمت گیرنده [www.some-receiver.com] (www.some) رو بررسی کنیم -receiver.com)،

     <span dir="ltr" align="left">

     ```js
     //Listener on http://www.some-receiver.com/
     window.addEventListener("message", function(message){
         if(/^http://www\.some-sender\.com$/.test(message.origin)){
              console.log('You received the data from valid sender', message.data);
        }
     });
     ```

     </span>

     **[فهرست](#فهرست)**

328. ### می‌تونیم کلا postMessageها رو غیرفعال کنیم؟

     نمی‌تونیم به طور کامل (یا 100٪) از postMessages استفاده نکنیم. حتی اگه برنامه‌مون با توجه به خطرات از postMessage استفاده نمیکنه، بسیاری از اسکریپت‌های شخص ثالث از postMessage برای برقراری ارتباط با سرویس شخص ثالث استفاده می‌کنن. بنابراین ممکنه برنامه بدون اطلاع شما از postMessage استفاده کنه.

     **[فهرست](#فهرست)**

329. ### آیا postMessageها به صورت synchronous و همزمان کار می‌کنن؟

     `postMessages` در مرورگر IE8 `synchronous` هستن اما در IE9 و سایر مرورگرهای مدرن دیگر (یعنی IE9+، Firefox، Chrome، Safari) `asynchronous` هستن. به دلیل این رفتار asyncو زمانی که `postMessage` برگردونده می‌شه، از مکانیزم `callback` استفاده می‌کنیم.

     **[فهرست](#فهرست)**

330. ### پارادیم زبان جاواسکریپت چیه؟

     جاواسکریپت یه زبان چند پارادایمه که از برنامه نویسی امری/روشی، برنامه نویسی شی گرا و برنامه نویسی تابعی پشتیبانی میکنه. جاواسکریپت از برنامه نویسی شی گرا با وراثت اولیه پشتیبانی میکنه.

     **[فهرست](#فهرست)**

331. ### تفاوت‌های بین جاواسکریپت داخلی و خارجی چیه؟

     **جاواسکریپت داخلی:** کد منبع درون تگ اسکریپته.
     **جاواسکریپت خارجی:** کد منبع تو یه فایل خارجی (ذخیره شده با پسوند js.) ذخیره می‌شه و در تگ ارجاع می‌شه.

     **[فهرست](#فهرست)**

332. ### آیا جاواسکریپت سریعتر از اسکریپت‌های سمت سرور است؟

     بله، جاواسکریپت سریعتر از اسکریپت سمت سروره. از اونجایی که جاواسکریپت یه اسکریپت سمت کلاینته برای محاسبات یا محاسبات خودش به کمک سرور وب نیازی نداره. بنابراین جاواسکریپت همیشه سریعتر از هر اسکریپت سمت سرور مانند ASP، PHP و غیره اس.

     **[فهرست](#فهرست)**

333. ### چطوری وضعیت چک بودن یه checkbox رو بدست بیاریم؟

     می‌تونیم ویژگی`checked` رو در کادر انتخاب شده در DOM اعمال کنیم. اگه مقدار "True" باشه به این معنیه که چک باکس علامت زده شده در غیر این صورت علامت اونو بردارین. برای مثال، عنصر چک باکس HTML زیر رو می‌شه با استفاده از جاواسکریپت به صورت زیر در دسترس قرار داد:

     <span dir="ltr" align="left">

     ```html
     <input type="checkbox" name="checkboxname" value="Agree" /> Agree the
     conditions<br />
     ```

     </span>

     <span dir="ltr" align="left">

     ```js
     console.log(document.getElementById("checkboxname").checked); // true or false
     ```

     </span>

     **[فهرست](#فهرست)**

334. ### هدف از عملگر double-tilde چیه؟

     عملگر دابل tilde(~~) به عنوان عملگر `bitwise double NOT` شناخته می‌شه. این عملگر قراره جایگزین سریع تری برای `Math.floor`.

     **[فهرست](#فهرست)**

335. ### چطوری یه کاراکتر رو به کد ASCII تبدیل کنیم؟

     برای تبدیل کاراکترهای رشته به اعداد اسکی می‌تونیم از متد `String.prototype.charCodeAt` استفاده کنیم. برای مثال، بیاین کد ASCII رو برای حرف اول رشته «ABC» پیدا کنیم:

     <span dir="ltr" align="left">

     ```js
     "ABC".charCodeAt(0); // returns 65
     ```

     </span>

     در حالی که روش `String.fromCharCode` اعداد رو به کاراکترهای `ASCII` برابر تبدیل میکنه.

     <span dir="ltr" align="left">

     ```js
     String.fromCharCode(65, 66, 67); // returns 'ABC'
     ```

     </span>

     **[فهرست](#فهرست)**

336. ### ArrayBuffer چیه؟

     یه گلاس `ArrayBuffer` برای نشون دادن یه بافر داده باینری خام عمومی با طول ثابت استفاده می‌شه. می‌تونیم اونو به صورت زیر ایجاد کنیم:

     <span dir="ltr" align="left">

     ```js
     const buffer = new ArrayBuffer(16); // create a buffer of length 16
     alert(buffer.byteLength); // 16
     ```

     </span>

     برای دستکاری یه `ArrayBuffer،` باید از یه کلاس `DataView` استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     // Create a DataView referring to the buffer
     const view = new DataView(buffer);
     ```

     </span>

     **[فهرست](#فهرست)**

337. ### خروجی کد زیر چی خواهد بود؟

     <span dir="ltr" align="left">

     ```js
     console.log("Welcome to JS world"[0]);
     ```

     </span>

     خروجی عبارت بالا "W" عه.
     **توضیح:** نماد براکت با شاخص خاص روی یه رشته کاراکتر رو تو یه مکان خاص برمی‌گردونه. از این رو، کاراکتر "W" رشته رو برمی‌گردونه. از اونجایی که این مورد در نسخه‌های IE7 و پایین‌تر پشتیبانی نمی‌شه، ممکنه لازم باشه از متد charAt برای به دست آوردن نتیجه دلخواه استفاده کنیم.

     **[فهرست](#فهرست)**

338. ### هدف از Error-object چیه؟

     کلاس Error یه آبجکت error ایجاد میکنه و نمونه‌هایی از آبجکت‌های خطا موقع رخ دادن خطاهای زمان اجرا ارسال میشن، آبجکت Error همچنین میتونه به عنوان یه آبجکت پایه برای استثناهای تعریف شده توسط کاربر استفاده شه. برای مثال

     <span dir="ltr" align="left">

     ```js
     new Error([message[, fileName[, lineNumber]]])
     ```

     </span>

     می‌تونیم استثناها یا خطاهای تعریف شده توسط کاربر رو با استفاده از آبجکت Error در بلوک try...catch مثل کد زیر ارسال کنیم.

     <span dir="ltr" align="left">

     ```js
     try {
       if (withdraw > balance)
         throw new Error("Oops! You don't have enough balance");
     } catch (e) {
       console.log(`${e.name}: ${e.message}`);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

339. ### هدف از EvalError-object چیه؟

     آبجکت `EvalError` یه خطا راجع به استفاده از تابع `eval` رو نشون میده. البته دیگه این استثنا توسط جاواسکریپت ایجاد نمی‌شه و آبجکت EvalError فقط برای سازگاری با نسخه‌های باقی مونده. برای مثال

     <span dir="ltr" align="left">

     ```js
     new EvalError([message[, fileName[, lineNumber]]])
     ```

     </span>

     می‌تونیم EvalError رو با بلوک try...catch مثل کد زیر ارسال کنیم.

     <span dir="ltr" align="left">

     ```js
     try {
       throw new EvalError("Eval function error", "someFile.js", 100);
     } catch (e) {
       console.log(e.message, e.name, e.fileName); // "Eval function error", "EvalError", "someFile.js"
     }
     ```

     </span>

     **[فهرست](#فهرست)**

340. ### خطاهایی که در حالت strict-mode رخ میدن ولی در غیر اون وجود ندارن کدوما هستن؟

     وقتی `use strict` رو اعمال می‌کنیم. syntax، بعضی از موارد زیر قبل از اجرای اسکریپت یه SyntaxError ایجاد می‌کنن

     1. وقتی از دستور `Octal` استفاده می‌کنیم

     <span dir="ltr" align="left">

     ```js
     const n = 022;
     ```

     </span>

     2. استفاده از عبارت `with`.
     3. وقتی از عملگر حذف روی نام متغیر استفاده می‌کنیم
     4. استفاده از eval یا آرگومان‌ها به عنوان متغیر یا نام آرگومان تابع
     5. موقعی که از کلمات کلیدی رزرو شده جدید استفاده می‌کنیم
     6. موقعی که یه تابع رو تو یه بلوک اعلام می‌کنیم

     <span dir="ltr" align="left">

     ```js
     if (someCondition) {
       function f() {}
     }
     ```

     </span>

     از این رو، خطاهای موارد بالا برای جلوگیری از خطا در محیط‌های توسعه/تولید مفید هستن.

     **[فهرست](#فهرست)**

341. ### آیا همه objectها دارای prototype هستن؟

     خیر. همه objectها دارای prototype هستن به جز object پایه که توسط کاربر ایجاد می‌شه یا آبجکت‌ای که با استفاده از کلمه کلیدی new ایجاد می‌شه.

     **[فهرست](#فهرست)**

342. ### تفاوت‌های بین parameter و argument چیه؟

     `parameter` نام متغیر تعریف یه تابعه در حالی که یه `argument` نشون دهنده مقدار داده شده به تابع موقع فراخونای شدنشه. بیاین این رو با یه تابع ساده توضیح بدیم

     <span dir="ltr" align="left">

     ```js
     function myFunction(parameter1, parameter2, parameter3) {
       console.log(arguments[0]); // "argument1"
       console.log(arguments[1]); // "argument2"
       console.log(arguments[2]); // "argument3"
     }
     myFunction("argument1", "argument2", "argument3");
     ```

     </span>

     **[فهرست](#فهرست)**

343. ### هدف از متد some روی آرایه‌ها چیه؟

     متد `some` برای تست این که حداقل یه عنصر در آرایه، از تست پیاده‌سازی شده توسط تابع ارائه شده، عبور میکنه یا نه استفاده می‌شه. متد یه مقدار بولین برمی‌گردونه. بیاین مثالی بزنیم تا هر عنصر رو بر اساس داشتن عدد زوج آزمایش کنیم:

     <span dir="ltr" align="left">

     ```js
     const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

     const odd = (element) => element % 2 !== 0;

     console.log(array.some(odd)); // true (the odd element exists)
     ```

     </span>

     **[فهرست](#فهرست)**

344. ### چطوری دو یا تعداد بیشتری از آرایه‌ها رو با هم ترکیب کنیم؟

     متد `concat` برای ترکیب دو یا چند آرایه با برگردوندن یه آرایه جدید حاوی تمام عناصر استفاده می‌شه.مثال:

     <span dir="ltr" align="left">

     ```js
     array1.concat(array2, array3, ..., arrayX)
     ```

     </span>

     بیاین مثالی از الحاق آرایه با آرایه‌های veggies و fruits رو مثال بزنیم.

     <span dir="ltr" align="left">

     ```js
     const veggies = ["Tomato", "Carrot", "Cabbage"];
     const fruits = ["Apple", "Orange", "Pears"];
     const veggiesAndFruits = veggies.concat(fruits);
     console.log(veggiesAndFruits); // Tomato, Carrot, Cabbage, Apple, Orange, Pears
     ```

     </span>

     **[فهرست](#فهرست)**

345. ### تفاوت‌های بین Shallow و Deep کپی چیه؟

     **کپی سطحی:**
     کپی کم عمق یه کپی بیتی از یه آبجکته. یه آبجکت جدید ایجاد می‌شه که یه کپی دقیق از مقادیر موجود در آبجکت اصلی رو داره. اگه هر یه از فیلدهای آبجکت ارجاع به آبجکت‌های دیگه باشه، فقط آدرس‌های مرجع کپی میشن یعنی فقط آدرس توی حافظه کپی می‌شه.

     **مثال**

      <span dir="ltr" align="left">

     ```js
     const empDetails = {
       name: "John",
       age: 25,
       expertise: "Software Developer",
     };
     ```

      </span>

     برای ایجاد یه نسخه تکراری

      <span dir="ltr" align="left">

     ```js
     const empDetailsShallowCopy = empDetails; // Shallow copying!
     ```

      </span>

     اگه مقداری از ویژگی رو تو یه تکراری به این صورت تغییر بدیم:

      <span dir="ltr" align="left">

     ```js
     empDetailsShallowCopy.name = "Johnson";
     ```

      </span>

     دستور بالا همچنین نام `empDetails` رو تغییر میده، چون ما یه کپی کم عمق داریم. یعنی ما داده‌های اصلی رو هم از دست می دیم.

     **کپی عمیق(Deep):**
     یه کپی عمیق همه فیلدها رو کپی میکنه و از حافظه تخصیص یافته به صورت پویا که توسط فیلدها به آن اشاره می‌شه کپی میکنه. یه کپی عمیق زمانی اتفاق میوفته که یه آبجکت همراه با پراپرتی‌هایی که به اون اشاره داره کپی شه.

     **Example**

      <span dir="ltr" align="left">

     ```js
     const empDetails = {
       name: "John",
       age: 25,
       expertise: "Software Developer",
     };
     ```

      </span>

     یه کپی عمیق با استفاده از خواص از آبجکت اصلی در متغیر جدید ایجاد کنیم:

      <span dir="ltr" align="left">

     ```js
     const empDetailsDeepCopy = {
       name: empDetails.name,
       age: empDetails.age,
       expertise: empDetails.expertise,
     };
     ```

      </span>

     اگه `empDetailsDeepCopy.name` رو تغییر بدین، فقط `empDetailsDeepCopy` و نه `empDetails` رو تحت تأثیر قرار میده.

     **[فهرست](#فهرست)**

346. ### چطوری می‌تونیم به یه تعداد مشخص از یه رشته کپی کنیم؟

     متد`repeat` برای ساخت و برگردوندن یه رشته جدید استفاده می‌شه که حاوی تعداد مشخصی از کپی‌های رشته‌ای هس که روی اون فراخوانی شده و به هم پیوسته شدن. یادتون باشه که این روش به مشخصات ECMAScript 2015 اضافه شده است.
     بیاین یه مثال از رشته Hello رو برای تکرارش 4 بار در نظر بگیریم:

     <span dir="ltr" align="left">

     ```js
     "Hello".repeat(4); // 'HelloHelloHelloHello'
     ```

     </span>

347. ### چطوری همه stringهای match شده با یه regular-expression رو برگردونیم؟

     متد `matchAll` می‌تواند برای برگردوندن یه تکرارکننده از تمام نتایجی که یه رشته با یه عبارت منظم مطابقت دارن، استفاده شه. مثال زیر آرایه ای از نتایج رشته منطبق رو در برابر یه عبارت منظم برمی‌گردونه:

     <span dir="ltr" align="left">

     ```js
     let regexp = /Hello(\d?))/g;
     let greeting = "Hello1Hello2Hello3";

     let greetingList = [...greeting.matchAll(regexp)];

     console.log(greetingList[0]); //Hello1
     console.log(greetingList[1]); //Hello2
     console.log(greetingList[2]); //Hello3
     ```

     </span>

     **[فهرست](#فهرست)**

348. ### چطوری یه رشته رو از اول یا از آخر trim کنیم؟

     روش `trim prototype` رشته برای برش دادن دو طرف یه رشته استفاده می‌شه. اما اگه بخوایم به‌خصوص در ابتدا یا انتهای رشته رو برش بدیم، می‌تونیم از روش‌های `trimStart/trimLeft` و `trimEnd/trimRight` استفاده کنیم. بیاین نمونه ای از این روش‌ها رو در پیام greeting ببینیم:

     <span dir="ltr" align="left">

     ```js
     const greeting = "   Hello, Goodmorning!   ";

     console.log(greeting); // "   Hello, Goodmorning!   "
     console.log(greeting.trimStart()); // "Hello, Goodmorning!   "
     console.log(greeting.trimLeft()); // "Hello, Goodmorning!   "

     console.log(greeting.trimEnd()); // "   Hello, Goodmorning!"
     console.log(greeting.trimRight()); // "   Hello, Goodmorning!"
     ```

     </span>

     **[فهرست](#فهرست)**

349. ### خروجی کنسول زیر با عملگر unary چی می‌شه؟

     <span dir="ltr" align="left">

     ```js
     console.log(+"Hello");
     ```

     </span>

     خروجی دستور log کنسول بالا NaN رو برمی‌گردونه. از اونجا که عنصر توسط عملگر unary پیشونده و مفسر جاواسکریپت سعی میکنه اون عنصر رو به یه نوع عدد تبدیل کنه. از اونجایی که تبدیل با شکست مواجه می‌شه، مقدار عبارت به مقدار NaN منجر می‌شه.

     **[فهرست](#فهرست)**

350. ### آیا جاواسکریپت از mixinها استفاده میکنه؟

     `Mixin` - یک اصطلاح برنامه نویسی شی گرا عمومیه: کلاسی که شامل متدهایی برای کلاس‌های دیگه اس. برخی از زبان‌های دیگر به ارث بردن چندگانه اجازه میدن. جاوا اسکریپت از وراثت چندگانه پشتیبانی نمیکنه، اما `Mixin`‌ها رو میشه با کپی کردن متد‌ها در نمونه اولیه پیاده سازی کرد.

     **[فهرست](#فهرست)**

351. ### تابع thunk چیه و چیکار میکنه؟

     `thunk` فقط تابعیه که ارزیابی مقدار رو به تاخیر می‌ندازه. هیچ آرگومانی نمی‌گیره، اما هر زمان که `thunk` رو فراخوانی می‌کنیم مقدار رو میده. برای مثال، از اون استفاده می‌شه که الان اجرا نشه، اما زمانی در آینده اجرا می‌شه. بیاین یه مثال sync بگیریم:

     <span dir="ltr" align="left">

     ```js
     const add = (x, y) => x + y;

     const thunk = () => add(2, 3);

     thunk(); // 5
     ```

     </span>

     **[فهرست](#فهرست)**

352. ### thunkهای asynchronous چیکار می‌کنن؟

     `Thunk`‌های `asynchronous` برای ایجاد درخواست‌های شبکه مفید هستن. بیاین نمونه ای از درخواست‌های شبکه رو ببینیم:

     <span dir="ltr" align="left">

     ```js
     function fetchData(fn) {
       fetch("https://jsonplaceholder.typicode.com/todos/1")
         .then((response) => response.json())
         .then((json) => fn(json));
     }

     const asyncThunk = function () {
       return fetchData((data) => {
         console.log(data);
       });
     };

     asyncThunk();
     ```

     </span>

     تابع `getData` فوراً فراخونی نمی‌شه و تنها زمانی فراخونی می‌شه که داده‌ها از نقطه پایانی API در دسترس باشن. تابع setTimeout هم برای ناهمزمان کردن کد ما استفاده می‌شه. بهترین مثال زمان واقعی، کتابخونه مدیریت حالت redux هس که از thunk‌های ناهمزمان برای به تاخیر انداختن اعمال برای ارسال استفاده میکنه.

     **[فهرست](#فهرست)**

353. ### خروجی فراخوانی‌های توابع زیر چی می‌شه؟

     **قسمت کد:**

     <span dir="ltr" align="left">

     ```js
     const circle = {
       radius: 20,
       diameter() {
         return this.radius * 2;
       },
       perimeter: () => 2 * Math.PI * this.radius,
     };

     console.log(circle.diameter());
     console.log(circle.perimeter());
     ```

     </span>

     **خروجی:**

     خروجی 40 و NaN هس. یادتون باشه که diameter یه تابع منظمه در حالی که مقدار perimeter یه `arrow function` هستش. کلمه کلیدی `this` یه تابع معمولی (یعنی diameter) به محدوده اطراف که یه کلاسه (یعنی آبجکت circle) اشاره داره. در حالی که این کلمه کلیدی تابع perimeter به محدوده اطراف که یه آبجکت window هس اشاره داره. از اونجایی که هیچ ویژگی radius در آبجکت‌های window وجود نداره، یه مقدار undefined برمی‌گردونه و ضرب مقدار، مقدار NaN رو برمی‌گردونه.

     **[فهرست](#فهرست)**

354. ### چطوری همه خطوط جدید رو از یه رشته حذف کرد؟

     ساده ترین روش ٍ استفاده از regex برای شناسایی و جایگزینی خطوط جدید توی رشته اس. در این حالت از تابع replace به همراه رشته برای جایگزینی استفاده می‌کنیم که در این مثال یه رشته خالیه:

     <span dir="ltr" align="left">

     ```js
     function remove_linebreaks( var message ) {
         return message.replace( /[\r\n]+/gm, "" );
     }
     ```

     </span>

     تو عبارت بالا g و m برای flag‌های سراسری و چند خطی هستن.

     **[فهرست](#فهرست)**

355. ### تفاوت‌ بین reflow و repaint چیه؟

     repaintزمانی اتفاق می‌افته که تغییراتی ایجاد می‌شه که روی دید یه عنصر تأثیر میذاره، اما روی طرح اون تأثیر نمیذاره،. نمونه‌هایی از این موارد شامل طرح کلی، نمایان بودن یا رنگ پس زمینه اس. یه _reflow_ شامل تغییراتیه که بر طرح بندی بخشی از صفحه (یا کل صفحه) تأثیر میزاره. تغییر اندازه پنجره مرورگر، تغییر فونت، تغییر محتوا (مانند تایپ متن توسط کاربر)، استفاده از روش‌های جاواسکریپت شامل سبک‌های محاسبه‌شده، اضافه کردن یا حذف عناصر از DOM، و تغییر کلاس‌های یه عنصر چند مورد از مواردی هستن که می‌تونن جریان مجدد رو آغاز کنن. جریان مجدد یه عنصر باعث جریان مجدد بعدی همه عناصر فرزند و اجداد و همچنین هر عنصری که به دنبال اون توی DOM هس می‌شه.

     **[فهرست](#فهرست)**

356. ### اگه قبل از یه آرایه عملگر نفی «!» بزاریم چی می‌شه؟

     نفی یه آرایه با کاراکتر «!»، آرایه رو به یه بولین تبدیل میکنه. از اونجایی که آرایه‌ها true در نظر گرفته میشن، پس نفی اون false رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     console.log(![]); // false
     ```

     </span>

     **[فهرست](#فهرست)**

357. ### اگه دو تا آرایه رو با هم جمع ببندیم چی می‌شه؟

     اگه دو آرایه رو با هم اضافه کنیم هر دو اونا رو به رشته تبدیل میکنه و اونا رو به هم متصل میکنه. برای بریم یه مثال در موردش ببینیم:

     <span dir="ltr" align="left">

     ```js
     console.log(["a"] + ["b"]); // "ab"
     console.log([] + []); // ""
     console.log(![] + []); // "false", because ![] returns false.
     ```

     </span>

     **[فهرست](#فهرست)**

358. ### اگه عملگر جمع «+» روی قبل از مقادیر falsy قرار بدیم چی می‌شه؟

     اگه عملگر additive(+) رو روی مقادیر نادرست (null، undefined، NaN، false، "") قرار بدیم، مقدار falsy به مقدار عددی صفر تبدیل می‌شه. بیاین اونا رو توی کنسول مرورگر به صورت زیر نمایش بدیم:

     <span dir="ltr" align="left">

     ```js
     console.log(+null); // 0
     console.log(+undefined); // NaN
     console.log(+false); // 0
     console.log(+NaN); // NaN
     console.log(+""); // 0
     ```

     </span>

     **[فهرست](#فهرست)**

359. ### چطوری با استفاده از آرایه‌ها و عملگرهای منطقی می‌تونیم رشته self رو تولید کنیم؟

     رشته self رو می‌شه با ترکیب کاراکترهای `[]()!+` تشکیل داد. برای رسیدن به این الگو باید موارد زیر رو بدونیم:

     1. از اونجایی که آرایه‌ها مقادیر true هستن، با نفی آرایه‌ها false تولید می‌شه: ![] === false
     2. طبق قوانین اجباری جاواسکریپت، اضافه کردن آرایه‌ها به هم اونا رو به رشته‌بندی تبدیل میکنه: [] + [] === ""
     3. Prepend یه آرایه با عملگر + یه آرایه رو به نادرست تبدیل میکنه، انکار اونو درست میکنه و در نهایت تبدیل نتیجه مقدار '1' رو تولید میکنه: +(!(+[])) === 1

     با اعمال قوانین بالا می‌تونیم شرایط زیر رو استخراج کنیم:

     <span dir="ltr" align="left">

     ```js
     (![] + [] === `false${!+[]}`) === 1;
     ```

     </span>

     اکنون الگوی کاراکتر به صورت زیر ایجاد می‌شه:

     <span dir="ltr" align="left">

     ```js
           s               e               l               f
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^

      (![] + [])[3] + (![] + [])[4] + (![] + [])[2] + (![] + [])[0]
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^
     (![] + [])[+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]] +
     (![] + [])[+[]]
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     (![]+[])[+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]]+(![]+[])[+[]]
     ```

     </span>

     **[فهرست](#فهرست)**

360. ### چطوری می‌تونیم مقادیر falsy رو از آرایه حذف کنیم؟

     می‌تونیم با وارد کردن Boolean به عنوان پارامتر، روش فیلتر رو روی آرایه اعمال کنیم. به این ترتیب تمام مقادیر falsy (0، undifined، null، false و "") از آرایه حذف می‌شه.

     <span dir="ltr" align="left">

     ```js
     const myArray = [false, null, 1, 5, undefined];
     myArray.filter(Boolean); // [1, 5] // is same as myArray.filter(x => x);
     ```

     </span>

     **[فهرست](#فهرست)**

361. ### چطوری مقادیر تکراری رو از یه آرایه حذف کنیم؟

     می‌تونیم مقادیر یونیک یه آرایه رو با ترکیب دستور "Set" و rest expression/spread(...) دریافت کنیم.

     <span dir="ltr" align="left">

     ```js
     console.log([...new Set([1, 2, 4, 4, 3])]); // [1, 2, 4, 3]
     ```

     </span>

     **[فهرست](#فهرست)**

362. ### aliaseهای همزمان با destructuring چطوری کار می‌کنن؟

     گاهی اوقات لازم داریم یه متغیر `destructure` شده با نامی متفاوت از نام ویژگی داشته باشیم. در این صورت، از یه `: newName` برای تعیین اسم برای متغیر استفاده می‌کنیم. این فرآیند `destructuring aliase` نامیده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const obj = { x: 1 };
     // Grabs obj.x as as { otherName }
     const { x: otherName } = obj;
     ```

     </span>

     **[فهرست](#فهرست)**

363. ### چطوری آیتم‌های یه آرایه رو بدون استفاده از متد map پیمایش کنیم؟

     می‌تونیم مقادیر آرایه‌ها رو بدون استفاده از متد `map` تنها با استفاده از روش `from` آرایه ترسیم کنیم. بیاین نام شهرها رو از آرایه کشورها ترسیم کنیم:

     <span dir="ltr" align="left">

     ```js
     const countries = [
       { name: "India", capital: "Delhi" },
       { name: "US", capital: "Washington" },
       { name: "Russia", capital: "Moscow" },
       { name: "Singapore", capital: "Singapore" },
       { name: "China", capital: "Beijing" },
       { name: "France", capital: "Paris" },
     ];

     const cityNames = Array.from(countries, ({ capital }) => capital);
     console.log(cityNames); // ['Delhi, 'Washington', 'Moscow', 'Singapore', 'Beijing', 'Paris']
     ```

     </span>

     **[فهرست](#فهرست)**

364. ### چطوری یه آرایه رو خالی کنیم؟

     با صفر کردن length آرایه می‌تونیم به سرعت یه آرایه رو خالی کنیم:

     <span dir="ltr" align="left">

     ```js
     const cities = ["Singapore", "Delhi", "London"];
     cities.length = 0; // cities becomes []
     ```

     </span>

     **[فهرست](#فهرست)**

365. ### چطوری اعداد رو با تعداد رقم اعشار مشخص رند می‌کنی؟

     می‌تونیم با استفاده از روش `toFixed` از جاواسکریپت، اعداد رو به تعداد معینی از اعشار گرد کنیم.

     <span dir="ltr" align="left">

     ```js
     let pie = 3.141592653;
     pie = pie.toFixed(3); // 3.142
     ```

     </span>

     **[فهرست](#فهرست)**

366. ### ساده‌ترین روش برای تبدیل آرایه به object چیه؟

     می‌تونیم با استفاده از عملگر spread(...) یه آرایه رو به یه آبجکت با همون داده تبدیل کنیم.

     <span dir="ltr" align="left">

     ```js
     const fruits = ["banana", "apple", "orange", "watermelon"];
     const fruitsObject = { ...fruits };
     console.log(fruitsObject); // {0: "banana", 1: "apple", 2: "orange", 3: "watermelon"}
     ```

     </span>

     **[فهرست](#فهرست)**

367. ### چطوری یه آرایه با یه سری داده درست کنیم؟

     می‌تونیم با استفاده از روش `fill` یه آرایه با مقداری داده یا یه آرایه با همون مقادیر ایجاد کنیم.

     <span dir="ltr" align="left">

     ```js
     const newArray = new Array(5).fill("0");
     console.log(newArray); // ["0", "0", "0", "0", "0"]
     ```

     </span>

     **[فهرست](#فهرست)**

368. ### متغیرهای موجود روی آبجکت console کدوما هستن؟

     1. %o - یه آبجکت رو می‌گیرد،
     2. %s - یه رشته می‌گیره،
     3. %d - برای اعشار یا عدد صحیح استفاده می‌شه
        این متغیرها رو می‌شه توی console.log به صورت زیر نشون داد

     <span dir="ltr" align="left">

     ```js
     const user = { name: "John", id: 1, city: "Delhi" };
     console.log(
       "Hello %s, your details %o are available in the object form",
       "John",
       user
     ); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
     ```

     </span>

     **[فهرست](#فهرست)**

369. ### می‌شه پیام‌های کنسول رو استایل‌دهی کرد؟

     بله، می‌تونیم سبک‌های CSS رو برای پیام‌های کنسول مشابه متن html در صفحه وب اعمال کنیم.

     <span dir="ltr" align="left">

     ```js
     console.log(
       "%c The text has blue color, with large font and red background",
       "color: blue; font-size: x-large; background: red"
     );
     ```

     </span>

     متن به صورت زیر نمایش داده می‌شه
     ![Screenshot](images/console-css.png)

     **نکته:** تمام سبک‌های CSS رو می‌شه برای پیام‌های کنسول اعمال کرد.

     **[فهرست](#فهرست)**

370. ### هدف از متد dir روی آبجکت console چیه؟

     `console.dir` برای نمایش یه لیست تعاملی از ویژگی‌های آبجکت جاواسکریپت مشخص شده به عنوان JSON استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const user = { name: "John", id: 1, city: "Delhi" };
     console.dir(user);
     ```

     </span>

     آبجکت user نمایش داده شده توی حالت JSON
     ![Screenshot](images/console-dir.png)

     **[فهرست](#فهرست)**

371. ### آیا می‌شه المنت‌های HTML رو توی console دیباگ کرد؟

     بله، دریافت و اشکال زدایی عناصر HTML توی کنسول، درست مثل بررسی عناصر، امکان پذیره.

     <span dir="ltr" align="left">

     ```js
     const element = document.getElementsByTagName("body")[0];
     console.log(element);
     ```

     </span>

     این عنصر HTML رو توی کنسول چاپ میکنه،

     ![Screenshot](images/console-html.png)

     **[فهرست](#فهرست)**

372. ### چطوری می‌شه داده‌ها رو به شکل جدولی توی console نمایش بدیم؟

     `console.table` برای نمایش داده‌ها توی کنسول توی یه قالب جدولی برای تجسم آرایه‌ها یا آبجکت‌های پیچیده استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const users = [
       { name: "John", id: 1, city: "Delhi" },
       { name: "Max", id: 2, city: "London" },
       { name: "Rod", id: 3, city: "Paris" },
     ];
     console.table(users);
     ```

     </span>

     داده‌هایی که در قالب جدول مشاهده می‌شن،

     ![Screenshot](images/console-table.png)

     **نکته:** یادتون باشه `console.table` توی مرورگر IE پشتیبانی نمی‌شه :-/

     **[فهرست](#فهرست)**

373. ### چطوری می‌شه بررسی کرد که یه پارامتر Number هست یا نه؟

     ترکیبی از روش‌های IsNaN و isFinite برای تأیید عدد بودن یا نبودن آرگومان استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     function isNumber(n) {
       return !isNaN(parseFloat(n)) && isFinite(n);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

374. ### چطوری یه متن رو می‌تونیم به clipboard کپی کنیم؟

     ما باید محتوا (با استفاده از روش .select) عنصر ورودی رو انتخاب کنیم و دستور copy رو با execCommand اجرا کنیم (یعنی execCommand('copy')). همچنین می‌تونیم سایر دستورات سیستم مثل cut و paste رو اجرا کنیم.

     <span dir="ltr" align="left">

     ```js
     document.querySelector("#copy-button").onclick = function () {
       // Select the content
       document.querySelector("#copy-input").select();
       // Copy to the clipboard
       document.execCommand("copy");
     };
     ```

     </span>

     **[فهرست](#فهرست)**

375. ### چطوری می‌شه timestamp رو بدست آورد؟

     می‌تونیم از `Date.getTime` برای دریافت مهر زمانی فعلی استفاده کنیم. یه میانبر جایگزین برای دریافت مقدار وجود داره.

     <span dir="ltr" align="left">

     ```js
     console.log(+new Date());
     console.log(Date.now());
     ```

     </span>

     **[فهرست](#فهرست)**

376. ### چطوری یه آرایه چندسطحی رو تک سطحی کنیم؟

     مسطح کردن آرایه‌های دو بعدی با عملگر Spread کاربرد نداره.

     <span dir="ltr" align="left">

     ```js
     const biDimensionalArr = [11, [22, 33], [44, 55], [66, 77], 88, 99];
     const flattenArr = [].concat(...biDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     </span>

     اما ما می‌تونیم اونو با آرایه‌های چند بعدی با فراخوانی‌های `recursive` کال کنیم:

     <span dir="ltr" align="left">

     ```js
     function flattenMultiArray(arr) {
       const flattened = [].concat(...arr);
       return flattened.some((item) => Array.isArray(item))
         ? flattenMultiArray(flattened)
         : flattened;
     }
     const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
     const flatArr = flattenMultiArray(multiDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     </span>

     **[فهرست](#فهرست)**

377. ### ساده‌ترین روش برای بررسی چندشرطی چیه؟

     می‌تونیم از تابع `indexOf`» برای مقایسه ورودی با چندین مقدار به جای بررسی هر مقدار به عنوان یه شرط استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     // Verbose approach
     if (
       input === "first" ||
       input === 1 ||
       input === "second" ||
       input === 2
     ) {
       someFunction();
     }
     // Shortcut
     if (["first", 1, "second", 2].indexOf(input) !== -1) {
       someFunction();
     }
     ```

     </span>

     **[فهرست](#فهرست)**

378. ### چطوری کلیک روی دکمه برگشت مرورگر رو متوجه بشیم؟

     روش `window.onbeforeunload` برای ضبط رویدادهای دکمه بازگشت مرورگر استفاده می‌شه. این برای هشدار دادن به کاربرها در مورد از دست دادن داده‌های فعلی میتونه استفاده. syntax تعریف کردنش به صورت زیر هست:

     <span dir="ltr" align="left">

     ```js
     window.onbeforeunload = function () {
       alert("You work will be lost");
     };
     ```

     </span>

     **[فهرست](#فهرست)**

379. ### چطوری می‌تونیم کلیک راست رو غیرفعال کنیم؟

     کلیک راست روی صفحه رو می‌شه با برگردوندن false از ویژگی `oncontextmenu` در تگ body غیرفعال کرد.

     <span dir="ltr" align="left">

     ```html
     <body oncontextmenu="return false;"></body>
     ```

     </span>

     **[فهرست](#فهرست)**

380. ### object-wrapperها چی هستن؟

     مقادیر اولیه مانند رشته، عدد و بولین پراپرتی و متدی ندارن، اما زمانی که می‌خوایم کارهایی رو روی اونا انجام بدیم، به طور موقت به یه آبجکت (آبجکت Wrapper) تبدیل می‌شن. برای مثال، اگه متد UpperCase رو روی یه مقدار رشته اولیه اعمال کنیم خطایی ایجاد نمیکنه، اما حروف بزرگ رشته رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```js
     const name = "john";

     console.log(name.toUpperCase());
     // Behind the scenes treated as console.log(new String(name).toUpperCase());
     ```

     </span>

     یعنی هر اولیه به جز null و undefined دارای Wrapper Object هس و لیست اشیاء wrapper عبارتند از String، Number، Boolean، Symbol و BigInt.

     **[فهرست](#فهرست)**

381. ### AJAX چیه؟

     `AJAX` مخفف `Asynchronous JavaScript XML` هس و گروهی از فناوری‌های مرتبط (HTML، CSS، JavaScript، XMLHttpRequest API و غیره) که برای نمایش داده‌ها به صورت ناهمزمان استفاده می‌شه. یعنی ما می‌تونیم داده‌ها رو به سرور ارسال کنیم و بدون بارگیری مجدد صفحه وب، داده‌ها رو از سرور دریافت کنیم.

     **[فهرست](#فهرست)**

382. ### روش‌های مختلف مدیریت یه کد Asynchronous چیه؟

     1. callback ‌ها
     2. Promise‌ها
     3. Async/await
     4. کتابخونه‌های شخص ثالث مانند async.js، bluebird و غیره

     **[فهرست](#فهرست)**

383. ### چطوری یه درخواست fetch رو کنسل کنیم؟

     یکی از ضعف Promise‌ها اینه که native راه مستقیمی برای لغو درخواست fetch نیست. اما `AbortController` جدید از مشخصات js به ما امکان میده که از یه سیگنال واسه لغو یک یا چند درخواست fetch استفاده کنیم.
     جریان اصلی لغو یه درخواست fetch اینجوری می‌شه.

     1. یه کلاس `AbortControlle` ایجاد کنیم
     2. ویژگی سیگنال اون آبجکت ساخته شده رو دریافت کنیم و سیگنال رو به عنوان یه option به متد fetch ارسال کنیم
     3. برای لغو تمام fetch‌هایی که از اون سیگنال استفاده می‌کنن با ویژگی abort از AbortController رو فراخوانی کنیم.
        برای مثال، بیاین یه سیگنال رو به چندین درخواست fetch ارسال کنیم، همه درخواست‌ها بااون سیگنال لغو میشن.

     <span dir="ltr" align="left">

     ```js
     const controller = new AbortController();
     const { signal } = controller;

     fetch("http://localhost:8000", { signal })
       .then((response) => {
         console.log("Request 1 is complete!");
       })
       .catch((e) => {
         if (e.name === "AbortError") {
           // We know it's been canceled!
         }
       });

     fetch("http://localhost:8000", { signal })
       .then((response) => {
         console.log("Request 2 is complete!");
       })
       .catch((e) => {
         if (e.name === "AbortError") {
           // We know it's been canceled!
         }
       });

     // Wait 2 seconds to abort both requests
     setTimeout(() => controller.abort(), 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

384. ### Speech-API چیه؟

     API گفتار وب برای فعال کردن مرورگرهای مدرن برای شناسایی و ترکیب گفتار (یعنی داده‌های صوتی در برنامه‌های وب) استفاده می‌شه. این API توسط انجمن W3C در سال 2012 معرفی شد و دارای دو بخش اصلیه.

     1. **تشخیص گفتار (تشخیص گفتار ناهمزمان یا گفتار به متن):** این امکان رو فراهم میکنه که زمینه صدا رو از ورودی صوتی تشخیص داده و به اون پاسخ بدین. این توسط رابط "SpeechRecognition" قابل دسترسیه.
        مثال زیر نحوه استفاده از این API برای دریافت متن از گفتار رو نشون میده.

     <span dir="ltr" align="left">

     ```js
     window.SpeechRecognition =
       window.webkitSpeechRecognition || window.SpeechRecognition; // webkitSpeechRecognition for Chrome and SpeechRecognition for FF
     const recognition = new window.SpeechRecognition();
     recognition.onresult = (event) => {
       // SpeechRecognitionEvent type
       const speechToText = event.results[0][0].transcript;
       console.log(speechToText);
     };
     recognition.start();
     ```

     </span>

     در این API، مرورگر برای استفاده از میکروفون‌ کاربر ازش اجازه می خواد

     2. **SpeechSynthesis (Text-to-Speech):** این امکان رو فراهم میکنه تا یه متن رو به صدا تبدیل کنیم و به وسیله "SpeechSynthesisAPI" قابل دسترسیه.

     برای مثال، کد زیر برای دریافت صدا/گفتار از متن استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     if ("speechSynthesis" in window) {
       const speech = new SpeechSynthesisUtterance("Hello World!");
       speech.lang = "en-US";
       window.speechSynthesis.speak(speech);
     }
     ```

     </span>

     نمونه‌های بالا رو می‌شه روی کنسول برنامه‌نویس مرورگر کروم (33+) تست کرد.
     **توجه:** این API هنوز یه پیش‌نویس فعاله و فقط روی مرورگرهای کروم و فایرفاکس وجود داره(البته کروم فقط مشخصات رو اجرا میکنه)

     **[فهرست](#فهرست)**

385. ### حداقل timeout توی throttling چقدره؟

     هم مرورگر و هم محیط‌های جاواسکریپت NodeJS با حداقل تاخیری که بیشتر از 0 میلی ثانیه اس throttles رو انجام میدن. یعنی حتی اگه تنظیم یه تاخیر 0ms به طور آنی اتفاق نیوفته.
     **مرورگرها:** حداقل 4 میلی ثانیه تاخیر دارن. این throttles زمانی اتفاق میوفته که تماس‌های متوالی به دلیل تودرتوی Callback (عمق معین) یا پس از تعداد معینی فواصل متوالی آغاز شه.
     توجه: مرورگرهای قدیمی حداقل 10 میلی ثانیه تاخیر دارن.
     **Nodejs:** حداقل 1ms تاخیر دارن. این throttles زمانی اتفاق میوفته که تاخیر بزرگتر از 2147483647 یا کمتر از 1 باشه.
     بهترین مثال برای توضیح این رفتار throttling وقفه، ترتیب قطعه کد.

     <span dir="ltr" align="left">

     ```js
     function runMeFirst() {
       console.log("My script is initialized");
     }
     setTimeout(runMeFirst, 0);
     console.log("Script loaded");
     ```

     </span>

     و خروجی

     <span dir="ltr" align="left">

     ```cmd
     Script loaded
     My script is initialized
     ```

     </span>

     اگه از «setTimeout» استفاده نمی‌کنیم ترتیب گزارش‌ها این شکلی می‌شه.

     <span dir="ltr" align="left">

     ```js
     function runMeFirst() {
       console.log("My script is initialized");
     }
     runMeFirst();
     console.log("Script loaded");
     ```

     </span>

     و خروجی

     <span dir="ltr" align="left">

     ```cmd
     My script is initialized
     Script loaded
     ```

     </span>

     **[فهرست](#فهرست)**

386. ### چطوری می‌شه یه timeout صفر توی مرورگر اجرا کرد؟

     به دلیل حداقل تاخیر بیش از 0 میلی ثانیه، نمی‌تونیم از setTimeout(fn, 0) برای اجرای فوری کد استفاده کنیم، اما برای دستیابی به این رفتار می‌تونیم از window.postMessage() استفاده کنیم.

     **[فهرست](#فهرست)**

387. ### taskها توی event-loop چی هستن؟

     وظیفه هر کد/برنامه جاواسکریپتیه که قراره توسط مکانیسم‌های استانداره اجرا شه، مثل شروع اولیه اجرای یه برنامه، اجرای یه رویداد، callback یا یه بازه زمانی یا وقفه در حال اجرا. همه این وظایف تو یه صف کار برنامه ریزی میشن
     موارد استفاده برای افزودن وظایف به صف کار اینا هستن.

     1. موقعی که یه برنامه جاواسکریپت جدید مستقیماً از کنسول اجرا می‌شه یا توسط عنصر `<script>` اجرا می‌شه، وظیفه به صف کار اضافه می‌شه.
     2. موقعی که یه رویداد فراخونی میشه، callback رویداد به صف کار اضافه می‌شه
     3. وقتی به یه setTimeout یا setInterval رسید، callback مربوطه به صف کار اضافه می‌شه

     **[فهرست](#فهرست)**

388. ### microtaskها چی هستن؟

     Microtask کد جاواسکریپت‌ـه که باید بلافاصله پس از تکمیل task/Microtask در حال اجرا اجرا شه. اونا در واقع به نوعی مسدود کننده هستن. یعنی تا زمانی که صف microtask خالی نشه، رشته اصلی مسدود می‌شه.
     منابع اصلی Microtaskها عبارتند از Promise.resolve، Promise.reject، MutationObservers، IntersectionObservers و غیره.

     **توجه:** همه این Microtaskها توی همون چرخش event-loop پردازش میشن.

     **[فهرست](#فهرست)**

389. ### event-loopهای مختلف کدوما هستن؟

     MainAppLoop - این حلقه اصلی یه برنامه اس. به طور معمول این تو پایین صفحه اصلیه. خروج معمولاً نشون دهنده تمایل به بسته شدن برنامه اس. توی هر برنامه فقط یکی از این موارد می‌تونه وجود داشته باشه. ThreadLoop - این حلقه ایه که معمولاً تو پایین رویه اصلی یه UI Thread یافت می‌شه.

     **[فهرست](#فهرست)**

390. ### هدف از queueMicrotask چیه؟

     صف میکروتسک به کد اجازه میده بدون تداخل با کدهای دیگه که در حالت تعلیق هستن، با اولویت بالاتری اجرا بشه.

     **[فهرست](#فهرست)**

391. ### چطوری می‌شه از کتابخونه‌های جاواسکریپت توی فایل typescript استفاده کرد؟

     مشخصه که همه‌ی کتابخونه‌ها یا چارچوب‌های جاواسکریپت دارای فایل‌های اعلان TypeScript نیستن. اما اگه هنوزم می‌خواین از کتابخونه‌ها یا فریم‌ورک‌ها تو فایل‌های TypeScript بدون دریافت خطاهای کامپایل استفاده کنیم تنها راه‌حل کلمه کلیدی `declare` به همراه یه اعلان متغیره. برای مثال، بیاین تصور کنیم که یه کتابخونه‌ به نام "customLibrary" دارید که اعلان TypeScript نداره و فضای نامی به نام customLibrary توی فضای نام گلوبال داره. می‌تونیم از این کتابخونه توی کد تایپ‌اسکریپت به صورت زیر استفاده کنیم.

     <span dir="ltr" align="left">

     ```js
     declare var customLibrary;
     ```

     </span>

     در زمان اجرا، تایپ‌اسکریپت نوع اونو به متغیر `customLibrary` به صورت any ارائه میکنه. جایگزین دیگه بدون استفاده از کلمه کلیدی declare رو تو مثال زیر ببینیم:

     <span dir="ltr" align="left">

     ```js
     var customLibrary: any;
     ```

     </span>

     **[فهرست](#فهرست)**

392. ### تفاوت‌های بینPromiseها و observableها کدوما هستن؟

     | Promise‌ها                                     | observableها                                                                            |
     | ---------------------------------------------- | --------------------------------------------------------------------------------------- |
     | فقط یه مقدار رو تو یه زمان منتشر میکنه         | چندین مقدار رو تو یه دوره زمانی منتشر میکنه (جریان مقادیری از 0 تا چندگانه)             |
     | قراره فوراً فراخوانی شن                        | اونا برای فراخوانی نیاز به اشتراک دارن                                                  |
     | Promise همیشه ناهمزمانه حتی اگه بلافاصله حل شه | observableها میتونن همزمان یا ناهمزمان                                                  |
     | هیچ اپراتور ارائه نمیده                        | اپراتورهایی مانند map، forEach، filter، reduce، retry و retryWhen و غیره رو ارائه میده. |
     | قابل لغو نیست                                  | با استفاده از روش unsubscribe لغو میشن                                                  |

     **[فهرست](#فهرست)**

393. ### heap چیه؟

     Heap (یا memory heap) محلیه که تو اون آبجکت‌ها موقع تعریف متغیرها ذخیره میشن یعنی این محلیه که تمام تخصیص حافظه و عدم تخصیص تو اون انجام می‌شه. هر دو heap و call-stack دو ظرف زمان اجرا JS هستن.
     هر زمان که زمان اجرا با متغیرها و اعلان‌های تابع در کد مواجه می‌شه، اونا رو توی Heap ذخیره میکنه.

     ![Screenshot](images/heap.png)

     **[فهرست](#فهرست)**

394. ### event-table چیه؟

     `Event-Table` یه ساختار داده‌ای‌ـه که تمام رویدادهایی رو که به صورت ناهمزمان اجرا می‌شن، مثل بعد از مدتی فاصله زمانی یا پس از رفع بعضی از درخواست‌های API، ذخیره و ردیابی میکنه. یعنی هر زمان که یه تابع setTimeout رو فراخوانی کنیم یا عملیات async رو فراخوانی کنیم به جدول رویداد اضافه می‌شه. توابع رو به تنهایی اجرا نمیکنه. هدف اصلی جدول رویدادها پیگیری رویدادها و فرستادنشون به صف رویداد همونطور که توی نمودار زیر می‌بینیم.

     ![Screenshot](images/event-table.png)

     **[فهرست](#فهرست)**

395. ### صف microTask چیه؟

     `Microtask Queue` صف جدیدیه که تو اون تمام وظایف آغاز شده توسط آبجکت Promise قبل از صف برگشت پردازش میشن
     صف microtask قبل از کارهای رندر و نقاشی بعدی پردازش می‌شه. اما اگه این ریزکارها برای مدت طولانی اجرا شن، منجر به مشکل بصری میشن.

     **[فهرست](#فهرست)**

396. ### تفاوت بین shim و polyfill چیه؟

     shim کتابخونه‌ایه که یه API جدید رو با استفاده از ابزارهای اون محیط به یه محیط قدیمی تر میاره. لزوماً محدود به یه برنامه وب نیست. برای مثال، es5-shim.js برای شبیه سازی ویژگی‌های ES5 توی مرورگرهای قدیمی (عمدتا قبل از IE9) استفاده می‌شه.
     در حالی که polyfill یه قطعه کد (یا افزونه) اس که فناوری رو ارائه میکنه که شما، توسعه‌دهنده، از مرورگر انتظار دارید که به صورت بومی ارائه کنه.

     تو یه جمله ساده، polyfill یه shim برای APIهای مرورگره.

     **[فهرست](#فهرست)**

397. ### چطوری متوجه primitive یا غیر primitive بودن یه نوع داده میشیم؟

     در جاواسکریپت، دیتای `primitive` عبارتند از `boolean،` `string،` `number،` `BigInt،` `null،` `Symbol` و `undefined`. در حالی که انواع غیر primitive شامل Object‌ها می‌شه. اما با تابع زیر می‌تونیم به راحتی اونا رو شناسایی کنیم

     <span dir="ltr" align="left">

     ```js
     const myPrimitive = 30;
     const myNonPrimitive = {};
     function isPrimitive(val) {
       return Object(val) !== val;
     }

     isPrimitive(myPrimitive);
     isPrimitive(myNonPrimitive);
     ```

     </span>

     اگه مقدار یه نوع داده اولیه باشه، سازنده Object یه آبجکت wrapper جدید برای مقدار ایجاد میکنه. اما اگه مقدار یه نوع داده non-primitive (یک آبجکت) باشه، سازنده Object همون آبجکت رو میده.

     **[فهرست](#فهرست)**

398. ### babel چیه؟

     Babel یه ترانسپایلر جاواسکریپت برای تبدیل کد ECMAScript 2015+ به یه نسخه سازگار جاواسکریپت تو مرورگرها یا محیط‌های فعلی و قدیمی تره. که میشه موارد زیر رو درموردش نوشت:

     1. تبدیل syntax
     2. ویژگی‌های Polyfill که در محیط هدف شما وجود نداره (با استفاده از @babel/polyfill)
     3. تبدیل کد منبع

     **[فهرست](#فهرست)**

399. ### آیا Node.js به شکل کامل تک thread کار میکنه؟

     Node یه رشته است، اما بعضی از توابع موجود توی کتابخونه استانداره Node.js (برای مثال، توابع ماژول fs) تک رشته‌ای نیستن. یعنی منطق اونا خارج از رشته Node.js اجرا می‌شه تا سرعت و عملکرد یه برنامه رو بهبود بخشد.

     **[فهرست](#فهرست)**

400. ### کاربردهای مرسوم observableها کدوما هستن؟

     بعضی از رایج‌ترین موارد استفاده اش، سوکت‌های وب با اعلان‌ها، تغییرات ورودی کاربر، فواصل تکراری و غیره اس.

     **[فهرست](#فهرست)**

401. ### RxJS چیه؟

     RxJS (افزونه‌های واکنش‌گرا برای جاواسکریپت) کتابخونه‌ای برای پیاده‌سازی برنامه‌نویسی واکنش‌گرا با استفاده از `observables` که نوشتن کد ناهمزمان یا مبتنی بر تماس رو آسان‌تر میکنه. همچنین توابع کاربردی رو برای ایجاد و کار با مشاهده پذیرها فراهم میکنه.

     **[فهرست](#فهرست)**

402. ### تفاوت بین Function-constructor و function-declaration چیه؟

     توابعی که با `Function-constructor` ایجاد می‌شن، برای زمینه‌های ایجاد خود بسته ایجاد نمی‌کنن، اما همیشه در محدوده جهانی ایجاد میشن یعنی تابع فقط میتونه به متغیرهای محلی خود و متغیرهای دامنه جهانی دسترسی داشته باشه. در حالی که اعلان‌های تابع میتونن به متغیرهای تابع بیرونی (بسته شدن) هم دسترسی داشته باشن.

     بیاین این تفاوت رو با یه مثال ببینیم،

     **Function Constructor:**

     <span dir="ltr" align="left">

     ```js
     const a = 100;
     function createFunction() {
       const a = 200;
       return new Function("return a;");
     }
     console.log(createFunction()()); // 100
     ```

     </span>

     **Function declaration:**

     <span dir="ltr" align="left">

     ```js
     const a = 100;
     function createFunction() {
       const a = 200;
       return function func() {
         return a;
       };
     }
     console.log(createFunction()()); // 200
     ```

     </span>

     **[فهرست](#فهرست)**

403. ### شرط Short-circuit یا اتصال کوتاه چیه؟

     شرایط اتصال کوتاه برای روش خلاصه‌شده نوشتن دستورات if ساده استفاده میشه. بیاین سناریو رو با استفاده از یه مثال نشون بدیم. اگه بخوایم وارد پورتالی با شرایط احراز هویت بشیم، کد جاوااسکریپتمون به این شکل نوشته میشه:

     <span dir="ltr" align="left">

     ```js
     if (authenticate) {
       loginToPorta();
     }
     ```

     </span>

     از اونجایی که عملگرهای منطقی جاواسکریپت از چپ به راست ارزیابی میشن عبارت بالا رو می‌شه با استفاده از عملگر منطقی && ساده کرد.

     <span dir="ltr" align="left">

     ```js
     authenticate && loginToPorta();
     ```

     </span>

     **[فهرست](#فهرست)**

404. ### ساده‌ترین روش برای تغییر سایز یه آرایه چیه؟

     ویژگی length یه آرایه برای تغییر اندازه یا خالی کردن سریع آرایه اس. بیاین ویژگی length رو روی آرایه اعداد اعمال کنیم تا تعداد عناصر رو از 5 به 2 تغییر بدیم:

     <span dir="ltr" align="left">

     ```js
     const array = [1, 2, 3, 4, 5];
     console.log(array.length); // 5

     array.length = 2;
     console.log(array.length); // 2
     console.log(array); // [1,2]
     ```

     </span>

     و آرایه رو هم می‌شه خالی کرد:

     <span dir="ltr" align="left">

     ```js
     const array = [1, 2, 3, 4, 5];
     array.length = 0;
     console.log(array.length); // 0
     console.log(array); // []
     ```

     </span>

     **[فهرست](#فهرست)**

405. ### observable چیه؟

     `Observable` اساساً تابعیه که میتونه جریانی از مقادیر رو به صورت همزمان یا ناهمزمان به یه ناظر در طول زمان برگردونه. مصرف کننده میتونه با فراخوانی متد `subscribe` مقدار رو دریافت کنه.
     بیاین به یه مثال ساده از یه Observable نگاه کنیم:

     <span dir="ltr" align="left">

     ```js
     import { Observable } from "rxjs";

     const observable = new Observable((observer) => {
       setTimeout(() => {
         observer.next("Message from a Observable!");
       }, 3000);
     });

     observable.subscribe((value) => console.log(value));
     ```

     </span>

     ![Screenshot](images/observables.png)

     **توجه:** Observableها هنوز بخشی از زبان جاواسکریپت نیستن اما پیشنهاد شده که به زبان اضافه بشن.

     **[فهرست](#فهرست)**

406. ### تفاوت‌های بین توابع و کلاس‌ها چیه؟

     تفاوت اصلی بین اعلان‌های تابع و اعلان‌های کلاس `hoisting` هس. اعلان‌های تابع میشن hoist اما اعلان‌های کلاس نه.

     **Classes:**

     <span dir="ltr" align="left">

     ```js
     const user = new User(); // ReferenceError

     class User {}
     ```

     </span>

     **Constructor Function:**

     <span dir="ltr" align="left">

     ```js
     const user = new User(); // No error

     function User() {}
     ```

     </span>

     **[فهرست](#فهرست)**

407. ### تابع async چیه؟

     یه تابع async تابعیه که با کلمه کلیدی `async` اعلام شده که با اجتناب از زنجیره پرامیس رفتار ناهمزمان و مبتنی بر قول به سبک تمیزتری نوشته شه. این توابع میتونن شامل صفر یا بیشتر عبارت `await` باشن.

     بیاین یه مثال تابع همگام زیر رو در نظر بگیریم،

     <span dir="ltr" align="left">

     ```js
     async function logger() {
       const data = await fetch("http://someapi.com/users"); // pause until fetch returns
       console.log(data);
     }
     logger();
     ```

     </span>

     این اساساً خوبی نحوی بیش از پرامیس‌ها و توابع جنریتور ES2015 هست.

     **[فهرست](#فهرست)**

408. ### چطوری خطاهای ایجاد شده هنگام استفاده از Promiseها رو کنترل کنیم؟

     موقع استفاده از کدهایasync و ناهمزمان، Promiseهای ES6 میتونن زندگی برنامه‌نویس رو بدون داشتن ترس از callbackها و مدیریت خطا در هر خط آسان‌تر می‌کنن. اما Promiseها مشکلاتی دارن و بزرگ‌ترین اونا به‌طور پیش‌فرض مخفی کردن خطاهاس.

     فرض کنیم انتظار دارین برای تمام موارد زیر یه خطا توی کنسول چاپ بشه.

     <span dir="ltr" align="left">

     ```js
     Promise.resolve("promised value").then(() => {
       throw new Error("error");
     });

     Promise.reject("error value").catch(() => {
       throw new Error("error");
     });

     new Promise((resolve, reject) => {
       throw new Error("error");
     });
     ```

     </span>

     اما خیلی از محیط‌های جاواسکریپت مدرن وجود دارن که هیچ خطایی رو چاپ نمی‌کنن. می‌تونیم این مشکل رو به روش‌های مختلف حل کنیم.

     1. **اضافه کردن یه بلوک catch به اخر هر زنجیره:** ما میتونیم یه بلوک `catch` به أخر زنجیره پرامیس‌هامون اضافه گنیم

     <span dir="ltr" align="left">

     ```js
     Promise.resolve("promised value")
       .th(() => {
         throw new Error("error");
       })
       .catch((error) => {
         console.error(error.stack);
       });
     ```

     </span>

     اما تایپ کردن برای هر زنجیره پرامیس‌ها و پرمخاطب هم خیلی سخته.

     2. **اضافه کردن متد done:** می‌تونیم ابتدا راه حل‌ها رو جایگزین کنیم و بعد با روش انجام شده بلوک‌ها رو بگیریم

     <span dir="ltr" align="left">

     ```js
     Promise.resolve("promised value").done(() => {
       throw new Error("error");
     });
     ```

     </span>

     فرض کنیم می‌خواییم داده‌ها رو با استفاده از HTTP fetch کنیم و بعداً پردازش داده‌های حاصل رو به صورت ناهمزمان انجام بدیم. می‌تونیم بلوک done رو به صورت زیر بنویسیم.

     <span dir="ltr" align="left">

     ```js
     getDataFromHttp()
       .then((result) => processDataAsync(result))
       .done((processed) => {
         displayData(processed);
       });
     ```

     </span>

     در آینده، اگه API کتابخونه پردازش به همگام تغییر کنه، می‌تونیم بلوک done رو حذف کنیم.

     <span dir="ltr" align="left">

     ```js
     getDataFromHttp().then((result) => displayData(processDataAsyn(result)));
     ```

     </span>

     سپس فراموش کردین که بلوک «انجام شد» رو به بلوک then اضافه کنیم که منجر به خطاهای خاموش می‌شه.

     3. **Extend ES6 Promises by Bluebird:**

        Bluebird-API میاد Promiseهای اکما اسکریپت رو گسترش میده تا در راه حل دوم مشکلی ایجاد نشه. این کتابخونه یه کنترل کننده "پیش فرض" در Rejection هس که تمام خطاها رو از Promises رد شده به stderr چاپ میکنه. پس از نصب، می‌تونیم ردهای کنترل نشده رو پردازش کنیم

     <span dir="ltr" align="left">

     ```js
     Promise.onPossiblyUnhandledRejection((error) => {
       throw error;
     });
     ```

     </span>

     یه reject رو انجام بدین فقط با یه catch خالی اونو مدیریت کنیم

     <span dir="ltr" align="left">

     ```js
     Promise.reject("error value").catch(() => {});
     ```

     </span>

     **[فهرست](#فهرست)**

409. ### Deno چیه؟

     Deno یه ران تایم(run-time) ساده، مدرن و ایمن برای جاواسکریپت و تایپ‌اسکریپته که از موتور جاواسکریپت V8 و زبان برنامه نویسی Rust استفاده میکنه و توسط رایان دال، خالق نود جی اس استارت توسعه‌اش زده شده.

     **[فهرست](#فهرست)**

410. ### توی جاواسکریپت چطوری یه object قابل پیمایش درست کنیم؟

     به طور پیش فرض، آبجکت‌ها`argument` ساده قابل تکرار نیستن. اما می‌تونیم با تعریف ویژگی «Symbol.iterator» روی اون شی رو قابل تکرار کنیم.

     بیاین این رو با یه مثال نشون بدیم،

     <span dir="ltr" align="left">

     ```js
     const collection = {
       one: 1,
       two: 2,
       three: 3,
       [Symbol.iterator]() {
         const values = Object.keys(this);
         let i = 0;
         return {
           next: () => ({
             value: this[values[i++]],
             done: i > values.length,
           }),
         };
       },
     };

     const iterator = collection[Symbol.iterator]();

     console.log(iterator.next()); // → {value: 1, done: false}
     console.log(iterator.next()); // → {value: 2, done: false}
     console.log(iterator.next()); // → {value: 3, done: false}
     console.log(iterator.next()); // → {value: undefined, done: true}
     ```

     </span>

     فرآیند بالا رو می‌شه با استفاده از یه تابع مولد ساده کرد:

     <span dir="ltr" align="left">

     ```js
     const collection = {
       one: 1,
       two: 2,
       three: 3,
       *[Symbol.iterator]() {
         for (const key in this) {
           yield this[key];
         }
       },
     };
     const iterator = collection[Symbol.iterator]();
     console.log(iterator.next()); // {value: 1, done: false}
     console.log(iterator.next()); // {value: 2, done: false}
     console.log(iterator.next()); // {value: 3, done: false}
     console.log(iterator.next()); // {value: undefined, done: true}
     ```

     </span>

     **[فهرست](#فهرست)**

411. ### روش مناسب برای فراخوانی توابع بازگشتی چیه؟

     فراخونی دنباله یه فراخوانی فرعی یا تابعیه که به عنوان آخرین عمل یه تابع فراخوانی انجام می‌شه. در حالی که **فراخوانی دنباله مناسب (PTC)** تکنیکیه که تو اون برنامه یا کد فریم‌های پشته ای(stack) اضافی برای بازگشت ایجاد نمیکنه، زمانی که فراخوانی تابع یه فراخوانی دنباله اس.

     برای مثال، بازگشت کلاسیک یا سر تابع فاکتوریل پایین به پشته(stack) برای هر مرحله بستگی داره. هر مرحله باید تا "n \* فاکتوریل(n - 1)" پردازش شه:

     <span dir="ltr" align="left">

     ```js
     function factorial(n) {
       if (n === 0) {
         return 1;
       }
       return n * factorial(n - 1);
     }
     console.log(factorial(5)); // 120
     ```

     </span>

     اما اگه از callbackها Tail استفاده می‌کنیم اونا تمام داده‌های لازم رو که بهش نیاز داره رو بدون تکیه بر پشته(stack)، موقع برگشت به پایین منتقل می‌کنن.

     <span dir="ltr" align="left">

     ```js
     function factorial(n, acc = 1) {
       if (n === 0) {
         return acc;
       }
       return factorial(n - 1, n * acc);
     }
     console.log(factorial(5)); // 120
     ```

     </span>

     الگوی بالا همون خروجی مورد اول رو برمی‌گردونه. اما انباشت کننده کل رو به عنوان آرگومان بدون استفاده از حافظه پشته توی callBack ردیابی میکنه.

     **[فهرست](#فهرست)**

412. ### چطوری بررسی کنیم که یه آبجکت Promise هست یا نه؟

     اگه نمی‌دونیم یه مقدار یه Promise هس یا نه، مقدار رو به صورت `Promise.resolve(value)` بپیچید که یه قول رو برمی‌گردونه.

      <span dir="ltr" align="left">

     ```js
     function isPromise(object) {
       if (Promise && Promise.resolve) {
         return Promise.resolve(object) === object;
       }
       throw "Promise not supported in your environment";
     }

     const i = 1;
     const promise = new Promise((resolve, reject) => {
       resolve();
     });

     console.log(isPromise(i)); // false
     console.log(isPromise(p)); // true
     ```

      </span>

     راه دیگر اینه که نوع handler.then رو بررسی کنیم

      <span dir="ltr" align="left">

     ```js
     function isPromise(value) {
       return Boolean(value && typeof value.then === "function");
     }
     const i = 1;
     const promise = new Promise((resolve, reject) => {
       resolve();
     });

     console.log(isPromise(i)); // false
     console.log(isPromise(promise)); // true
     ```

      </span>

     **[فهرست](#فهرست)**

413. ### چطوری متوجه بشیم که یا تابع با تابع constructor صدا زده شده یا نه؟

     می‌تونیم از ویژگی شبه `new.target`ß برای تشخیص اینکه آیا یه تابع به عنوان سازنده (با استفاده از عملگر جدید) فراخوانی شده یا به عنوان یه فراخوانی تابع معمولی استفاده کنیم.

     1. اگه سازنده یا تابعی با استفاده از عملگر جدید فراخوانی شه، new.target یه مرجع به سازنده یا تابع برمی‌گردونه.
     2. برای فراخوانی تابع، new.target تعریف نشده اس.

      <span dir="ltr" align="left">

     ```js
     function Myfunc() {
       if (new.target) {
         console.log("called with new");
       } else {
         console.log("not called with new");
       }
     }

     new Myfunc(); // called with new
     Myfunc(); // not called with new
     Myfunc.call({}); // not called with new
     ```

      </span>

     **[فهرست](#فهرست)**

414. ### تفاوت‌های بین آبجکت argument و پارامتر rest چیه؟

     1. آبجکت `argument` آرایه ماننده اما آرایه نیست. در حالی که توی Rest پارامتر‌ها آرایه هستن.
     2. آبجکت `argument` از روش‌هایی مانند sort، map، forEach یا pop پشتیبانی نمیکنه. در حالی که این روش‌ها رو می‌شه رو پارامترهای Rest استفاده کرد.
     3. توی Rest پارامتر‌ها فقط اونایی هستن که نام جداگانه ای به اونا داده نشده در حالی که آبجکت `argument` شامل تمام آرگومان‌های ارسال شده به تابعه.

     **[فهرست](#فهرست)**

415. ### تفاوت‌های بین عملگر spread و پارامتر rest چیه؟

     پارامتر Rest تمام عناصر باقی مانده رو تو یه آرایه جمع آوری میکنه. در حالی که عملگر Spread به تکرارپذیرها (آرایه‌ها / اشیاء / رشته‌ها) اجازه میده تا به آرگومان‌ها / عناصر منفرد گسترش پیدا کنن. یعنی پارامتر Rest مخالف عملگر spread هس.

     **[فهرست](#فهرست)**

416. ### نوع‌های مختلف generatorها کدوما هستن؟

     1. **تعریف بیانی تابع generator :**

       <span dir="ltr" align="left">

     ```js
     function* myGenFunc() {
       yield 1;
       yield 2;
       yield 3;
     }
     const genObj = myGenFunc();
     ```

       </span>

     2. **تعریف عبارتی تابع generator:**

       <span dir="ltr" align="left">

     ```js
     const myGenFunc = function* () {
       yield 1;
       yield 2;
       yield 3;
     };
     const genObj = myGenFunc();
     ```

       </span>

     3. **تعریف بیانی تابع generator در آبجکت به صورت متد:**

       <span dir="ltr" align="left">

     ```js
     const myObj = {
       *myGeneratorMethod() {
         yield 1;
         yield 2;
         yield 3;
       },
     };
     const genObj = myObj.myGeneratorMethod();
     ```

       </span>

     4. **تعریف تابع generator در کلاس‌ها:**

       <span dir="ltr" align="left">

     ```js
     class MyClass {
       *myGeneratorMethod() {
         yield 1;
         yield 2;
         yield 3;
       }
     }
     const myObject = new MyClass();
     const genObj = myObject.myGeneratorMethod();
     ```

       </span>

     5. **تعریف تابع generator به عنوان یک ویژگی محاسبه شده:**

       <span dir="ltr" align="left">

     ```js
     const SomeObj = {
       *[Symbol.iterator]() {
         yield 1;
         yield 2;
         yield 3;
       },
     };

     console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
     ```

       </span>

     **[فهرست](#فهرست)**

417. ### iterableهای built-in کدوما هستن؟

     1. آرایه‌ها و TypedArrays
     2. رشته‌ها: روی هر کاراکتر یا نقاط کد یونیکد تکرار کنیم
     3. Map: روی جفت‌های کلید-مقدار آن تکرار شه
     4. مجموعه‌ها: روی عناصر خود تکرار می‌شه
     5. آرگومان‌ها: یه متغیر خاص آرایه مانند در توابع
     6. مجموعه DOM مانند NodeList

     **[فهرست](#فهرست)**

418. ### تفاوت‌های بین حلقه for...of و for...in چیه؟

     از for...in و for...of برای پیمایش بر روی داده ها با خاصیت تکرار (مثل آرایه ها)، استفاده می‌شه. تنها تفاوت در مورد چیزیه که اونا تکرار میکنن:

     1. for..in روی تمام کلیدهای خصوصیت شمارش پذیر یه شی تکرار می‌شه
     2. for..of iterates بیش از مقادیر یه شی قابل تکرار.

     بیاین این تفاوت رو توی یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```js
     const arr = ["a", "b", "c"];

     arr.newProp = "newVlue";

     // key are the property keys
     for (const key in arr) {
       console.log(key);
     }

     // value are the property values
     for (const value of arr) {
       console.log(value);
     }
     ```

     </span>

     از اونجا که حلقه for..in روی کلیدهای شی تکرار می‌شه حلقه اول 0، 1، 2 و newProp رو در حین تکرار روی شی آرایه ثبت میکنه. حلقه for..of روی مقادیر یه ساختار داده arr تکرار می‌شه و a، b، c رو تو کنسول ثبت میکنه.

     **[فهرست](#فهرست)**

419. ### چطوری propertyهای instance و غیر instanceای تعریف می‌کنی؟

     خصوصیات Instance باید در داخل متدهای کلاس تعریف بشن. برای مثال، مشخصات نام و سن سازنده داخلی هم مثل مثال پایین تعریف میشن.

     <span dir="ltr" align="left">

     ```js
     class Person {
       constructor(name, age) {
         this.name = name;
         this.age = age;
       }
     }
     ```

     </span>

     اما خصوصیات داده Static(class) و prototype باید خارج از اعلان ClassBody تعریف بشن. بیاین مقدار سن رو برای کلاس Person به صورت زیر اختصاص بدیم.

     <span dir="ltr" align="left">

     ```js
     Person.staticAge = 30;
     Person.prototype.prototypeAge = 40;
     ```

     </span>

     **[فهرست](#فهرست)**

420. ### تفاوت‌های بین isNaN و Number.isNaN کدوما هستن؟

     1. **isNaN**: تابع سراسری «isNaN» آرگومان رو به عدد تبدیل میکنه و اگه مقدار حاصل NaN باشه، true رو برمی‌گردونه.

     <br />

     2. **Number.isNaN**: این روش آرگومان رو تبدیل نمیکنه. اما زمانی که نوع یه عدد و مقدار NaN باشه مقدار true رو برمی‌گردونه.

     <br />

     بیاین تفاوت رو با یه مثال ببینیم:

     <span dir="ltr" align="left">

     ```js
     isNaN("hello"); // true
     Number.isNaN("hello"); // false
     ```

     </span>

     **[فهرست](#فهرست)**

</div>
